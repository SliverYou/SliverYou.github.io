<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Base58 & Base64]]></title>
    <url>%2F2018%2F05%2F27%2Flearn-base58%2F</url>
    <content type="text"><![CDATA[“你看看就知道了💰。” 前言在学习比特币源码的时候，发现了 Base58 算法，之前倒是知道 Base64，就像这样： 123456import base64e = base64.b64encode((b"How are you?"))print(e)d = base64.b64decode(e)print(d) 输出结果为： 12b'SG93IGFyZSB5b3U/'b'How are you?' 那…Base64 又是啥…？ Base64由来首先，为什么会有 Base64 编码呢？ 因为有些网络传送渠道并不支持所有的字节，例如传统的邮件只支持可见字符的传送，像 ASCII 码的一些特殊字符就不能通过邮件传送。这样用途就受到了很大的限制，比如图片二进制流的每个字节不可能全部是可见字符，所以就传送不了。最好的方法就是在不改变传统协议的情况下，做一种扩展方案来支持二进制文件的传送。把不可打印的字符也能用可打印字符来表示，问题也就可以解决了。 因此，Base64 编码应运而生，Base64 就是一种基于64个可打印字符来表示二进制数据的表示方法。 索引表 根据如上的 base64 索引表，可以看到它的字符集选用了 A-Z、a-z、0-9、+、/ 64个可打印字符。数值就代表字符的索引。 原理因为 Base64 的索引表只有64个字符，如果要表达64个字符的话，使用6位 bit 即可完全表示（2的6次方为64）。 由于 Base64 的编码只用6个 bit 即可表示，而正常的字符是使用8个 bit 表示，8和6的最小公倍数是24，所以4个 Base64 字符可以表示3个标准的 ASCII 字符。 如图，b1，b2，b3，3个字节分成了4个 Base64 的索引，得到索引后查表，即获得相应的4个字符，也就是编码后的字符串。 所以，Base64 编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。 如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64 会用 \x00 在末尾补足后，再在编码的末尾加上1个或2个 = 号，表示补了多少字节，解码的时候，会自动去掉。 编码过程： 123456字符串 a b cASCII 97 98 998 bit 01100001-01100010-011000116 bit 011000-010110-001001-100011十进制 24 22 9 35对应编码 Y W J j 解码时，获取字符在表中的索引然后组合，每八个 bit 分组再编码为 ASCII 字符，即可完成 Base64 的解码。 Python 中 Base64Python 有现成 base64 模块，模块还实现了 Base32，Base16 等算法，在此不再赘述。 1234567891011import base64e64 = base64.b64encode(b"How are you?")print(e64)d64 = base64.b64decode(e64)print(d64)e32 = base64.b32encode(b"How are you?")print(e32)d32 = base64.b32decode(e32)print(d64) 输出结果为： 1234b'SG93IGFyZSB5b3U/'b'How are you?'b'JBXXOIDBOJSSA6LPOU7Q===='b'How are you?' Golang 中的 Base64Golang 中使用 encoding 下的 base64 包也可以快速实现 Base64 编码和解密： 1234567891011121314151617181920212223242526package mainimport ( "encoding/base64" "fmt")func main() &#123; eStand := base64.StdEncoding.EncodeToString([]byte("How are you?")) fmt.Println(eStand) dStand, err := base64.StdEncoding.DecodeString(eStand) if err != nil &#123; panic(err) &#125; fmt.Printf("%s\n", dStand) eURL := base64.URLEncoding.EncodeToString([]byte("http://home.junyouxiaowu.top/")) fmt.Println(eURL) dURL, err := base64.URLEncoding.DecodeString(eURL) if err != nil &#123; panic(err) &#125; fmt.Printf("%s\n", dURL)&#125; 输出结果为： 1234SG93IGFyZSB5b3U/How are you?aHR0cDovL2hvbWUuanVueW91eGlhb3d1LnRvcC8=http://home.junyouxiaowu.top/ Base58由来Base58 是用于比特币中使用的一种独特的编码方式，主要用于产生比特币的钱包地址。（所以附上下图） 相比 Base64，Base58 不使用数字”0”，字母大写”O”，字母大写”I”，和字母小写”l”，以及”+”和”/“符号。 设计 Base58 主要的目的是： 避免混淆。在某些字体下，数字0和字母大写O，以及字母大写I和字母小写l会非常相似 不使用”+”和”/“的原因是非字母或数字的字符串作为账号（地址）较难被接受 没有标点符号，通常不会被从中间分行 大部分的软件支持双击选择整个字符串 索引表 看表确实很明显，相比 Base64，Base58 删去了一些字符。 原理Base58 的原理与 Base64 差不多，但因为58不是2的倍数，只能先将二进制比特流转化为大数后不断模58，才能进行编码。 解码时，遍历编码字符串得到字符在表中的索引，然后输出结果不断乘以58再加上索引，最后重新编码成 ASCII 字符。 有个细节是 Base58 中是没有0的，所以编码时字节流中的前导0 0x00 需要记录下来，然后在最后编码时最前面加上索引表中索引为0对应的字符即可。 Base58 代码实现 Python 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from hashlib import sha256from binascii import hexlify, unhexlifyBASE58_ALPHABET = b"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"def base58encode(hexstring): # byteseq = bytes(unhexlify(bytes(hexstring, 'ascii'))) byteseq = bytes.fromhex(hexstring) n, leading_zeroes_count = 0, 0 for c in byteseq: n = n * 256 + c if n == 0: leading_zeroes_count += 1 res = bytearray() while n &gt;= 58: div, mod = divmod(n, 58) res.insert(0, BASE58_ALPHABET[mod]) n = div else: res.insert(0, BASE58_ALPHABET[n]) return (BASE58_ALPHABET[0:1] * leading_zeroes_count + res).decode('ascii')def base58decode(base58_str): base58_text = bytes(base58_str, "ascii") n, leading_zeroes_count = 0, 0 for b in base58_text: n = n * 58 + BASE58_ALPHABET.find(b) if n == 0: leading_zeroes_count += 1 res = bytearray() while n &gt;= 256: div, mod = divmod(n, 256) res.insert(0, mod) n = div else: res.insert(0, n) return hexlify(bytearray(1 * leading_zeroes_count) + res).decode('ascii')s = sha256("Hello, I'm Sliver.".encode('ascii')).hexdigest()print(s)e = base58encode(s)print(e)d = base58decode(e)print(d) 输出结果为： 123785479510983164ebd04d38d51b5af8b4f16a9aa6177a8545f40ce7997e6130996idhybpuR5RpxaPqCp6j8Qa8prRdZuyUiKn8SLHsZK6785479510983164ebd04d38d51b5af8b4f16a9aa6177a8545f40ce7997e61309 Golang 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package mainimport ( "bytes" "crypto/sha256" "fmt" "math/big")var b58Alphabet = []byte("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")// Base58Encode 将一个字节切片转化为 Base58 编码数据func Base58Encode(input []byte) []byte &#123; var result []byte zeroBytes := 0 x := big.NewInt(0).SetBytes(input) base := big.NewInt(int64(len(b58Alphabet))) zero := big.NewInt(0) mod := &amp;big.Int&#123;&#125; for x.Cmp(zero) != 0 &#123; x.DivMod(x, base, mod) result = append(result, b58Alphabet[mod.Int64()]) &#125; for _, b := range input &#123; if b != 0x00 &#123; break &#125; zeroBytes++ &#125; result = append(result, bytes.Repeat([]byte&#123;b58Alphabet[0]&#125;, zeroBytes)...) // 尾部插入数据后再反转回来 ReverseBytes(result) return result&#125;// Base58Decode 解码一个 Base58 编码的数据func Base58Decode(input []byte) []byte &#123; result := big.NewInt(0) zeroBytes := 0 for _, b := range input &#123; if b != b58Alphabet[0] &#123; break &#125; zeroBytes++ &#125; payload := input[zeroBytes:] // 读取输入流中前导0之后的数据 for _, b := range payload &#123; charIndex := bytes.IndexByte(b58Alphabet, b) result.Mul(result, big.NewInt(58)) result.Add(result, big.NewInt(int64(charIndex))) &#125; decoded := result.Bytes() decoded = append(bytes.Repeat([]byte&#123;byte(0x00)&#125;, zeroBytes), decoded...) return decoded&#125;// ReverseBytes 将一个字节切片逆序func ReverseBytes(data []byte) &#123; for i, j := 0, len(data)-1; i &lt; j; i, j = i+1, j-1 &#123; data[i], data[j] = data[j], data[i] &#125;&#125;func main() &#123; content := []byte("Hello, I'm Sliver.") s := sha256.Sum256(content) fmt.Printf("%x\n", s) e := Base58Encode(s[:]) fmt.Println(string(e)) d := Base58Decode(e) fmt.Printf("%x\n", d)&#125; 输出结果为： 123785479510983164ebd04d38d51b5af8b4f16a9aa6177a8545f40ce7997e6130996idhybpuR5RpxaPqCp6j8Qa8prRdZuyUiKn8SLHsZK6785479510983164ebd04d38d51b5af8b4f16a9aa6177a8545f40ce7997e61309 参考 Base64原理解析 常用内建模块 - base64 WiKi - Base64 WiKi - Base58 Wiki - Base58Check encoding]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Go</tag>
        <tag>BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Merkle树和SPV简单支付验证]]></title>
    <url>%2F2018%2F05%2F26%2Fmerkletree-spv%2F</url>
    <content type="text"><![CDATA[“Merkle Tree，一棵神奇的树🌲。” Merkle Tree 基本概念HashHash 是一个把任意长度的数据映射成固定长度数据的函数（如 SHA256）。例如，对于数据完整性校验，最简单的方法是对整个数据做 Hash 运算得到固定长度的 Hash 值，然后把得到的 Hash 值公布在网上，这样用户下载到数据之后，对数据再次进行 Hash 运算，比较运算结果和网上公布的 Hash 值进行比较，如果两个 Hash 值相等，说明下载的数据没有损坏。可以这样做是因为输入数据的稍微改变就会引起 Hash 运算结果的面目全非，而根据 Hash 值反推原始输入数据的特征是困难的。 如果从一个稳定的服务器进行下载，采用单一 Hash 是可取的。但如果数据源不稳定，一旦数据损坏，就需要重新下载，这种下载的效率是很低的。 Hash List在点对点网络中作数据传输的时候，会同时从多个机器上下载数据，而且很多机器可以认为是不稳定或者不可信的。为了校验数据的完整性，更好的办法是把大的文件分割成小的数据块（例如，把分割成2K为单位的数据块）。这样的好处是，如果小块数据在传输过程中损坏了，那么只要重新下载这一快数据就行了，不用重新下载整个文件。 怎么确定小的数据块没有损坏哪？只需要为每个数据块做 Hash。BT 下载的时候，在下载到真正数据之前，我们会先下载一个 Hash 列表。那么问题又来了，怎么确定这个 Hash 列表本身是正确的哪？答案是把每个小块数据的 Hash 值拼到一起，然后对这个长字符串在作一次 Hash 运算，这样就得到 Hash 列表的根 Hash（Top Hash or Root Hash）。下载数据的时候，首先从可信的数据源得到正确的根 Hash，就可以用它来校验 Hash 列表了，然后通过校验后的 Hash 列表可以用来校验数据块。 Merkle TreeMerkle Tree，通常也被称作 Hash Tree，顾名思义，它就是存储 Hash 值的一棵树。Merkle Tree 的叶子是数据块（例如，文件或者文件的集合）的 hash 值。非叶节点是其对应子节点串联字符串的 hash 值。 Merkle Tree 可以看做 Hash List 的泛化（Hash List 也可以看作一种特殊的 Merkle Tree，即树高为2的多叉 Merkle Tree）。 在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应地哈希和它对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合并成一个字符串，然后运算这个字符串的哈希，这样每两个哈希就两两配对，得到了一个子哈希。如果最底层的哈希总数是单数，那到最后必然出现一个单身哈希，这种情况下可以直接对它进行哈希运算或者对它进行复制后再进行哈希运算，所以也能得到它的子哈希。于是往上推，依然是一样的方式，可以得到数目更少的新一级哈希，最终必然形成一棵倒挂的树，到了树根的这个位置，这一代就剩下一个根哈希了，我们把它叫做 Merkle Root。 在 P2P 网络下载网络之前，先从可信的源获得文件的 Merkle Tree 树根。一旦获得了树根，就可以从其他从不可信的源获取 Merkle tree。通过可信的树根来检查接受到的 Merkle Tree。如果 Merkle Tree 是损坏的或者虚假的，就从其他源获得另一个 Merkle Tree，直到获得一个与可信树根匹配的 Merkle Tree。 Merkle Tree 和 Hash List 的主要区别是，可以直接下载并立即验证 Merkle Tree 的一个分支。因为可以将文件切分成小的数据块，这样如果有一块数据损坏，仅仅重新下载这个数据块就行了。如果文件非常大，那么 Merkle tree 和 Hash list 都能完成任务，但是 Merkle tree 可以一次下载一个分支，然后立即验证这个分支，如果分支验证通过，就可以下载数据了。而 Hash list 只有下载整个 Hash list 才能验证。 Merkle Tree 基本操作创建Merckle Tree加入最底层有9个数据块。 step1：(红色线) 对数据块做 Hash 运算，Node0i = Hash(Data0i), i = 1, 2, …, 9 step2：(橙色线) 相邻两个 Hash 块串联，然后做 Hash 运算，Node1((i + 1)/2) = Hash(Node0i + Node0(i + 1)), i = 1, 3, 5, 7；对于i = 9, Node1((i + 1) / 2) = Hash(Node0i) step3：(黄色线) 重复step2 step4：(绿色线) 重复step2 step5：(蓝色线) 重复step2，生成Merkle Tree Root 易得，创建 Merkle Tree 是 O(n) 复杂度（这里指 O(n) 次 Hash 运算），n 是数据块的大小。得到 Merkle Tree 的树高是 log(n)+1。 检索数据块为了更好理解，我们假设有 A 和 B 两台机器，A 需要与 B 相同目录下有8个文件，文件分别是 f1，f2，f3，….，f8。这个时候我们就可以通过 Merkle Tree 来进行快速比较。假设我们在文件创建的时候每个机器都构建了一个 Merkle Tree。具体如下图: 从上图可得知，叶子节点 node7 的 value = Hash(f1)，是 f1 文件的 HASH；而其父亲节点 node3 的 value = Hash(v7, v8)，也就是其子节点 node7，node8 的值的 HASH。就是这样表示一个层级运算关系。root 节点的 value 其实是所有叶子节点的 value 的唯一特征。 假如 A 上的文件5与 B 上的不一样。我们怎么通过两个机器的 Merkle Tree 信息找到不相同的文件呢？这个比较检索过程如下： step1：首先比较 v0 是否相同，如果不同，检索其孩子 node1 和 node2 step2：v1 相同，v2 不同。检索 node2 的孩子node5 node6 step3：v5 不同，v6 相同，检索比较 node5 的孩子 node11 和 node12 step4：v11 不同，v12 相同。node11 为叶子节点，获取其目录信息 step5：检索比较完毕。 以上过程的理论复杂度是Log(N)。过程描述图如下: 从上图可以得知真个过程可以很快的找到对应的不相同的文件。 Merkle Tree 应用Merkle Proof 最早的应用是 Bitcoin，它是由中本聪在2009年描述并创建的。Bitcoin 的 Blockchain 利用 Merkle Proof 来存储每个区块的交易。 而这样做的好处，也就是中本聪描述到的 简化支付验证（Simplified Payment Verification，SPV）的概念：一个 轻客户端（Light Client）可以仅下载链的区块头即每个区块中的 80byte 的数据块，它仅包含六个元素，而不是要求下载每一笔交易以及每一个区块。 六个元素具体为： 版本号 上一个区块头的哈希值 时间戳 挖矿难度值（Bits） 工作量证明随机数（Nonce） 包含该区块所有交易的 Merkle Tree 的根哈希 如果客户端想要确认一个交易的状态，它只需简单的发起一个 Merkle Proof 请求，这个请求显示出这个特定的交易在 Merkle Tree 的一个之中，而且这个 Merkle Tree 的树根在主链的一个区块头中。 但是 Bitcoin 的轻客户端有它的局限。一个局限是，尽管它可以证明包含的交易，但是它不能进行涉及当前状态的证明（如数字资产的持有，名称注册，金融合约的状态等）。 Bitcoin 如何查询你当前有多少币？一个比特币轻客户端，可以使用一种协议，它涉及查询多个节点，并相信其中至少会有一个节点会通知你关于你的地址中任何特定的交易支出，而这可以让你实现更多的应用。但对于其他更为复杂的应用而言，这些远远是不够的。一笔交易影响的确切性质（precise nature），可以取决于此前的几笔交易，而这些交易本身则依赖于更为前面的交易，所以最终你需要验证整个链上的每一笔交易。 SPVSPV，也就是中本聪描述到的 简化支付验证，正是有了 SPV，才让区块链和比特币更加广泛的被传播和使用。 我们大部分人在电脑安装的比特币钱包都是轻量级（非全节点）的，也就是本地并没有所有的区块数据（上百G）。理论上来说，要验证一笔交易，钱包需要遍历所有的区块找到和该笔交易相关的所有交易进行逐个验证才是可靠的。 支付验证和交易验证SPV 指的是“支付验证“，而不是“交易验证”。这两种验证有很大区别。 “交易验证”非常复杂，涉及到验证是否有足够余额可供支出、是否存在双花、脚本能否通过等等，通常由运行完全节点的矿工来完成。 “支付验证”则比较简单，只判断用于“支付”的那笔交易是否已经被验证过，并得到了多少的算力保护（多少确认数）。 考虑这样一种情况：Alice 收到来自 Bob 的一个通知，Bob 声称他已经从某某账户中汇款一定数额的钱给了 Alice。在去中心方式下，没有任何人能证明 Bob 的可靠。接到这一通知，Alice 如何能判断 Bob 所说的是真的呢？ 在比特币系统中，这一通知是以一个固定格式的“交易”来实现的，该交易中包含 Bob 的汇款账户支票、Bob 的签名、汇给 Alice 的金额以及 Alice 的地址。 如果 Alice 想本人亲自验证这笔交易，首先，Alice 要遍历区块链账本，定位到 Bob 的账户上，这样才能查看 Bob 所给的账户支票上是否曾经有足够的金额；接下来，Alice 要遍历后续的所有账本，看 Bob 是否已经支出了这个账户支票上的钱给别人(是否存在双花欺骗）；然后还要验证脚本来判断 Bob 是否拥有该账户的支配权。这一过程要求 Alice 必须得到完整的区块链才行。 但是，如果 Alice 只想知道这笔支付是否已经得到了验证（如果验证了就发货），她可以依赖比特币系统来快速验证。即检查发生此项支付的那笔交易是否已经收录于区块链中，并得到了多少个确认。这也就是 SPV 的作用。 区块头 先来看看，如上图所示：每个数据区块包含区块头和区块体。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class CBlockHeader&#123;public: // header int32_t nVersion; uint256 hashPrevBlock; uint256 hashMerkleRoot; uint32_t nTime; uint32_t nBits; uint32_t nNonce; CBlockHeader() &#123; SetNull(); &#125; ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action) &#123; READWRITE(this-&gt;nVersion); READWRITE(hashPrevBlock); READWRITE(hashMerkleRoot); READWRITE(nTime); READWRITE(nBits); READWRITE(nNonce); &#125; void SetNull() &#123; nVersion = 0; hashPrevBlock.SetNull(); hashMerkleRoot.SetNull(); nTime = 0; nBits = 0; nNonce = 0; &#125; bool IsNull() const &#123; return (nBits == 0); &#125; uint256 GetHash() const; int64_t GetBlockTime() const &#123; return (int64_t)nTime; &#125;&#125;; 查看比特币源码也可以发现，区块头封装了当前版本号、前一区块哈希值、当前区块要求的随机数（Nonce）、时间戳、难度系数、以及 Merkle Root 信息。 区块体则包括当前区块经过验证的、区块创建过程中生成的所有交易记录。这些记录通过 Merkle Tree 的哈希过程生成唯一的 Merkle Root 并记入区块头。需要记住的是，中间过程中的那些 Hash 没有被保存，只是一些中间数据。 简单支付验证你也许会问，为什么要搞这么复杂？直接把所有交易数据保存起来，然后验证交易是否存在还不简单吗？之所以要这么干，是因为比特币发明之初，中本聪想到了一种轻钱包的实现，也就是 SPV 的设计蓝图。 SPV 节点不保存所有交易也不会下载整个区块，仅仅保存区块头，它通过区块头进行支付验证。毕竟，区块体保存了完整的交易信息，而交易信息需要的存储量大部分都是交易头的千倍以上。所以，如果只保存交易头，就可以极大的减少本地客户端存储的区块链信息。 但是，也不能因此让区块链无法工作啊。如果这个时候轻钱包要对某一个交易进行验证，而本地又没有这个交易的信息，那怎么验证呢？这时，区块头里面的 Merkle Root 就要起作用了。 验证路径在讲述轻钱包的验证过程之前，我们需要知道如何在 Merkle Tree 里面做验证。我们已知 Merkle Tree 里面父节点和子节点的运算关系，因此，当我们要证明一个叶子节点存在于这棵树时，只需要得到从该叶子节点到根的运算过程里面需要的那些 Hash 即可，并不需要所有叶子节点参与计算。 你可能觉得有点奇怪，为什么不直接把所有的叶子节点告诉它就行了，你用所有叶子节点能算出 Root Hash 就验证通过了。但事实就是这样，因为每一个父节点 Hash 一定是由两个子节点 Hash 运算得到，所以，我们只需要挑选出所有参与运算的节点，就可以证明这个叶子节点存在于树中。这样可以减少 Hash 运算的次数。而这些被挑选出来的节点，以及它们之间的层级关系，就是验证路径，即上图中 Merkle Root 那个盒子下面的所有盒子。 如何证明交易的真实性？比特币网络中的交易，只有已经被记录到区块链，并且已经得到6个确认的，才被认为是真实的，只有基于这些真实交易发起的新交易（输入与输出的概念），才是合法的。 我们询问一个交易是否真实，往往基于以下前提： 我们在问一个交易是否已被记录到区块链中 而且这个交易所在的区块链是最长的哪一条，没有在分叉链上 当每个节点接收到一条交易广播时，我们要查询作为一笔新交易的输入的真实性 矿工对交易进行打包之前，对所有的输入进行真实性验证（在矿工接收到交易信息时就已经验证过了，打包的时候验证2000条交易信息不可能） 那么对于 SPV 轻钱包而言，怎么知道一个交易是否真实的呢？SPV 拿到一个交易信息之后（比如接收到一笔钱），并不能确认这个交易是否合法，因此要对这个交易的输入进行验证。但是它只拿到了单个交易的信息，而没有本地的完整区块链数据，因此，SPV 要拿着这个交易的信息向网络发起查询请求，这个请求被称为 Merkle Block Message。当其他有完整区块链数据的客户端收到这个请求之后，利用传过来的交易信息在自己的区块链数据库中进行查询，并把验证路径返回给请求源，SPV 拿到验证路径之后，再做一次 Merkle 校验，确认无误之后，就认为这个交易是可信的。 现在的问题是： 怎么从区块链里面查一个交易？ 怎么获取 Merkle 验证路径？ 怎么确保网络上这个返回的验证路径不是伪造的？ 当比特币网络需要利用 SPV 进行简单支付验证时步骤如下： 计算待验证支付的交易哈希值； 节点从区块链网络上获取并存储最长链的所有区块头至本地； 节点从区块链获取待验证支付对应的 Merkle Tree 认证路径； 根据认证路径，计算 Merkle Tree 的根哈希值，将计算结果与本地区块头中的 Merkle Tree 根哈希值进行比较，定位到包含待验证支付的区块； 根据该区块头所处的位置，验证该区块的区块头是否已经包含在已知最长链中，并确定该支付已经得到的确认数量，如果包含则证明支付真实有效。（交易得到6次确认） 从区块链查交易区块链的数据结构是离散的，要得到一个交易的验证路径，必须得到这个交易所在的区块链。这是一个复制的查询过程，可能需要把所有的区块都遍历一遍才能找到。因此，blockchain.info 这样的网站孕育而生，帮助你通过一个信息查这个信息在区块链上的所有相关记录。但是对于客户端而言，可没那么容易，它不能信任 blockchain.info 这个网站，只能信任自己本地存储的区块链。所以，只能用比较合理的算法，去优化交易查询。 一种设计是，把每一个区块的数据结构修改为关系型数据库，通过关系型数据库，可以用 SQL 语句快速查询。但是，要遍历查询所有区块链，是比较浪费的。还有一种想法是，利用交易的时间戳来快速定位区块位置，在临近的几个区块中快速找到它。 获取 Merkle 验证路径实际上，Merkle 的验证路径生成的前提是已经存在一棵完整的 Merkle 树。市面上有很多 Merkle Tree 的实现包，有的包直接给出来 getProof 的方法来获取某个叶子节点的验证路径。 在客户端收到 Merkle Block Message 之后，要执行下面的步骤： 通过上述方法找到包含该交易的区块 检查该区块是否是整个网络中最长链条里面的 取出所有交易生成的 Merkle Tree，利用 getProof 方法得到该交易的验证路径 将该验证路径发送回请求源 SPV 得到响应之后，要做如下验证： 同步区块链，确保是整个网络中最长的一条 先拿到 Merkle Root 去区块链中查找，确保该 Merkle Root 是在链条中 利用拿到的验证路径，再进行一次 Merkle 校验，确保验证路径全部合法 为什么 SPV 还要再做一次 Merkle 校验呢？主要是为了确保响应方发送的验证路径的有效性。 确保验证路径的真实性上面提到了 SPV 还要做一次 Merkle 校验，这也是“不信任”的表现之一。我们并不确保响应我们的节点不会作弊或欺诈，因此，我们要自己进行校验。但是，有没有可能虽然校验过程顺利，但是实际上校验路径是伪造的呢？ 我们来做一个假设：1）Merkle Root 为真；2）交易为假；3）路径中的 Hash 可真可假。这个假设是否成立？ 我们知道，不同字符串碰撞到同一个 SHA256 的概率极小，那么 Double SHA256 的概率就更小了，而Merkle Root 是经过一层一层计算上来的，一个区块有那么多交易，要经过 Merkle 运算得到一个相同的Hash，几乎是不可能的，因此，在 Merkle 验证中用一个伪造的交易 Hash 来得到一个已知来 Merkle Root 是不可能的。 如果还想更进一步校验，可以在区块头中存储区块打包的交易的数量，这样就可以知道从交易 Hash 到Merkle Root 需要经过几层的运算。这也是一个检验点。 SPV 面临的问题 与区块链系统的矛盾 SPV 面临的第一个是问题是 SPV 节点与区块链系统去中心化程度似乎存在一定的矛盾。随着 SPV 节点数量的增多，那么区块链参与完整验证的节点数量就会减少。然而，SPV 却不能完全独立构成区块链。由于 SPV 节点没有存储完整的区块链信息，SPV 的实现离不开存储区块链完整信息的节点或系统的辅助。 可锻性攻击 SPV 面临的第二个问题是交易可锻性攻击。由于 SPV 实现中一个关键步骤是根据支付哈希值定位其在区块中的位置，而该过程可能遭遇交易可锻性攻击。 比如比特币系统中，交易可锻性攻击体现在交易 ID 可被伪造，而交易 ID 可被伪造的原因是比特币签名算法不够完善。 以比特币为例，交易可锻性攻击的过程如下： 在比特币的交易中，第三方交易系统会将交易发送方、接受方、交易金额等数据作为一个交易发送到比特币网络中，发送之前会对这条交易信息进行加密和签名，接着根据生成的签名最终获得一个哈希值，这个哈希值作为交易 ID 返回给提现的用户。 一次交易请求过后，用户接收到的仅有一个交易 ID，根据这个交易 ID 可以查看交易是否成功。 当交易发送到比特币网络中后，网络中的各个节点会根据之前生成的签名来验证交易的真实性。 问题就出在签名算法上：椭圆曲线数字签名 ECDSA 这个算法的一个问题是，修改签名的某个字节能够使签名依然校验成功，这样伪造签名之后交易依然能够成功进行。 由于交易 ID 是根据签名生成的，而伪造之后的签名会生成一个完全不同的交易 ID，第三方判断到两个 ID 不同便会确定当前交易失败，而事实上交易已经成功了。这时如果用户发现交易提示失败，可以再次发起交易，第三方交易系统一看之前交易确实失败了，那就会再进行一次交易。 这时用户的比特币钱包里就会多收到一份比特币，也就造成了第三方交易平台资金损失。 交易的可锻性体现在虽然交易签名被“锻造过”（即修改伪造过），但最终的交易依然有效。上述攻击对于 SPV 是有效的，因为在交易可锻性攻击场景中，伪造的交易和正常的交易都在区块链网络中，如果伪造的交易先被处理，那么攻击就成功。从而，SPV 支付在区块链中的位置定位过程可能无法完成或出现错误，最终影响支付验证的进程和准确性。 总结说了这么多，SPV 其实就是对 Merkle Tree 的一种应用，现在重现一下过程： SPV 节点想要确认交易是否在区块链中并得到6次确认（即成功收款），不需要下载整个区块链的最长链，只需要下载最长链的每个区块头 SPV 节点可以对每个即将到来的交易进行过滤接收，获取与自己有关的交易，筛选后获得交易信息 SPV 节点拿着交易信息，发起 Merkle Block Message，询问全节点 Merkle 路径 收到 Merkle Block Message 的全节点，通过交易时间戳等信息，定位到拥有该交易的区块，计算并返回 Merkle 路径 SPV 节点先从 Merkle 路径获取 Merkle Root，通过 Merkle Root 找到拥有该 Root 的区块 SPV 节点计算 Merkle 路径，判断最后计算值是否为 Merkle Root 计算成功，代表支付得到验证 参考 Merkle Tree 学习 比特币区块结构 Merkle 树及简单支付验证分析 区块链如何运用 Merkle Tree 验证交易真实性 SPV、SPV 节点和 SPV 钱包 区块链进阶：简单支付验证（SPV）]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Notes</tag>
        <tag>BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go标准库]]></title>
    <url>%2F2018%2F05%2F18%2Fgo-standard-library%2F</url>
    <content type="text"><![CDATA[“Golang 百宝箱。” ioio 包为 I/O 原语提供了基本的接口。它主要包装了这些原语的已有实现。 由于这些接口和原语以不同的实现包装了低级操作，因此除非另行通知，否则客户端不应假定它们对于并行执行是安全的。 在 io 包中最重要的是两个接口：Reader 和 Writer 接口。本章所提到的各种 IO 包，都跟这两个接口有关，也就是说，只要实现了这两个接口，它就有了 IO 的功能。 Reader 接口Reader 接口的定义如下： 123type Reader interface &#123; Read(p []byte) (n int, err error)&#125; 官方文档中关于该接口方法的说明： Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &lt;= n &lt;= len(p)） 以及任何遇到的错误。即使 Read 返回的 n &lt; len(p)，它也会在调用过程中使用 p 的全部作为暂存空间。若一些数据可用但不到 len(p) 个字节，Read 会照例返回可用的数据，而不是等待更多数据。 当 Read 在成功读取 n &gt; 0 个字节后遇到一个错误或 EOF (end-of-file)，它就会返回读取的字节数。它会从相同的调用中返回（非nil的）错误或从随后的调用中返回错误（同时 n == 0）。 一般情况的一个例子就是 Reader 在输入流结束时会返回一个非零的字节数，同时返回的 err 不是 EOF 就是 nil。无论如何，下一个 Read 都应当返回 0, EOF。 调用者应当总在考虑到错误 err 前处理 n &gt; 0 的字节。这样做可以在读取一些字节，以及允许的 EOF 行为后正确地处理 I/O 错误。 也就是说，当 Read 方法返回错误时，不代表没有读取到任何数据。调用者应该处理返回的任何数据，之后才处理可能的错误。 根据 Go 语言中关于接口和实现了接口的类型的定义（Interface_types），我们知道 Reader 接口的方法集（Method_sets）只包含一个 Read 方法，因此，所有实现了 Read 方法的类型都实现了 io.Reader 接口，也就是说，在所有需要 io.Reader 的地方，可以传递实现了 Read() 方法的类型的实例。 下面，我们通过具体例子来谈谈该接口的用法。 12345678func ReadFrom(reader io.Reader, num int) ([]byte, error) &#123; p := make([]byte, num) n, err := reader.Read(p) if n &gt; 0 &#123; return p[:n], nil &#125; return p, err&#125; ReadFrom 函数将 io.Reader 作为参数，也就是说，ReadFrom 可以从任意的地方读取数据，只要来源实现了 io.Reader 接口。比如，我们可以从标准输入、文件、字符串等读取数据，示例代码如下： 12345678910111213141516171819202122232425262728293031package mainimport ( "fmt" "io" "os" "strings")func main() &#123; data, err := ReadFrom(strings.NewReader("from string"), 12) if err != nil &#123; fmt.Println(err) &#125; fmt.Println(data) data, err = ReadFrom(os.Stdin, 11) if err != nil &#123; fmt.Println(err) &#125; fmt.Println(data)&#125;func ReadFrom(reader io.Reader, num int) ([]byte, error) &#123; p := make([]byte, num) n, err := reader.Read(p) if n &gt; 0 &#123; return p[:n], nil &#125; return p, err&#125; 输出结果为： 123[102 114 111 109 32 115 116 114 105 110 103]hello this is go[104 101 108 108 111 32 116 104 105 115 32] Tips: io.EOF 变量的定义：var EOF = errors.New(“EOF”)，是 error 类型。根据 reader 接口的说明，在 n &gt; 0 且数据被读完了的情况下，返回的 error 有可能是 EOF 也有可能是 nil。 Writer 接口Writer 接口的定义如下： 123type Writer interface &#123; Write(p []byte) (n int, err error)&#125; 官方文档中关于该接口方法的说明： Write 将 len(p) 个字节从 p 中写入到基本数据流中。它返回从 p 中被写入的字节数 n（0 &lt;= n &lt;= len(p)）以及任何遇到的引起写入提前停止的错误。若 Write 返回的 n &lt; len(p)，它就必须返回一个 非nil 的错误。 同样的，所有实现了 Write 方法的类型都实现了 io.Writer 接口。 在 fmt 标准库中，有一组函数：Fprint/Fprintf/Fprintln，它们接收一个 io.Wrtier 类型参数（第一个参数），也就是说它们将数据格式化输出到 io.Writer 中。那么，调用这组函数时，该如何传递这个参数呢？ 以 fmt.Fprintln 为例，同时看一下 fmt.Println 函数的源码： 123func Println(a ...interface&#123;&#125;) (n int, err error) &#123; return Fprintln(os.Stdout, a...)&#125; 很显然，fmt.Println 会将内容输出到标准输出中。 ReaderAt 和 WriterAt 接口ReaderAt 接口的定义如下： 123type ReaderAt interface &#123; ReadAt(p []byte, off int64) (n int, err error)&#125; 官方文档中关于该接口方法的说明： ReadAt 从基本输入源的偏移量 off 处开始，将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &lt;= n &lt;= len(p)）以及任何遇到的错误。 当 ReadAt 返回的 n &lt; len(p) 时，它就会返回一个 非nil 的错误来解释 为什么没有返回更多的字节。在这一点上，ReadAt 比 Read 更严格。 即使 ReadAt 返回的 n &lt; len(p)，它也会在调用过程中使用 p 的全部作为暂存空间。若一些数据可用但不到 len(p) 字节，ReadAt 就会阻塞直到所有数据都可用或产生一个错误。 在这一点上 ReadAt 不同于 Read。 若 n = len(p) 个字节在输入源的的结尾处由 ReadAt 返回，那么这时 err == EOF 或者 err == nil。 若 ReadAt 按查找偏移量从输入源读取，ReadAt 应当既不影响基本查找偏移量也不被它所影响。 ReadAt 的客户端可对相同的输入源并行执行 ReadAt 调用。 可见，ReaderAt 接口使得可以从指定偏移量处开始读取数据。 示例代码如下： 12345678910111213141516package mainimport ( "fmt" "strings")func main() &#123; reader := strings.NewReader("Golang library.") p := make([]byte, 6) n, err := reader.ReadAt(p, 2) if err != nil &#123; panic(err) &#125; fmt.Printf("%s, %d\n", p, n)&#125; 输出结果为： 1lang l, 6 WriterAt 接口的定义如下： 123type WriterAt interface &#123; WriteAt(p []byte, off int64) (n int, err error)&#125; 官方文档中关于该接口方法的说明： WriteAt 从 p 中将 len(p) 个字节写入到偏移量 off 处的基本数据流中。它返回从 p 中被写入的字节数 n（0 &lt;= n &lt;= len(p)）以及任何遇到的引起写入提前停止的错误。若 WriteAt 返回的 n &lt; len(p)，它就必须返回一个 非nil 的错误。 若 WriteAt 按查找偏移量写入到目标中，WriteAt 应当既不影响基本查找偏移量也不被它所影响。 若区域没有重叠，WriteAt 的客户端可对相同的目标并行执行 WriteAt 调用。 可以通过该接口将数据写入数据流的特定偏移量之后。 通过简单示例来演示 WriteAt 方法的使用（os.File 实现了 WriterAt 接口）： 123456789101112131415161718192021package mainimport ( "fmt" "os")func main() &#123; file, err := os.Create("writeAt.txt") if err != nil &#123; panic(err) &#125; defer file.Close() file.WriteString("Golang library.") n, err := file.WriteAt([]byte(" - Sliver"), 15) // 在文件第15个字节后插入字符 if err != nil &#123; panic(err) &#125; fmt.Println(n) // 9&#125; 打开文件 WriteAt.txt，内容是：Golang library. - Sliver 分析可以知道，file.WriteString(“Golang library.”) 往文件中写入 Golang library.，之后 file.WriteAt([]byte(“ - Sliver”), 15) 在文件流的 offset=24 处写入 - Sliver。 ReaderFrom 和 WriterTo 接口ReaderFrom 的定义如下： 123type ReaderFrom interface &#123; ReadFrom(r Reader) (n int64, err error)&#125; 官方文档中关于该接口方法的说明： ReadFrom 从 r 中读取数据，直到 EOF 或发生错误。其返回值 n 为读取的字节数。除 io.EOF 之外，在读取过程中遇到的任何错误也将被返回。 如果 ReaderFrom 可用，Copy 函数就会使用它。 注意：ReadFrom 方法不会返回 err == EOF。 举个例子： 123456789101112131415161718package mainimport ( "bufio" "os")func main() &#123; file, err := os.Open("writeAt.txt") if err != nil &#123; panic(err) &#125; defer file.Close() writer := bufio.NewWriter(os.Stdout) writer.ReadFrom(file) writer.Flush() // Golang library. - Sliver%&#125; 这段代码将之前生成的 writeAt.txt 的文件内容读取并输出到了终端。 也可以通过 ioutil 包的 ReadFile 函数获取文件全部内容。其实，跟踪一下 ioutil.ReadFile 的源码，会发现其实也是通过 ReadFrom 方法实现（用的是 bytes.Buffer，它实现了 ReaderFrom 接口）。 如果不通过 ReadFrom 接口来做这件事，而是使用 io.Reader 接口，有两种思路： 先获取文件的大小（File 的 Stat 方法），之后定义一个该大小的 []byte，通过 Read 一次性读取 定义一个小的 []byte，不断的调用 Read 方法直到遇到 EOF，将所有读取到的 []byte 连接到一起 WriterTo 的定义如下： 123type WriterTo interface &#123; WriteTo(w Writer) (n int64, err error)&#125; 官方文档中关于该接口方法的说明： WriteTo 将数据写入 w 中，直到没有数据可写或发生错误。其返回值 n 为写入的字节数。 在写入过程中遇到的任何错误也将被返回。 如果 WriterTo 可用，Copy 函数就会使用它。 可以发现，其实 ReaderFrom 和 WriterTo 接口的方法接收的参数是 io.Reader 和 io.Writer 类型。 这里只提供简单的一个示例代码：将一段文本输出到标准输出 1234567891011package mainimport ( "bytes" "os")func main() &#123; reader := bytes.NewReader([]byte("Hello, golang!\n")) reader.WriteTo(os.Stdout) // Hello, golang!&#125; 通过 io.ReaderFrom 和 io.WriterTo 的学习，可以知道，如果需要一次性从某个地方读或写到某个地方去，可以使用这两个接口。 Copy 和 CopyN 函数Copy 函数的签名： 1func Copy(dst Writer, src Reader) (written int64, err error) 函数文档： Copy 将 src 复制到 dst，直到在 src 上到达 EOF 或发生错误。它返回复制的字节数，如果有的话，还会返回在复制时遇到的第一个错误。 成功的 Copy 返回 err == nil，而非 err == EOF。由于 Copy 被定义为从 src 读取直到 EOF 为止，因此它不会将来自 Read 的 EOF 当做错误来报告。 若 dst 实现了 ReaderFrom 接口，其复制操作可通过调用 dst.ReadFrom(src) 实现。此外，若 src 实现了 WriterTo 接口，其复制操作可通过调用 src.WriteTo(dst) 实现。 示例代码如下： 1234567891011package mainimport ( "io" "os" "strings")func main() &#123; io.Copy(os.Stdout, strings.NewReader("Hello, golang!"))&#125; 此代码直接将内容输出（写入 Stdout 中）。 也可以这么做： 123456789101112package mainimport ( &quot;fmt&quot; &quot;io&quot; &quot;os&quot;)func main() &#123; io.Copy(os.Stdout, os.Stdin) fmt.Println(&quot;End.&quot;)&#125; 将输入直接输出。 CopyN 函数的签名： 1func CopyN(dst Writer, src Reader, n int64) (written int64, err error) 函数文档： CopyN 将 n 个字节从 src 复制到 dst。 它返回复制的字节数以及在复制时遇到的最早的错误。由于 Read 可以返回要求的全部数量及一个错误（包括 EOF），因此 CopyN 也能如此。 若 dst 实现了 ReaderFrom 接口，复制操作也就会使用它来实现。 示例代码： 1234567891011package mainimport ( "io" "os" "strings")func main() &#123; io.CopyN(os.Stdout, strings.NewReader("Golang."), 3) // Gol&#125; 文件读取1： 1234567891011121314151617181920212223242526272829303132package mainimport ( "bufio" "fmt" "io" "os")func main() &#123; file, err := os.Open("ecc.py") if err != nil &#123; panic(err) &#125; defer file.Close() r := bufio.NewReader(file) chunks := make([]byte, 1024, 1024) buf := make([]byte, 1024) for &#123; n, err := r.Read(buf) if err != nil &amp;&amp; err != io.EOF &#123; panic(err) &#125; if n == 0 &#123; break &#125; chunks = append(chunks, buf[:n]...) &#125; fmt.Printf("%s\n", chunks)&#125; 文件读取2： 123456789101112131415161718192021222324252627package mainimport ( "fmt" "os")func check(err error) &#123; if err != nil &#123; fmt.Println(err) &#125;&#125;func main() &#123; file, err := os.Create("test.txt") check(err) file.WriteString("One ") // 在文件 file 偏移量0处开始写入 One file.Write([]byte("Two Three")) // 在文件 file 偏移量 One 之后开始写入 Two Three file.WriteAt([]byte("Hello, golang!"), 8) // 在文件 file 偏移量 10 处开始写入 Hello, golang!，将会覆盖一些数据 a := make([]byte, 20) file.Seek(0, 0) // file 指针指向文件开始位置 n, err := file.Read(a) check(err) fmt.Println(string(a[:n])) // One Two Hello, golan&#125; ioutil虽然 io 包提供了不少类型、方法和函数，但有时候使用起来不是那么方便。比如读取一个文件中的所有内容。为此，标准库中提供了一些常用、方便的 IO 操作函数。 ReadAll 函数很多时候，我们需要一次性读取 io.Reader 中的数据，考虑到读取所有数据的需求比较多，Go 提供了ReadAll 这个函数，用来从 io.Reader 中一次读取所有数据。 1func ReadAll(r io.Reader) ([]byte, error) 阅读该函数的源码发现，它是通过 bytes.Buffer 中的 ReadFrom 来实现读取所有数据的，源码如下： 12345678910111213141516171819202122232425262728// readAll reads from r until an error or EOF and returns the data it read// from the internal buffer allocated with a specified capacity.func readAll(r io.Reader, capacity int64) (b []byte, err error) &#123; buf := bytes.NewBuffer(make([]byte, 0, capacity)) // If the buffer overflows, we will get bytes.ErrTooLarge. // Return that as an error. Any other panic remains. defer func() &#123; e := recover() if e == nil &#123; return &#125; if panicErr, ok := e.(error); ok &amp;&amp; panicErr == bytes.ErrTooLarge &#123; err = panicErr &#125; else &#123; panic(e) &#125; &#125;() _, err = buf.ReadFrom(r) return buf.Bytes(), err&#125;// ReadAll reads from r until an error or EOF and returns the data it read.// A successful call returns err == nil, not err == EOF. Because ReadAll is// defined to read from src until EOF, it does not treat an EOF from Read// as an error to be reported.func ReadAll(r io.Reader) ([]byte, error) &#123; return readAll(r, bytes.MinRead)&#125; 示例代码： 12345678910111213141516171819202122package mainimport ( "fmt" "io/ioutil" "os")func main() &#123; file, err := os.Open("writeAt.txt") if err != nil &#123; fmt.Println(err) &#125; defer file.Close() content, err := ioutil.ReadAll(file) if err != nil &#123; fmt.Println(err) &#125; fmt.Printf("%s\n", content)&#125; 输出结果为： 1Golang library. - Sliver ReadDir 函数在 ioutil 中提供了一个方便的函数：ReadDir，它读取目录并返回排好序的文件和子目录名（[]os.FileInfo）。 示例代码： 123456789101112131415161718192021222324252627282930package mainimport ( "fmt" "io/ioutil" "path/filepath")func main() &#123; dirAbs, err := filepath.Abs(".") if err != nil &#123; fmt.Println(err) &#125; fmt.Println(dirAbs) // 读取目录下所有文件信息 fileInfos, err := ioutil.ReadDir(dirAbs) if err != nil &#123; fmt.Println(err) &#125; // 获取当前目录下所有文件的名称 for _, file := range fileInfos &#123; if file.IsDir() &#123; continue &#125; else &#123; fmt.Println(file.Name()) &#125; &#125;&#125; Golang 中文件以及文件夹路径相关操作 ReadFile 和 WriteFile 函数ReadFile 可以读取整个文件的内容，它的实现和 ReadAll类似。不过，ReadFile 会先判断文件的大小，再给 bytes.Buffer 一个预定义容量，避免额外分配内存。 WriteFile 函数的签名如下： 1func WriteFile(filename string, data []byte, perm os.FileMode) error 它将 data 写入 filename 文件中，当文件不存在时会创建一个（文件权限由 perm 指定）；否则会先清空文件内容。对于 perm 参数，一般可以指定为：0666。 12345678910111213141516171819202122package mainimport ( "fmt" "io/ioutil")func main() &#123; file, err := ioutil.ReadFile("writeAt.txt") if err != nil &#123; fmt.Println(err) &#125; fmt.Printf("%s\n", file) content := []byte("Hello, this WriteFile function.") err = ioutil.WriteFile("hello.txt", content, 0666) if err != nil &#123; fmt.Println(err) &#125; fmt.Println("Write successfully!")&#125; 输出结果为： 12Golang library. - SliverWrite successfully! 获得文件信息： 12345678910111213141516171819202122232425package mainimport ( "fmt" "io/ioutil" "os")func main() &#123; data := []byte("Hello, golang!") ioutil.WriteFile("test.txt", data, 0666) fileinfo, err := os.Stat("test.txt") // 判断文件是否存在 if os.IsNotExist(err) &#123; fmt.Printf("No existing file found.\n") os.Exit(1) &#125; fmt.Println(fileinfo.Name()) // 获取文件名 fmt.Println(fileinfo.IsDir()) // 判断是否是目录，返回bool类型 fmt.Println(fileinfo.ModTime()) // 获取文件修改时间 fmt.Println(fileinfo.Mode()) // 获取文件权限 fmt.Println(fileinfo.Size()) // 获取文件大小 fmt.Println(fileinfo.Sys())&#125; 输出结果为： 123456test.txtfalse2018-05-23 15:42:47.491606099 +0800 CST-rw-r--r--14&amp;&#123;16777220 33188 1 8605038327 501 20 0 [0 0 0 0] &#123;1527061295 61056911&#125; &#123;1527061367 491606099&#125; &#123;1527061367 491606099&#125; &#123;1527061291 258604785&#125; 14 8 4194304 64 0 0 [0 0]&#125; fmtfmt 包实现了格式化 I/O 函数，类似于 C 的 printf 和 scanf。格式“占位符”衍生自 C，但比 C 更简单。 fmt 包的官方文档对 Printing 和 Scanning 有很详细的说明。这里就直接引用文档进行说明，同时附上额外的说明或例子，之后再介绍具体的函数使用。 Print 序列函数 这里说的 Print 序列函数包括：Fprint/Fprintf/Fprintln/Sprint/Sprintf/Sprintln/Print/Printf/Println。之所以将放在一起介绍，是因为它们的使用方式类似、参数意思也类似。 一般的，我们将 Fprint/Fprintf/Fprintln 归为一类；Sprint/Sprintf/Sprintln 归为一类；Print/Printf/Println 归为另一类。其中，Print/Printf/Println 会调用相应的F开头一类函数。如： 123func Print(a ...interface&#123;&#125;) (n int, err error) &#123; return Fprint(os.Stdout, a...)&#125; Fprint/Fprintf/Fprintln 函数的第一个参数接收一个 io.Writer 类型，会将内容输出到io.Writer 中去。而 Print/Printf/Println 函数是将内容输出到标准输出中，因此，直接调用 F 类函数做这件事，并将 os.Stdout 作为第一个参数传入。 Sprint/Sprintf/Sprintln 是格式化内容为 string 类型，而并不输出到某处，需要格式化字符串并返回时，可以用次组函数。 在这三组函数中，S/F/Printf 函数通过指定的格式输出或格式化内容；S/F/Print 函数只是使用默认的格式输出或格式化内容；S/F/Println 函数使用默认的格式输出或格式化内容，同时会在最后加上”换行符”。 Print 序列函数的最后一个参数都是 a …interface{} 这种不定参数。对于 S/F/Printf 序列，这个不定参数的实参个数应该和 formt 参数的占位符个数一致，否则会出现格式化错误；而对于其他函数，当不定参数的实参个数为多个时，它们之间会直接（对于 S/F/Print）或通过” “（空格）（对于 S/F/Println）连接起来（注：对于 S/F/Print，当两个参数都不是字符串时，会自动添加一个空格，否则不会加。利用这一点，我们可以做如下事情： 12345678910package mainimport ( "fmt")func main() &#123; r1 := fmt.Sprint("I want to do something -", 12345) // I want to do something -12345 r2 := fmt.Sprintln("I want to do something -", 12345) // I want to do something - 12345&#125; 在这里 Sprint/Sprintln 起到了连接字符串和数字的作用，而不需要通过 strconv.Itoa() 转换。 Scan 序列函数 该序列函数和 Print 序列函数相对应，包括：Fscan/Fscanf/Fscanln/Sscan/Sscanf/Sscanln/Scan/Scanf/Scanln。 一般的，我们将 Fscan/Fscanf/Fscanln 归为一类；Sscan/Sscanf/Sscanln 归为一类；Scan/Scanf/Scanln 归为另一类。其中，Scan/Scanf/Scanln 会调用相应的 F 开头一类函数。 123func Scan(a ...interface&#123;&#125;) (n int, err error) &#123; return Fscan(os.Stdin, a...)&#125; Fscan/Fscanf/Fscanln 函数的第一个参数接收一个 io.Reader 类型，从其读取内容并赋值给相应的实参。而 Scan/Scanf/Scanln 正是从标准输入获取内容，因此，直接调用 F 类函数做这件事，并将 os.Stdin 作为第一个参数传入。 Sscan/Sscanf/Sscanln 则直接从字符串中获取内容。 对于 Scan/Scanf/Scanln 三个函数的区别，我们通过例子来说明，为了方便讲解，我们使用 Sscan/Sscanf/Sscanln 这组函数。 Scan/FScan/Sscan 12345678910111213package mainimport ( "fmt")func main() &#123; var name string var age int n, _ := fmt.Sscan("Sliver 19", &amp;name, &amp;age) fmt.Println(n, name, age) // 2 Sliver 19&#125; Scan/FScan/Sscan 这组函数将连续由空格分隔的值存储为连续的实参（换行符也记为空格）。 Scanf/FScanf/Sscanf 12345678910111213package mainimport ( "fmt")func main() &#123; var name string var age int n, _ := fmt.Sscanf("Sliver 19", "%s%d", &amp;name, &amp;age) fmt.Println(n, name, age) // 2 Sliver 19&#125; 如果将”空格”分隔改为”\n”分隔，则输出为：1 Sliver 0。可见，Scanf/FScanf/Sscanf 这组函数将连续由空格分隔的值存储为连续的实参，其格式由 format 决定，换行符处停止扫描(Scan)。 Scanln/FScanln/Sscanln 12345678910111213package mainimport ( "fmt")func main() &#123; var name string var age int n, _ := fmt.Sscanln("Ariel 18", &amp;name, &amp;age) fmt.Println(n, name, age) // 2 Ariel 18&#125; Scanln/FScanln/Sscanln 表现和上一组一样，遇到”\n”停止（对于 Scanln，表示从标准输入获取内容，最后需要回车）。 bufiobufio 包实现了缓存 IO。它包装了 io.Reader 和 io.Writer 对象，创建了另外的 Reader 和 Writer 对象，它们也实现了io.Reader和io.Writer接口，不过它们是有缓存的。该包同时为文本I/O提供了一些便利操作。 Reader 类型和方法bufio.Reader 结构包装了一个 io.Reader 对象，提供缓存功能，同时实现了 io.Reader 接口。 Reader 结构没有任何导出的字段，结构定义如下： 12345678910type Reader struct &#123; buf []byte // 缓存 rd io.Reader // 底层的io.Reader // r:从buf中读走的字节（偏移）；w:buf中填充内容的偏移； // w - r 是buf中可被读的长度（缓存数据的大小），也是Buffered()方法的返回值 r, w int err error // 读过程中遇到的错误 lastByte int // 最后一次读到的字节（ReadByte/UnreadByte) lastRuneSize int // 最后一次读到的Rune的大小(ReadRune/UnreadRune)&#125; 实例化 bufio 包提供了两个实例化 bufio.Reader 对象的函数：NewReader 和 NewReaderSize。其中，NewReader 函数是调用 NewReaderSize 函数实现的： 1234func NewReader(rd io.Reader) *Reader &#123; // 默认缓存大小：defaultBufSize=4096 return NewReaderSize(rd, defaultBufSize)&#125; 我们看一下 NewReaderSize 的源码： 123456789101112131415161718func NewReaderSize(rd io.Reader, size int) *Reader &#123; // 已经是bufio.Reader类型，且缓存大小不小于 size，则直接返回 b, ok := rd.(*Reader) if ok &amp;&amp; len(b.buf) &gt;= size &#123; return b &#125; // 缓存大小不会小于 minReadBufferSize （16字节） if size &lt; minReadBufferSize &#123; size = minReadBufferSize &#125; // 构造一个bufio.Reader实例 return &amp;Reader&#123; buf: make([]byte, size), rd: rd, lastByte: -1, lastRuneSize: -1, &#125;&#125; 示例代码： 1234567891011121314151617181920212223242526272829package mainimport ( "bufio" "fmt" "os")func main() &#123; file, err := os.Open("writeAt.txt") check(err) defer file.Close() r := bufio.NewReader(file) p, err := r.Peek(5) check(err) fmt.Printf("Read 5 bytes: %s\n", p) out := make([]byte, 25) n, err := r.Read(out) check(err) fmt.Printf("%d bytes read: %s\n", n, out)&#125;func check(e error) &#123; if e != nil &#123; panic(e) &#125;&#125; 输出结果： 12Read 5 bytes: Golan24 bytes read: Golang library. - Sliver Writer 类型和方法bufio.Writer 结构包装了一个 io.Writer 对象，提供缓存功能，同时实现了 io.Writer 接口。 Writer 结构没有任何导出的字段，结构定义如下：o123456type Writer struct &#123; err error // 写过程中遇到的错误 buf []byte // 缓存 n int // 当前缓存中的字节数 wr io.Writer // 底层的 io.Writer 对象&#125; 相比 bufio.Reader, bufio.Writer 结构定义简单很多。 注意：如果在写数据到 Writer 的时候出现了一个错误，不会再允许有数据被写进来了，并且所有随后的写操作都会返回该错误。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( "bufio" "fmt" "io/ioutil" "os")func main() &#123; a := []byte("Hello, golang.") err := ioutil.WriteFile("hello.txt", a, 0644) check(err) f, err := os.Create("test.txt") check(err) defer f.Close() b := []byte("Sliver") n, err := f.Write(b) check(err) fmt.Printf("Wrote %d bytes\n", n) n, err = f.WriteString(" wrote it.\n") fmt.Printf("Wrote %d bytes\n", n) f.Sync() w := bufio.NewWriter(f) n, err = w.WriteString("buffered\n") fmt.Printf("Wrote %d bytes\n", n) w.Flush()&#125;func check(e error) &#123; if e != nil &#123; panic(e) &#125;&#125; Scanner 类型和方法对于简单的读取一行，在 Reader 类型中，感觉没有让人特别满意的方法。于是，Go1.1 增加了一个类型：Scanner。官方关于 Go1.1 增加该类型的说明如下： 在 bufio 包中有多种方式获取文本输入，ReadBytes、ReadString 和独特的 ReadLine，对于简单的目的这些都有些过于复杂了。在 Go 1.1 中，添加了一个新类型，Scanner，以便更容易的处理如按行读取输入序列或空格分隔的词等，这类简单的任务。它终结了如输入一个很长的有问题的行这样的输入错误，并且提供了简单的默认行为：基于行的输入，每行都剔除分隔标识。这里的代码展示一次输入一行： 1234567scanner := bufio.NewScanner(os.Stdin)for scanner.Scan() &#123; fmt.Println(scanner.Text()) // Println will add back the final '\n'&#125;if err := scanner.Err(); err != nil &#123; fmt.Fprintln(os.Stderr, "reading standard input:", err)&#125; Scanner 类型和 Reader 类型一样，没有任何导出的字段，同时它也包装了一个 io.Reader 对象，但它没有实现 io.Reader 接口。 示例代码： 12345678910111213141516171819202122package mainimport ( "bufio" "fmt" "os" "strings")func main() &#123; scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() &#123; ucl := strings.ToUpper(scanner.Text()) fmt.Println(ucl) &#125; if err := scanner.Err(); err != nil &#123; fmt.Fprintln(os.Stderr, "error:", err) os.Exit(1) &#125;&#125; 输出结果： 12abcdefghABCDEFGH gobGo 可以通过 json 或 gob 来序列化 struct 对象，虽然 json 的序列化更为通用，但利用 gob 编码可以实现 json 所不能支持的 struct 的方法序列化，并且利用 gob 包序列化 struct 后，保存到本地也十分简单。 先看一个官方的例子： 1234567891011121314151617181920212223242526272829303132package mainimport ( "bytes" "encoding/gob" "fmt" "log")type P struct &#123; X, Y, Z int Name string&#125;func main() &#123; var network bytes.Buffer // Stand-in for a network connection. enc := gob.NewEncoder(&amp;network) // Will write to network. dec := gob.NewDecoder(&amp;network) // Will read from network. err := enc.Encode(P&#123;3, 4, 5, "Pythagoras"&#125;) if err != nil &#123; log.Fatal("encode error:", err) &#125; fmt.Printf("%v\n", network.Bytes()) var p P err = dec.Decode(&amp;p) if err != nil &#123; log.Fatal("decode error:", err) &#125; fmt.Printf("%s: &#123;%d, %d, %d&#125;\n", p.Name, p.X, p.Y, p.Z)&#125; 输出结果为： 12[42 255 129 3 1 1 1 80 1 255 130 0 1 4 1 1 88 1 4 0 1 1 89 1 4 0 1 1 90 1 4 0 1 4 78 97 109 101 1 12 0 0 0 21 255 130 1 6 1 8 1 10 1 10 80 121 116 104 97 103 111 114 97 115 0]Pythagoras: &#123;3, 4, 5&#125; 从上面的例子可以发现，gob 不仅可以把结构体直接转化为 bytes.Buffer，还可以直接把 bytes.Buffer 转化为结构体，并读取数据。并且，Encode 是将结构体（传递指针也行）传递过来，而 Decode 的函数参数却是一个指针。 序列化至文件中： 123456789101112131415161718192021222324252627282930313233343536package mainimport ( "encoding/gob" "fmt" "log" "os")type User struct &#123; Id int Name string&#125;func (this *User) Say() string &#123; return this.Name + ` hello world ! `&#125;func main() &#123; file, err := os.Create("gob.txt") if err != nil &#123; fmt.Println(err) &#125; user1 := User&#123;Id: 1, Name: "Mike"&#125; user2 := User&#123;Id: 3, Name: "Jack"&#125; u := []User&#123;user1, user2&#125; enc := gob.NewEncoder(file) err = enc.Encode(u) if err != nil &#123; log.Fatal("encode error:", err) &#125; fmt.Println("Successfully!")&#125; 输出结果为： 1Successfully! 在当前目录下也会生成 gob.txt 文件。 从文件反序列化： 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( "encoding/gob" "fmt" "log" "os")type User struct &#123; Id int Name string&#125;func (this *User) Say() string &#123; return this.Name + ` hello world ! `&#125;func main() &#123; var u []User file, err := os.Open("gob.txt") if err != nil &#123; fmt.Println(err) &#125; defer file.Close() dec := gob.NewDecoder(file) err = dec.Decode(&amp;u) if err != nil &#123; log.Fatal("decode error:", err) &#125; for _, user := range u &#123; fmt.Println(user.Id) fmt.Println(user.Say()) &#125;&#125; 输出结果为： 12341Mike hello world !3Jack hello world ! 当编解码中有一个字段是 interface{} 的时候需要对 interface{} 的可能产生的类型进行注册，这个时候就需要使用 gob.Register() 方法。 flag在写命令行程序（工具、server）时，对命令参数进行解析是常见的需求。各种语言一般都会提供解析命令行参数的方法或库，以方便程序员使用。如果命令行参数纯粹自己写代码解析，对于比较复杂的参数逻辑，写起来还是挺费劲的。在 Go 标准库中提供了一个包：flag，方便进行命令行解析。 首先看一个例子： 1234567891011121314package mainimport "os"import "fmt"func main() &#123; // os.Args 提供原始命令行参数访问功能。注意，切片中的第一个参数是该程序的路径，并且 os.Args[1:]保存所有程序的的参数。 argsWithProg := os.Args argsWithoutProg := os.Args[1:] arg := os.Args[3] fmt.Println(argsWithProg) fmt.Println(argsWithoutProg) fmt.Println(arg)&#125; 输出结果为： 12345输入：go run "demo.go" a b c d[/var/folders/nw/dg52p8850tn61qzlhh9vj6j80000gn/T/go-build729329098/command-line-arguments/_obj/exe/hello a b c d][a b c d]c 可以看到 os.Args 可以提供原始的命令行参数访问功能。 在介绍 flag 包前，先来结果注意事项和科普： 可以通过 flag.String(), flag.Bool(), flag.Int() 等方式来定义命令行中需要使用的参数 在定义完 flag 后，需要调用 flag.Parse() 来对命令行参数进行解析 获取 flag.String(), flag.Bool(), flag.Int() 等方法的返回值时，是对应着用户输入的参数值，但它们均为相应变量的内存地址，取值时前面要加上 * 号 示例代码1： 1234567891011121314151617181920212223package mainimport ( "flag" "fmt")func main() &#123; married := flag.Bool("married", false, "Are you married?") age := flag.Int("age", 22, "How old are you?") name := flag.String("name", "", "What's your name?") var address string // flag.StringVar 函数第一个参数为变量地址，后面的参数和 flag.String 是一样的。 flag.StringVar(&amp;address, "address", "HangZhou", "What's your address?") flag.Parse() // 解析输入的参数 fmt.Println("married:", *married) // 不加 * 号的话，输出的是内存地址 fmt.Println("age:", *age) fmt.Println("name:", *name) fmt.Println("address:", address)&#125; 输出结果为： 123456789101112go run "demo.go" -married=false -age=20 -name=slivermarried: falseage: 20name: sliveraddress: HangZhougo run "demo.go" -age 20 -name slivermarried: falseage: 20name: sliveraddress: HangZhou 示例代码2： 12345678910111213141516171819202122package mainimport ( "flag" "fmt" "os")func main() &#123; personFlag := flag.NewFlagSet("person", flag.ExitOnError) personData := personFlag.String("data", "", "Personal data") personFlag.Parse(os.Args[2:]) if personFlag.Parsed() &#123; if *personData == "sliver" &#123; fmt.Println("This is sliver.") &#125; else &#123; fmt.Println("Unknown host.") &#125; &#125;&#125; 输出结果为： 1234567go run "demo.go" person -data "sliver"This is sliver.go run "demo.go" person -data "ariel"Unknown host. 可见： 1234flagSet 类可以让参数处理更加灵活。其中 NewFlagSet:flagSet = flag.NewFlagSet("xcl",flag.ExitOnError) NewFlagSet 的第一个参数是可以任意定的，但第二个参数，则决定了参数解析出错时错误处理方式。 hex在项目中可能会需要将 byte slice 或 string 转化为对应的16进制字符串表示，这时候 encoding/hex 包就派上了用场。 举个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( "encoding/hex" "fmt")func something() &#123; // func EncodeToString(src []byte) string 编码 byte 字节切片为16进制字符串 src := []byte("hello") fmt.Println(src) // [104 101 108 108 111] encodeStr := hex.EncodeToString(src) // 16进制转换：68656c6c6f fmt.Println(encodeStr) // func Encode(dst, src []byte) int // func EncodedLen(n int) int welcome := []byte("Gopher!") wdest := make([]byte, hex.EncodedLen(len(welcome))) num := hex.Encode(wdest, welcome) // 返回编码长度 fmt.Println(wdest, num) // wdest = [52 55 54 102 55 48 54 56 54 53 55 50 50 49]，num = 14 //func DecodeString(s string) ([]byte, error) 解码16进制的字符串为 byte 类型 decodeStr, err := hex.DecodeString(encodeStr) if err != nil &#123; fmt.Println(err) &#125; fmt.Println(string(decodeStr)) // hello //func DecodedLen(x int) int x个 byte 解码后的长度，一般是 x/2 //func Decode(dst, src []byte) (int, error) 将 byte 类型的 src 解码到 byte 类型的 dst 中，并且解码的长度 test := []byte("48656c6c6f20476f7068657221") dest := make([]byte, hex.DecodedLen(len(test))) // 定义一个切片 num, err = hex.Decode(dest, test) // 转换16进制字符串为byte[]类型，返回切片长度 if err != nil &#123; fmt.Println(err) &#125; fmt.Println(num, dest[:num], string(dest), len(dest), cap(dest)) // print 13 //func Dump(data []byte) string // 返回给定字符串以及字符串相对应的 hex dump 文件 效果相当于 linux 命令行下的 "hexdump -C filename" content := []byte("Go is an open source programming language.") fmt.Println(hex.Dump(content))&#125;func main() &#123; something()&#125; 输出结果为： 12345678[104 101 108 108 111]68656c6c6f[52 55 54 102 55 48 54 56 54 53 55 50 50 49] 14hello13 [72 101 108 108 111 32 71 111 112 104 101 114 33] Hello Gopher! 13 1300000000 47 6f 20 69 73 20 61 6e 20 6f 70 65 6e 20 73 6f |Go is an open so|00000010 75 72 63 65 20 70 72 6f 67 72 61 6d 6d 69 6e 67 |urce programming|00000020 20 6c 61 6e 67 75 61 67 65 2e | language.| 一般使用 EncodeToString() 和 DecodeString() 居多。 binary 与16进制一样，2进制也是需要进行编码解码的。 12345678910111213141516171819202122232425package mainimport ( "bytes" "encoding/binary" "fmt")func main() &#123; var a int64 = 100 buff := new(bytes.Buffer) err := binary.Write(buff, binary.BigEndian, a) if err != nil &#123; fmt.Println(err) &#125; fmt.Println(buff.Bytes()) var b int64 err = binary.Read(buff, binary.BigEndian, &amp;b) if err != nil &#123; fmt.Println(err) &#125; fmt.Println(b)&#125; 输出结果为： 12[0 0 0 0 0 0 0 100]100 多轮编/解码： 1234567891011121314151617181920212223242526package mainimport ( "bytes" "encoding/binary" "fmt")func main() &#123; buf := new(bytes.Buffer) var data = []interface&#123;&#125;&#123; uint16(61374), int8(-54), uint8(254), &#125; fmt.Printf("%v\n", data) for _, v := range data &#123; err := binary.Write(buf, binary.LittleEndian, v) if err != nil &#123; fmt.Println(err) &#125; &#125; fmt.Printf("%b\n", buf.Bytes())&#125; 输出结果为： 12[61374 -54 254][10111110 11101111 11001010 11111110]]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Go</tag>
        <tag>Library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go详尽笔记]]></title>
    <url>%2F2018%2F05%2F08%2Fjust-to-go%2F</url>
    <content type="text"><![CDATA[“I just wanna go.” 什么是 Go？Go 是一门并发支持、垃圾回收的编译型系统编程语言，旨在创造一门具有在静态编译语言的高性能和动态语言的高效开发之间拥有良好平衡点的一门编程语言。 Go 的主要特点有哪些？ 类型安全和内存安全 以非常直观和极低代价的方案实现高并发 高效的垃圾回收机制 快速编译（同时解决 C 语言中头文件太多的问题） 为多核计算机提供性能提升的方案 UTF-8 编码支持 如何安装 Go？Mac 下使用 brew 即可安装： 1brew install go 根据约定，GOPATH 下需要建立3个目录： bin（存放编译后生成的可执行文件） pkg（存放编译后生成的包文件） src（存放项目源码） 在用户目录下创建 go 文件夹，并在其中再创建 bin, pkg, src 文件夹，将以下参数添加到 .zshrc 文件： 12export GOPATH=$HOME/goexport GOBIN=$GOPATH/bin 创建 hello.go 文件，并写入： 1234567package mainimport "fmt"func main() &#123; fmt.Println("Hello, world!")&#125; 使用 go run hello.go 可以看到显示的结果： Go 常用命令简介 go get：获取远程包（需提前安装 git 或 hg） go run：直接运行程序 go build：测试编译，检查是否有编译错误 go fmt：格式化源码（部分 IDE 在保存时自动调用） go install：编译包文件并编译整个程序 go test：运行测试文件 go doc：查看文档（CHM 手册） Go 基础关键字和注释25 个内置关键字： 12345break default func interface selectcase defer go map structchan else goto package switchconst fallthrough if range typecontinue for import return var 12345678910内建常量：true false iota nil内建类型：int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error 内建函数：make len cap new append copy close delete complex real imag panic recover Go 语言中，使用大小写来决定该常量、变量、类型、接口、结构或函数是否可以被外部包所调用，如果一个名字是大写开头的，那么它将是可导出的，也就是可以被外部的包所访问 在习惯上，Go 语言程序员推荐使用驼峰式命名，如：parseRequestLine等。 注释方法： 12// 单行注释/* 多行注释 */ 基本结构 Go 程序是通过 package 来组织的（这与 Python 类似） 只有 package 名称为 main 的包可以包含 main 函数 一个可执行程序有且仅有一个 main 包 通过 import 关键字来导入其它非 main 包 通过 const 关键字来进行常量的定义 通过在函数体外部使用 var 关键字来进行全局变量的声明与赋值 通过 type 关键字来进行结构（struct）或接口（interface）的声明 通过 func 关键字来进行函数的声明 导入 package： 分批导入 12345import "fmt"import "os"import "strings"import "strconv"import "time" 集中式导入 1234567import ( "fmt" "os" "strings" "strconv" "time") 导入具有别名的 package： 12345678910package mainimport ( io "fmt")func main() &#123; // 别名调用 io.Println("Hello, world!")&#125; 省略 package 名称导入（不推荐）： 12345678910package mainimport ( . "fmt")func main() &#123; // 省略调用 Println("Hello, world!")&#125; 声明常量： 123456const ( pi = 3.14 a = "a" b = 66 c = "C") 声明全局变量： 12345var ( a = "a" b = 66 c = "C") 声明类型： 12345type ( t1 float64 t2 string t3 int64) Go 基本类型类型介绍 布尔型：bool 长度：1字节 取值范围：true, false 注意事项：不可以用数字代表 true 或 false 整型：int/uint 根据运行平台可能为32或64位 8位整型：int8/uint8 长度：1字节 取值范围：-128~127/0~255 字节型：byte（uint8的别名） 16位整型：int16/uint16 长度：2字节 取值范围：-32768~32767/0~65535 32位整型：int32（rune）/uint32 长度：4字节 取值范围：-2^32/2~2^32/2-1/0~2^32-1 64位整型：int64/uint64 长度：8字节 取值范围：-2^64/2~2^64/2-1/0~2^64-1 浮点型：float32/float64 长度：4/8字节 小数位：精确到7/15小数位 复数：complex64/complex128 长度：8/16字节 1234567891011121314151617181920212223package mainimport ( "fmt" "math" "math/cmplx")func main() &#123; a := 3 + 4i var b = complex(4, 3) // 输出一个复数 fmt.Printf("%g, %[1]T\n", a) // 欧拉公式：e ^ iπ + 1 = 0 fmt.Println(cmplx.Exp(1i*math.Pi) + 1) // 计算复数的模 fmt.Println(cmplx.Abs(a), cmplx.Abs(b)) // 输出结果为： // (3+4i), complex128 // (0+1.2246467991473515e-16i) // 5 5&#125; 足够保存指针的 32 位或 64 位整数型：uintptr 其它值类型： array、struct、string 引用类型： slice、map、chan 接口类型：inteface 函数类型：func 类型零值零值并不等于空值，而是当变量被声明为某种类型后的默认值，通常情况下数值类型的默认值为0，bool 为 false，string 为空字符串： 123456789101112package mainimport ( "fmt")func main() &#123; var a string var b int var c bool fmt.Println(a, b, c)&#125; 输出结果为： 10 false 类型名称一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。 123456789101112131415package mainimport ( "fmt")type ( newType int64)func main() &#123; var a newType a = 666 fmt.Println(a)&#125; 输出结果为： 1666 Go 变量声明 变量类型写在变量名之后 编译器可以推断变量类型 没有 char，只有 rune 原生支持复数类型 单个变量的声明与赋值123变量的声明格式：var &lt;变量名称&gt; &lt;变量类型&gt;变量的赋值格式：&lt;变量名称&gt; = &lt;表达式&gt;声明的同时赋值：var &lt;变量名称&gt; [变量类型] = &lt;表达式&gt; / &lt;变量名称&gt; := &lt;表达式&gt; 12345678910111213141516171819package mainimport ( "fmt")func main() &#123; // 单个变量声明 var a string // 单个变量赋值 a = "hello" // 单个变量声明并赋值 var b = "world" // 简短变量声明并赋值 c := "!" fmt.Println(a, b, c)&#125; 输出结果为： 1hello world ! 多个变量的声明与赋值1234全局变量的声明可使用 var() 的方式进行简写全局变量的声明不可以省略 var，但可使用并行方式所有变量都可以使用类型推断局部变量不可以使用 var() 的方式简写，只能使用并行方式 12345678910111213141516171819202122232425package mainimport ( "fmt")func main() &#123; // 多个变量的声明 var a, b, c int // 多个变量的赋值 a, b, c = 1, 2, 3 fmt.Println(a, b, c) // 多个变量声明并赋值 var d, e, f int = 4, 5, 6 fmt.Println(d, e, f) // 使用类型推断声明多个变量并赋值 var g, h, i = 7, 8, 9 fmt.Println(g, h, i) // 简短变量声明并赋值 j, k, l := 10, 11, 12 fmt.Println(j, k, l)&#125; 简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。 变量的类型转换 Go 中不存在隐式转换，所有类型转换必须显式声明 转换只能发生在两种相互兼容的类型之间 类型转换的格式：&lt;ValueA&gt; [:]= &lt;TypeOfValueA&gt;(&lt;ValueB&gt;) 1234567891011121314151617181920package mainimport ( "fmt")func main() &#123; // 相互兼容的类型才能相互转换 var a float32 = 3.14 b := int(a) fmt.Println(a, b) // 浮点数类型不能直接转换成字符串类型 // c := string(a) // fmt.Println(a, c) // 整数类型可以转化成字符串类型 d := string(b) fmt.Printf("%d, %q\n", b, d)&#125; 输出结果为： 123.14 33, "\x03" 若要完成数值和数值字符串的转化，可以使用 strconv 包： 1234567891011121314package mainimport ( "fmt" "strconv")func main() &#123; a := strconv.Itoa(66) fmt.Printf("%T\n", a) b, _ := strconv.Atoi("67") fmt.Printf("%T\n", b) fmt.Printf("%q, %d\n", a, b)&#125; 输出结果为： 123stringint"66", 67 Go 常量定义常量摘要 常量的值在编译时就已经确定 常量的定义格式与变量基本相同 等号右侧必须是常量或者常量表达式 常量表达式中的函数必须是内置函数 如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的： 12345678910111213141516package mainimport ( "fmt")const ( a = 1 b c = 2 d)func main() &#123; fmt.Println(a, b, c, d)&#125; 输出结果为： 11 1 2 2 iota 常量生成器常量声明可以使用 iota 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 const 声明语句中，在第一个声明的常量所在的行，iota 将会被置为0，然后在每一个有常量声明的行加一。 123456789101112131415161718192021222324package mainimport ( "fmt")type Weekday intconst ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday)func main() &#123; fmt.Println(Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday)&#125; 输出结果为： 10 1 2 3 4 5 6 iota 的值与这组常量的行索引有关： 123456789101112131415161718192021222324package mainimport ( "fmt")type Weekday intconst ( Sunday Weekday = 666 Monday Tuesday Wednesday = iota Thursday Friday Saturday)func main() &#123; fmt.Println(Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday)&#125; 输出结果为： 1666 666 666 3 4 5 6 iota 组合结果： 1234567891011121314151617package mainimport ( "fmt")const ( _ = iota KB = 1 &lt;&lt; (iota * 10) MB GB TB)func main() &#123; fmt.Println(KB, MB, GB, TB)&#125; 输出结果为： 11024 1048576 1073741824 1099511627776 无类型常量一般定义常量时可以不确定常量的基础类型，编译器往往会为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，并且在具体使用时不需要显示的类型转换；也就是说，常量可以作为各种类型使用。 Go 指针Go 虽然保留了指针，但与其它编程语言不同的是，在 Go 当中不支持指针运算以及”-&gt;”运算符，而直接采用”.”选择符来操作指针目标对象的成员。 操作符”&amp;”取变量地址，使用”*“通过指针间接访问目标对象 默认值为 nil 而非 NULL 12345678910111213package mainimport ( "fmt")func main() &#123; x := 1 p := &amp;x fmt.Println(*p) *p++ fmt.Println(x)&#125; 输出结果为： 1212 使用指针来交换数据： 1234567891011121314151617package mainimport ( "fmt")func main() &#123; a, b := 3, 4 fmt.Println(a, b) swap(&amp;a, &amp;b) fmt.Println(a, b)&#125;func swap(a, b *int) &#123; // 通过指针交换数据 *a, *b = *b, *a&#125; 输出结果为： 123 44 3 使用 new 函数可以初始化相应类型的零值并返回创建类型的地址： 123456789101112package mainimport ( "fmt")func main() &#123; p := new(int) fmt.Println(p, *p) *p += 2 fmt.Println(*p)&#125; 返回结果为： 120xc420080010 02 Go 运算符 Go 中的运算符均是从左至右结合 123456789// 优先级（从高到低）^ ! （一元运算符）* / % &lt;&lt; &gt;&gt; &amp; &amp;^+ - | ^ （二元运算符）== != &lt; &lt;= &gt;= &gt;&lt;- （专门用于 channel）&amp;&amp;|| 其中一元运算符中的 ^ 代表将数值按位取反，二元运算符中的 &amp;^ 代表 a &amp; (^b) 12345678910111213141516package mainimport ( "fmt")func main() &#123; // a = 00000001, b = 00000010 var a, b uint8 = 1, 2 // ^a = 11111110 fmt.Println(^a) // a = 00000001 // ^b = 11111101 // a &amp;^ b = 00000001 fmt.Println(a &amp;^ b)&#125; 输出结果为： 122541 在 Go 当中，++ 与 – 是作为语句而并不是作为表达式，即 i++ 与 i = i + 1 或 i += 1 等效 Go 逻辑语句判断语句 if 条件表达式没有括号 支持一个初始化表达式（可以是并行方式） 左大括号必须和条件语句或 else 在同一行 支持单行模式 初始化语句中的变量为 block 级别，同时隐藏外部同名变量 1234567891011121314151617package mainimport ( "fmt")func main() &#123; a := "ok" if a, b, c := 1, 2, 3; a+b+c &gt; 6 &#123; fmt.Println(a) &#125; else &#123; fmt.Println(a, b, c) a := "hello" fmt.Println(a) &#125; fmt.Println(a)&#125; 输出结果为： 1231 2 3hellook 可以看到，if 语句中新初始化的变量 a 会屏蔽前面已经存在变量 a，当语句判断结束后，被屏蔽的 a 变量才会显现。 Go 支持在进行 if 判断的时候对变量进行初始化： 123456789101112131415161718package mainimport ( "fmt" "io/ioutil")func main() &#123; const filename = "test.txt" // 读取一个 test.txt 文件夹，里面包含内容：Hello, world! if content, err := ioutil.ReadFile(filename); err != nil &#123; // 打印读取文件时的错误 fmt.Println(err) &#125; else &#123; fmt.Println(content) fmt.Printf("%s\n", content) &#125;&#125; 输出结果为： 12[72 101 108 108 111 44 32 119 111 114 108 100 33]Hello, world! 循环语句 for Go 只有 for 一个循环语句关键字，但支持3种形式 初始化和步进表达式可以是多个值 条件语句每次循环都会被重新检查，因此不建议在条件语句中使用函数，应尽量提前计算好条件并以变量或常量代替 左大括号必须和条件语句在同一行 无限循环形式： 12345678910111213141516package mainimport ( "fmt")func main() &#123; a := 1 for &#123; a++ if a == 3 &#123; break &#125; &#125; fmt.Println(a)&#125; 输出结果为： 13 充当 while 循环： 12345678910111213package mainimport ( "fmt")func main() &#123; a := 1 for a &lt;= 3 &#123; a++ &#125; fmt.Println(a)&#125; 输出结果为： 14 利用 if 和 for 实现一个十进制转二进制函数： 1234567891011121314151617181920212223package mainimport ( "fmt" "strconv")func main() &#123; fmt.Println(conventToBin(13)) fmt.Println(conventToBin(255))&#125;func conventToBin(num int) string &#123; result := "" if num == 0 &#123; return result &#125; for num &gt; 0 &#123; result += strconv.Itoa(num % 2) num /= 2 &#125; return result&#125; 输出结果为： 12101111111111 常规 for 循环： 12345678910111213package mainimport ( "fmt")func main() &#123; a := 1 for i := 0; i &lt; 3; i++ &#123; a++ &#125; fmt.Println(a)&#125; 输出结果为： 14 同理，在 for 循环中，初始化的变量也是 block 级别的： 12345678910111213package mainimport ( "fmt")func main() &#123; a := 1 for a := 0; a &lt; 3; a++ &#123; fmt.Println(a) &#125; fmt.Println(a)&#125; 输出结果为： 12340121 选择语句 switch 可以使用任何类型或表达式作为条件语句 case 的结尾不需要写 break，一旦条件符合将自动终止 如希望继续执行下一个 case，需使用 fallthrough 语句 支持一个初始化表达式（可以是并行方式），右侧需跟分号 左大括号必须和条件语句在同一行 常规 switch： 12345678910111213141516package mainimport ( "fmt")func main() &#123; a := 1 switch a &#123; case 0: fmt.Println("a = 0") case 1: fmt.Println("a = 1") &#125; fmt.Println(a)&#125; 输出结果为： 12a = 11 在 case 中进行判断： 1234567891011121314151617181920212223package mainimport ( "fmt")func main() &#123; a := 1 switch &#123; case a &gt;= 0: fmt.Println("a &gt;= 0") case a &gt;= 1: fmt.Println("a &gt;= 1") &#125; fmt.Println(a)&#125;``` 输出结果为：```Goa &gt;= 01 使用 fallthrough 防止 break： 123456789101112131415161718package mainimport ( "fmt")func main() &#123; switch a := 1; &#123; case a &gt;= 0: fmt.Println("a &gt;= 0") fallthrough case a &gt;= 1: fmt.Println("a &gt;= 1") fallthrough default: fmt.Println("else") &#125;&#125; 输出结果为： 123a &gt;= 0a &gt;= 1else 跳转语句 goto，break，continue 三个语句都可以配合标签使用 标签名区分大小写，若不使用会造成编译错误 break 与 continue 配合标签可用于多层循环的跳出 goto 是调整执行位置，与其它2个语句配合标签的结果并不相同 通过标签使用 break： 1234567891011121314151617package mainimport ( "fmt")func main() &#123;Label: for &#123; for i := 0; i &lt; 4; i++ &#123; if i == 3 &#123; break Label &#125; &#125; &#125; fmt.Println("ok")&#125; 输出结果为： 1ok 通过标签使用 continue 12345678910111213141516171819202122package mainimport ( "fmt")func main() &#123;Label: for i := 0; i &lt; 10; i++ &#123; for &#123; fmt.Printf("%d ", i) continue Label &#125; &#125; fmt.Println("ok")&#125;``` 输出结果为：```Go0 1 2 3 4 5 6 7 8 9 ok 通过标签使用 goto 12345678910111213141516171819202122package mainimport ( "fmt")func main() &#123; for i := 0; i &lt; 10; i++ &#123; for &#123; fmt.Printf("%d ", i) goto Label &#125; &#125;Label: fmt.Println("ok")&#125;``` 输出结果为：```Go0 ok Go 数组类型 定义数组的格式：var [n]，n &gt;= 0 数组长度也是类型的一部分，因此具有不同长度的数组为不同类型 注意区分指向数组的指针和指针数组 数组在 Go 中为值类型，在函数或方法中传递数组时，传递的关于数组的整个拷贝 数组之间可以使用 == 或 != 进行比较，但不可以使用 &lt; 或 &gt; 可以使用 new 来创建数组，此方法返回一个指向数组的指针 Go 支持多维数组 数组声明与创建1234567891011121314151617181920212223242526272829303132package mainimport ( "fmt")func main() &#123; // 通过 var 来声明数组 var a [3]int var b [3]int fmt.Println(a, b) fmt.Println(a == b) // 使用短变量声明方式声明数组 c := [3]int&#123;1, 2, 3&#125; fmt.Println(c) // 按顺序对数组赋值，为赋值的索引将分配零值 d := [3]int&#123;4, 5&#125; fmt.Println(d) // 指定索引赋值 e := [20]int&#123;19: 100&#125; fmt.Println(e) // 由编译器分配数组长度 f := [...]int&#123;1, 2, 3, 4, 5, 6&#125; fmt.Println(f) g := [...]int&#123;29: 100&#125; fmt.Println(g)&#125; 输出结果为： 1234567[0 0 0] [0 0 0]true[1 2 3][4 5 0][0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 100][1 2 3 4 5 6][0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 100] 指向数组的指针的使用12345678910111213141516171819202122232425package mainimport ( "fmt")func main() &#123; a := [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; // 声明指向数组的指针 var p *[10]int p = &amp;a fmt.Println(a) a[5] = 60 fmt.Println(a) fmt.Println(p) // 使用 new 关键词来创建指向数组的指针 q := new([10]int) fmt.Println(q) // 直接通过指针括号索引赋值即可对数组相应索引赋值 q[2] = 5 fmt.Println(q) fmt.Println(*q)&#125; 输出结果为： 123456[1 2 3 4 5 6 7 8 9 10][1 2 3 4 5 60 7 8 9 10]&amp;[1 2 3 4 5 60 7 8 9 10]&amp;[0 0 0 0 0 0 0 0 0 0]&amp;[0 0 5 0 0 0 0 0 0 0][0 0 5 0 0 0 0 0 0 0] 多维数组的声明和使用123456789101112131415package mainimport ( "fmt")func main() &#123; a := [2][3]int&#123; &#123;1, 1, 1&#125;, &#123;2, 2, 2&#125;&#125; fmt.Println(a) p := new([2][3]int) p = &amp;a fmt.Println(p)&#125; 输出结果为： 12[[1 1 1] [2 2 2]]&amp;[[1 1 1] [2 2 2]] 实现一个冒泡排序： 12345678910111213141516171819package mainimport ( "fmt")func main() &#123; a := [...]int&#123;10, 8, 3, 1, 9, 7&#125; fmt.Println("Before sort:", a) length := len(a) for i := 0; i &lt; length; i++ &#123; for j := i + 1; j &lt; length; j++ &#123; if a[i] &gt; a[j] &#123; a[i], a[j] = a[j], a[i] &#125; &#125; &#125; fmt.Println(" After sort:", a)&#125; 输出结果为： 12Before sort: [10 8 3 1 9 7] After sort: [1 3 7 8 9 10] Go 切片类型 其本身并不是数组，但它指向底层的数组 作为变长数组的替代方案，可以关联底层数组的局部或全部为引用类型 可以直接创建或从底层数组获取生成 使用 len() 获取元素个数，cap() 获取容量 一般使用 make() 创建 如果多个 slice 指向相同底层数组，其中一个的值改变会影响全部 根据数组创建切片123456789101112131415161718192021package mainimport ( "fmt")func main() &#123; // 声明切片时，方括号内不需要填任何数 var s1 []int fmt.Println(" s1:", s1) a := [5]int&#123;1, 2, 3, 4, 5&#125; fmt.Println(" a:", a) s2 := a[2:5] fmt.Println("a[2:5]:", s2) s3 := a[3:] fmt.Println("a[3: ]:", s3) s4 := a[:3] fmt.Println("a[ :3]:", s4) s5 := a[:] fmt.Println("a[ : ]:", s5)&#125; 输出结果为： 123456 s1: [] a: [1 2 3 4 5]a[2:5]: [3 4 5]a[3: ]: [4 5]a[ :3]: [1 2 3]a[ : ]: [1 2 3 4 5] 使用 make 创建切片123456789101112package mainimport ( "fmt")func main() &#123; // 使用 make 创建一个长度为3，容量为10的切片 s1 := make([]int, 3, 10) fmt.Println("s1:", s1) fmt.Printf("len: %d, cap: %d\n", len(s1), cap(s1))&#125; 输出结果为： 12s1: [0 0 0]len: 3, cap: 10 切片和数组的关系 切片实际上是对底层数组的引用 123456789101112131415161718package mainimport ( "fmt")func main() &#123; // 创建包含 a~k 字符 ascii 码的数组 a := []byte&#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'&#125; fmt.Println("a:", a) sa := a[2:5] // 对 a 数组索引[2，4]的数据进行应用 sb := a[3:5] // 对 a 数组索引[3，4]的数据进行应用 fmt.Println("a[2:5]:", string(sa), "a[3:5]:", string(sb)) // 因为是对数组的引用，某个切片对相关数据的修改也会影响其他切片 fmt.Println("Change sa[2] = 'z':") sa[2] = 'z' fmt.Println("a[2:5]:", string(sa), "a[3:5]:", string(sb), "a:", string(a))&#125; 输出结果为： 1234a: [97 98 99 100 101 102 103 104 105 106 107]a[2:5]: cde a[3:5]: deChange sa[2] = 'z':a[2:5]: cdz a[3:5]: dz a: abcdzfghijk append 函数对切片的内存处理机制 使用 append 为 slice 增加数据： 123456789101112131415161718192021package mainimport ( "fmt")func main() &#123; // 创建一个长度为3，容量为6的 int 型切片 s1 := make([]int, 3, 6) // 打印它的地址、数据形式，长度和容量 fmt.Println("Init s1:") fmt.Printf("s1: %p, %[1]v, len: %d, cap: %d\n", s1, len(s1), cap(s1)) // 使用内置函数 append 向其尾部添加数据 s1 = append(s1, 1, 2, 3) fmt.Println("Append s1 1, 2, 3:") fmt.Printf("s1: %p, %[1]v, len: %d, cap: %d\n", s1, len(s1), cap(s1)) // 当容量不够时，append 会将原始容量翻倍，并重新分配地址，原始数据拷贝一份至新地址 fmt.Println("Append s1 4, 5, 6:") s1 = append(s1, 4, 5, 6) fmt.Printf("s1: %p, %[1]v, len: %d, cap: %d\n", s1, len(s1), cap(s1))&#125; 输出结果为： 123456Init s1:s1: 0xc420012090, [0 0 0], len: 3, cap: 6Append s1 1, 2, 3:s1: 0xc420012090, [0 0 0 1 2 3], len: 6, cap: 6Append s1 4, 5, 6:s1: 0xc420072060, [0 0 0 1 2 3 4 5 6], len: 9, cap: 12 使用 append 删除 slice 指定索引的元素： 12345678910111213141516171819202122232425package mainimport ( "fmt")func main() &#123; s1 := []int&#123;1, 2, 3, 4, 5, 6&#125; println("Init slice:") printSlice(s1) s1 = del(s1, 2) fmt.Println("Del elements from slice: ") printSlice(s1)&#125;func del(s []int, index int) []int &#123; // 将 slice 展开 return append(s[:index], s[index+1:]...)&#125;func printSlice(s []int) &#123; // 打印 slice 的有关信息 fmt.Printf("slice: %v, len: %d, cap: %d, add: %p\n", s, len(s), cap(s), s)&#125; 输出结果为： 1234Init slice:slice: [1 2 3 4 5 6], len: 6, cap: 6, add: 0xc420012090Del elements from slice:slice: [1 2 4 5 6], len: 5, cap: 6, add: 0xc420012090 copy 函数对切片的复制 12345678910111213141516171819202122232425262728package mainimport ( "fmt")func main() &#123; s1 := []int&#123;1, 2, 3, 4, 5, 6&#125; s2 := []int&#123;7, 8, 9&#125; s3 := []int&#123;1, 2, 3, 4, 5, 6&#125; fmt.Println("s1:", s1, "s2:", s2, "s3:", s3) fmt.Printf("s1.address: %p, s2.address: %p, s3.address: %p\n\n", s1, s2, s3) // 将 s2 中数据 copy 到 s1 fmt.Println("Copy s2 to s1:") copy(s1, s2) fmt.Println("s1:", s1, "s2:", s2) // 将 s3 中数据 copy 到 s2 fmt.Println("Copy s3 to s2:") copy(s2, s3) fmt.Println("s3:", s3, "s2:", s2) // copy 不会改变切片容量及相关地址 fmt.Println("After copy:") fmt.Printf("s1.cap: %d, s2.cap: %d, s3.cap: %d\n", cap(s1), cap(s2), cap(s3)) fmt.Printf("s1.address: %p, s2.address: %p, s3.address: %p\n", s1, s2, s3)&#125; 输出结果为： 12345678910s1: [1 2 3 4 5 6] s2: [7 8 9] s3: [1 2 3 4 5 6]s1.address: 0xc420012090, s2.address: 0xc420016200, s3.address: 0xc4200120c0Copy s2 to s1:s1: [7 8 9 4 5 6] s2: [7 8 9]Copy s3 to s2:s3: [1 2 3 4 5 6] s2: [1 2 3]After copy:s1.cap: 6, s2.cap: 3, s3.cap: 6s1.address: 0xc420012090, s2.address: 0xc420016200, s3.address: 0xc4200120c0 切片的 reslice 和 extend 12345678910111213141516171819package mainimport ( "fmt")func main() &#123; arr := []int&#123;1, 2, 3, 4, 5, 6, 7&#125; printSlice(arr) s1 := arr[2:6] // reslice，获得原始切片的[2:6]部分，即 3，4，5，6 printSlice(s1) s2 := s1[3:5] // extend，尽管超出了 s1 的索引范围，但仍能指向最底层的数组，所以将自动拓展出去 printSlice(s2)&#125;func printSlice(s []int) &#123; // 打印 slice 的有关信息 fmt.Printf("slice: %v, len: %d, cap: %d, add: %p\n", s, len(s), cap(s), s)&#125; 输出结果为： 123slice: [1 2 3 4 5 6 7], len: 7, cap: 7, add: 0xc420014040slice: [3 4 5 6], len: 4, cap: 5, add: 0xc420014050slice: [6 7], len: 2, cap: 2, add: 0xc420014068 根据代码和图解可以知道：slice 不可以向前拓展，但可以向后拓展；且 s[i] 不能超越 len(s)，拓展不能超越底层数组 cap(s)。 Go map 类型 Go 中的 map 类似其它语言中的哈希表或者字典，以 key-value 形式存储数据 key 必须是支持 == 或 != 比较运算的类型，不可以是函数、map 或 slice map 查找比线性搜索快很多，但比使用索引访问数据的类型慢100倍 map 使用 make() 创建，支持 := 这种简写方式 make([keyType]valueType, cap)，cap 表示容量，可省略 超出容量时会自动扩容，但尽量提供一个合理的初始值 使用 len() 获取元素个数 键值对不存在时，map 会自动添加，使用 delete() 删除某键值对 使用 for range 可以对 map 和 slice 进行迭代操作 声明并创建一个 map1234567891011121314151617181920212223242526package mainimport ( "fmt")func main() &#123; // 显式声明创建 map var m map[int]string m = make(map[int]string) m[1] = "hello" m[2] = "world" m[3] = "!" fmt.Println(m) // 简短声明创建 map a := make(map[int]string) for i := 0; i &lt; 3; i++ &#123; a[i] = string(i + 65) &#125; fmt.Println(a) // 删除一个键值对 delete(a, 2) fmt.Println(a)&#125; 输出结果为： 123map[1:hello 2:world 3:!]map[0:A 1:B 2:C]map[0:A 1:B] 创建多层 map12345678910111213141516171819package mainimport ( "fmt")func main() &#123; // 声明并创建一个多级 map m := make(map[int]map[int]string) fmt.Println(m) for i := 1; i &lt;= 3; i++ &#123; // 还需要对里头的 map 进行赋值 if _, ok := m[i][1]; !ok &#123; m[i] = make(map[int]string) m[i][1] = string(i + 64) &#125; &#125; fmt.Println(m)&#125; 输出结果为： 12map[]map[2:map[1:B] 3:map[1:C] 1:map[1:A]] 使用 range 进行迭代12345678910111213141516171819202122package mainimport ( "fmt")func main() &#123; s := []int&#123;6, 7, 8, 9, 10&#125; // 对 slice 进行迭代，并对值进行修改 for i, num := range s &#123; fmt.Println(i, num) s[i] = i * 10 &#125; fmt.Println(s) m := map[int]string&#123;1: "A", 2: "B", 3: "C"&#125; fmt.Println(m) // 对 map 进行迭代 for k, v := range m &#123; fmt.Println(k, v) &#125;&#125; 输出结果为： 123456789100 61 72 83 94 10[0 10 20 30 40]map[2:B 3:C 1:A]3 C1 A2 B 迭代排序过的 map12345678910111213141516171819202122232425262728293031package mainimport ( "fmt" "sort")func main() &#123; m := map[int]string&#123;1: "A", 2: "B", 3: "C", 4: "D", 5: "E"&#125; fmt.Println(m) // 对 map 进行迭代 for k, v := range m &#123; fmt.Println(k, v) &#125; // 创建 slice 存储键值 s := make([]int, len(m)) i := 0 for k := range m &#123; s[i] = k i++ &#125; fmt.Println(s) // 使用 sort 包对 slice 排序 sort.Ints(s) fmt.Println(s) // 迭代排序过的键值 for _, k := range s &#123; fmt.Println(k, m[k]) &#125;&#125; 输出结果为： 12345678910111213map[1:A 2:B 3:C 4:D 5:E]4 D5 E1 A2 B3 C[2 3 4 5 1][1 2 3 4 5]1 A2 B3 C4 D5 E 利用 map 解决问题 计算一个字符串中最大不重复子串的长度 12345678910111213141516171819202122232425262728293031package mainimport ( "fmt")func main() &#123; s1 := "abcabcabbsab" fmt.Println(lengthOfNonRepeatingSubStr(s1)) s2 := "cbdaeababa" fmt.Println(lengthOfNonRepeatingSubStr(s2))&#125;func lengthOfNonRepeatingSubStr(s string) int &#123; // 得到最大不重复子串的长度 lastOccurred := make(map[byte]int) start, maxLength := 0, 0 for i, char := range []byte(s) &#123; if lastI, ok := lastOccurred[char]; ok &amp;&amp; lastI &gt;= start &#123; start = lastI + 1 &#125; if i-start+1 &gt; maxLength &#123; maxLength = i - start + 1 &#125; lastOccurred[char] = i &#125; return maxLength&#125; 输出结果为： 1235 Go 字符串类型 rune 相当于 Go 中的 char（占四个字节），它是32位 int 的别名 byte 相当于一个字节，它是8位 int 的别名 string 可以转化为 rune slice 或是 byte slice 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( "fmt" "unicode/utf8")func main() &#123; // 一个字符串包含了多个字节 s := "你好啊，我的名字叫 Sliver。" fmt.Println("s 的 byte 切片形式：") fmt.Printf("% X\n", []byte(s)) fmt.Println("\n循环遍历 s 的 string 形式：") for i, char := range s &#123; // i 代表的是字节编号，char 则是 utf-8 编码 fmt.Printf("(%d, %X) ", i, char) &#125; // 计算字符串中 rune 的数量 fmt.Println("\n\nRune count:", utf8.RuneCountInString(s)) // 将比特流中 utf-8 编码的数据转化为 rune bytes := []byte(s) for len(bytes) &gt; 0 &#123; // utf8.DecodeRune() 方法将会检测 bytes 流中第一个可以转化为 utf-8 编码的数据和它的所占大小 char, size := utf8.DecodeRune(bytes) bytes = bytes[size:] fmt.Printf("%c ", char) /* DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8. */ &#125; fmt.Printf("\n\n") fmt.Println("循环遍历 s 的 rune 切片形式：") for i, char := range []rune(s) &#123; fmt.Printf("(%d, %c) ", i, char) &#125;&#125; 输出结果为： 1234567891011s 的 byte 切片形式：E4 BD A0 E5 A5 BD E5 95 8A EF BC 8C E6 88 91 E7 9A 84 E5 90 8D E5 AD 97 E5 8F AB 20 53 6C 69 76 65 72 E3 80 82循环遍历 s 的 string 形式：(0, 4F60) (3, 597D) (6, 554A) (9, FF0C) (12, 6211) (15, 7684) (18, 540D) (21, 5B57) (24, 53EB) (27, 20) (28, 53) (29, 6C) (30, 69) (31, 76) (32, 65) (33, 72) (34, 3002)Rune count: 17你 好 啊 ， 我 的 名 字 叫 S l i v e r 。循环遍历 s 的 rune 切片形式：(0, 你) (1, 好) (2, 啊) (3, ，) (4, 我) (5, 的) (6, 名) (7, 字) (8, 叫) (9, ) (10, S) (11, l) (12, i) (13, v) (14, e) (15, r) (16, 。) 其他操作 12345678910111213141516171819202122232425262728293031package mainimport ( "fmt" "strings")var print = fmt.Printlnfunc main() &#123; print("Contains: ", strings.Contains("sliver", "li")) print("Count: ", strings.Count("sliver", "e")) print("HasPrefix: ", strings.HasPrefix("sliver", "sl")) print("HasSuffix: ", strings.HasSuffix("sliver", "er")) print("Index: ", strings.Index("sliver", "e")) print("LastIndex: ", strings.LastIndex("slivere", "e")) print("Join: ", strings.Join([]string&#123;"a", "b"&#125;, "-")) print("Repeat: ", strings.Repeat("a", 5)) print("Replace: ", strings.Replace("foo", "o", "0", -1)) print("Replace: ", strings.Replace("foo", "o", "0", 1)) print("Split: ", strings.Split("a-b-c-d-e", "-")) print("Fields: ", strings.Fields("a b c\nd\te")) print("ToLower: ", strings.ToLower("sliver")) print("ToUpper: ", strings.ToUpper("sliver")) print("Trim: ", strings.Trim("sliver", "sr")) print("TrimLeft: ", strings.TrimLeft("sliver", "sl")) print("TrimRight: ", strings.TrimRight("sliverrr", "r")) print("TrimSpace: ", strings.TrimSpace(" sliver ")) print("Len: ", len("hello")) print("Char:", "hello"[1])&#125; 输出结果为： 1234567891011121314151617181920Contains: trueCount: 1HasPrefix: trueHasSuffix: trueIndex: 4LastIndex: 6Join: a-bRepeat: aaaaaReplace: f00Replace: f0oSplit: [a b c d e]Fields: [a b c d e]ToLower: sliverToUpper: SLIVERTrim: liveTrimLeft: iverTrimRight: sliveTrimSpace: sliverLen: 5Char: 101 Go struct 类型 Go 中仅支持封装，不支持继承和多态 Go 中没有 class，只有 struct 不论地址还是结构本身，一律使用 . 来访问，不用使用 -&gt; 等方法来区分 可以使用自定义工厂函数，返回局部变量地址并不会发生错误 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( "fmt")type Point struct &#123; X, Y int&#125;type Node struct &#123; Value int Left, Right *Node&#125;func main() &#123; // 声明创建一个 Point a var a Point a = Point&#123;1, 2&#125; fmt.Println("Point a:", a) // 短变量声明 Point b b := Point&#123;X: 3, Y: 4&#125; fmt.Println("Point b:", b) // 创建 Point 类的切片 points := []Point&#123; &#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;, &#123;7, 8&#125;, &#125; fmt.Println("Point slice:", points) root := Node&#123;3, nil, nil&#125; fmt.Println("Init root:", root) root.Left = &amp;Node&#123;&#125; root.Right = &amp;Node&#123;5, nil, nil&#125; root.Right.Left = new(Node) fmt.Println(" New root:", root) // 使用工厂函数 root.Left = CreateNode(5) fmt.Println("root.Left:", root.Left)&#125;func CreateNode(value int) *Node &#123; return &amp;Node&#123;Value: value&#125;&#125; 输出结果为： 123456Point a: &#123;1 2&#125;Point b: &#123;3 4&#125;Point slice: [&#123;1 2&#125; &#123;3 4&#125; &#123;5 6&#125; &#123;7 8&#125;]Init root: &#123;3 &lt;nil&gt; &lt;nil&gt;&#125; New root: &#123;3 0xc42000a0a0 0xc42000a0c0&#125;root.Left: &amp;&#123;5 &lt;nil&gt; &lt;nil&gt;&#125; Go 中对方法的传递的也是值传递 只有使用指针才可以改变结构的内容 nil 指针也可以调用方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport ( "fmt")type Point struct &#123; X, Y int&#125;func main() &#123; // 声明创建一个 Point a var a Point a = Point&#123;1, 2&#125; fmt.Println("Point a:") a.print() // 短变量声明 Point b b := Point&#123;X: 3, Y: 4&#125; fmt.Println("Point b:") b.print() fmt.Println("Point a + Point b:") c := add(a, b) c.print() // 创建 Point 类的切片 points := []Point&#123; &#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;, &#123;7, 8&#125;, &#125; fmt.Println("Point slice:", points) d := Point&#123;X: 10, Y: 11&#125; fmt.Println("Init Point d:") d.print() d.setValue(100, 110) fmt.Println("Point d setValue:") d.print() d.setValueNew(100, 110) fmt.Println("Point d setValueNew:") d.print()&#125;func (p Point) print() &#123; // 创建类方法 fmt.Printf("Point.X = %d, Point.Y = %d\n", p.X, p.Y)&#125;func (p Point) setValue(x, y int) &#123; // 使用值作为方法接受者，不会改变值 p.X, p.Y = x, y&#125;func (p *Point) setValueNew(x, y int) &#123; // 只有指针作为方法接受者，可以改变值 p.X, p.Y = x, y&#125;func add(p1, p2 Point) Point &#123; return Point&#123;X: p1.X + p2.X, Y: p1.Y + p2.Y&#125;&#125; 输出结果为： 12345678910111213Point a:Point.X = 1, Point.Y = 2Point b:Point.X = 3, Point.Y = 4Point a + Point b:Point.X = 4, Point.Y = 6Point slice: [&#123;1 2&#125; &#123;3 4&#125; &#123;5 6&#125; &#123;7 8&#125;]Init Point d:Point.X = 10, Point.Y = 11Point d setValue:Point.X = 10, Point.Y = 11Point d setValueNew:Point.X = 100, Point.Y = 110 值接收者是 Go 中特有的 值/指针接收者均可以接收值/指针 要改变内容必须使用指针接受者 结构过大也考虑使用指针接受者 Go 拓展类型 利用 type 拓展已有类型 12345678910111213141516171819202122232425262728293031package mainimport ( "fmt")type Queue []intfunc (q *Queue) Push(v int) &#123; *q = append(*q, v)&#125;func (q *Queue) Pop() int &#123; head := (*q)[0] *q = (*q)[1:] return head&#125;func (q *Queue) IsEmpty() bool &#123; return len(*q) == 0&#125;func main() &#123; q := Queue&#123;1, 2, 3&#125; fmt.Println("Queue:", q) q.Push(4) q.Push(5) fmt.Println("After push:", q) fmt.Println("Queue q Pop:", q.Pop(), "Queue q:", q) fmt.Println("IsEmpty:", q.IsEmpty())&#125; 输出结果为： 1234Queue: [1 2 3]After push: [1 2 3 4 5]Queue q Pop: 1 Queue q: [2 3 4 5]IsEmpty: false Go 函数 Go 函数不支持嵌套、重载和默认参数，但支持以下特性： 无需声明原型、拥有不定长度变参、多返回值、命名返回值参数 拥有匿名函数、闭包特性 定义函数使用关键字 func，且左大括号不能另起一行 函数返回值类型要写在声明后面 函数也可以作为一种类型使用，并作为参数传入 定义基本函数123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( "fmt")func main() &#123; // 不同类型参数，单返回值 fmt.Println(operator(1, 2, "+")) fmt.Println(operator(3, 4, "-")) fmt.Println(operator(5, 6, "*")) fmt.Println(operator(7, 8, "/")) // fmt.Println(operator(9, 10, "&amp;")) // 相同类型参数，多返回值 fmt.Println(div(2, 3)) fmt.Println(div(10, 3))&#125;func operator(a int, b int, op string) int &#123; // 加减乘除操作函数 switch op &#123; case "+": return a + b case "-": return a - b case "*": return a * b case "/": return a / b default: panic("Unsupported operation: " + op) &#125;&#125;func div(a, b int) (int, int) &#123; // 带余除法 return a / b, a % b&#125; 输出结果为： 1234563-13000 23 1 添加错误处理机制1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( "fmt")func main() &#123; // 判断异常 if result, err := operatorPlus(1, 2, "+"); err != nil &#123; fmt.Println(err) &#125; else &#123; fmt.Println(result) &#125; if result, err := operatorPlus(1, 2, "x"); err != nil &#123; fmt.Println(err) &#125; else &#123; fmt.Println(result) &#125; // 命名返回参数 fmt.Println(divPlus(10, 4))&#125;func operatorPlus(a, b int, op string) (int, error) &#123; // 加减乘除操作函数 switch op &#123; case "+": return a + b, nil case "-": return a - b, nil case "*": return a * b, nil case "/": return a / b, nil default: return 0, fmt.Errorf("Unsupported operation: %s", op) &#125;&#125;func divPlus(a, b int) (q, r int) &#123; // 带余除法，并命名返回值参数 return a / b, a % b&#125; 输出结果为： 1233Unsupported operation: x2 2 函数式编程和匿名函数将函数作为参数和匿名函数： 12345678910111213141516171819202122232425262728293031package mainimport ( "fmt" "math" "reflect" "runtime" "strconv")func main() &#123; // 函数式编程，这里将类似 Python 的装饰器进行使用 fmt.Println(apply(pow, 3, 4)) // 使用匿名函数 fmt.Println(apply(func(a, b int) int &#123; return int(math.Pow(float64(a), float64(b))) &#125;, 3, 4))&#125;func apply(op func(int, int) int, a, b int) string &#123; p := reflect.ValueOf(op).Pointer() // 获取当前传入函数的名称 opName := runtime.FuncForPC(p).Name() fmt.Printf("Calling function %s with args (%d, %d)\n", opName, a, b) return fmt.Sprintf("result: " + strconv.Itoa(op(a, b)))&#125;func pow(a, b int) int &#123; return int(math.Pow(float64(a), float64(b)))&#125; 输出结果为： 1234Calling function main.pow with args (3, 4)result: 81Calling function main.main.func1 with args (3, 4)result: 81 闭包： 1234567891011121314151617181920package mainimport ( "fmt")func adder() func(int) int &#123; sum := 0 return func(v int) int &#123; sum += v return sum &#125;&#125;func main() &#123; a := adder() for i := 0; i &lt; 10; i++ &#123; fmt.Println(a(i)) &#125;&#125; 输出结果为： 123456789100136101521283645 可变参数调用123456789101112131415161718package mainimport ( "fmt")func main() &#123; // 使用不定长参数 fmt.Println(sum(1, 2, 3, 4, 5))&#125;func sum(numbers ...int) int &#123; var s int for i := range numbers &#123; s += numbers[i] &#125; return s&#125; 输出结果为： 115 Go interface 类型 Duck typing - ”像鸭子走路，像鸭子叫（长得像鸭子），那么它就是鸭子“ 描述事物的外部行为，而不是内部结构 Go 属于结构化系统结构，类似 duck typing Interface 其实是一组方法签名的集合，使用一个 interface 可以识别一个对象能够进行的操作 实现一个 Fakeduck1 和 Fakeduck2，如果它们都有 Gaga() 和 LikeDuck() 方法，就可以当做成一个 Duck，这也是 interface 的思想 Interface 只有方法声明，没有实现也没有数据字段 Example 1: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package mainimport ( "fmt")// USB &amp; Connecter interfacetype USB interface &#123; Name() string Connecter // 组合 interface&#125;type Connecter interface &#123; Connect()&#125;// PhoneConnectertype PhoneConnecter struct &#123; name string&#125;func (phone PhoneConnecter) Name() string &#123; return phone.name&#125;func (phone PhoneConnecter) Connect() &#123; fmt.Println("Connected:", phone.name)&#125;// ComputerConnectertype ComputerConnecter struct &#123; name string brand string size string&#125;func (c ComputerConnecter) Name() string &#123; return fmt.Sprintf("Name - %s, Brand - %s, Size - %s", c.name, c.brand, c.size)&#125;func (c ComputerConnecter) Connect() &#123; fmt.Println("Connected:", c.name)&#125;// TVConnectertype TVConnecter struct &#123; name string&#125;func (tv TVConnecter) Name() string &#123; return tv.name&#125;func main() &#123; var p USB p = PhoneConnecter&#123;"iPhone 6s Plus"&#125; fmt.Println(p.Name()) p.Connect() DisConnect(p) var c USB c = ComputerConnecter&#123;name: "MacBook Pro 2018", brand: "Apple", size: "512GB"&#125; fmt.Println(c.Name()) c.Connect() DisConnect(c) t := TVConnecter&#123;"Apple TV 4K"&#125; fmt.Println(t.Name()) DisConnectNew(t) DisConnectNew(p) DisConnectNew(c)&#125;func DisConnect(usb USB) &#123; // 判断传入的 usb 是否为 PhoneConnecter（类型断言） if phone, ok := usb.(PhoneConnecter); ok &#123; fmt.Printf("Disconnected: %s\n\n", phone.name) return &#125; fmt.Println("Unknown device.\n")&#125;func DisConnectNew(usb interface&#123;&#125;) &#123; // switch type 对空接口的类型进行判断 switch device := usb.(type) &#123; case PhoneConnecter: fmt.Printf("Phone disconnected: %s\n", device.name) case ComputerConnecter: fmt.Printf("Computer disconnected: %s\n", device.name) default: fmt.Println("Unknown device.\n") &#125;&#125; 输出结果为： 12345678910111213iPhone 6s PlusConnected: iPhone 6s PlusDisconnected: iPhone 6s PlusName - MacBook Pro 2018, Brand - Apple, Size - 512GBConnected: MacBook Pro 2018Unknown device.Apple TV 4KUnknown device.Phone disconnected: iPhone 6s PlusComputer disconnected: MacBook Pro 2018 Interface 变量存储着实现者的类型和实现者的值/指针 Example 2: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport ( "fmt")type Human struct &#123; // 创建 Human name string age int phone string&#125;type Student struct &#123; // 创建 Student Human school string number string&#125;func (s Student) SayHi() &#123; fmt.Printf("Hi, I'm %s, my school is %s.\n", s.Human.name, s.school)&#125;func (student Student) Sing() &#123; fmt.Println("La la, la la la la...")&#125;type Employee struct &#123; // 创建 Employee Human company string money float64&#125;func (e Employee) SayHi() &#123; fmt.Printf("Hi, I'm %s, my company is %s.\n", e.Human.name, e.company)&#125;func (e Employee) Sing() &#123; fmt.Println("Hh, hh hh hh...")&#125;type Men interface &#123; // 创建 Men 接口，需要实现 SayHi，Sing 方法 SayHi() Sing()&#125;func SayHiAndSing(m Men) &#123; fmt.Printf("%T, %v\n", m, m) m.SayHi() m.Sing()&#125;func main() &#123; s := Student&#123;Human&#123;"Sliver", 10, "1234"&#125;, "HDU", "16"&#125; s.SayHi() s.Sing() e := Employee&#123;Human&#123;"Ariel", 8, "4321"&#125;, "COM", 5000&#125; e.SayHi() e.Sing() SayHiAndSing(s) SayHiAndSing(e)&#125; 输出结果为： 12345678910Hi, I'm Sliver, my school is HDU.La la, la la la la...Hi, I'm Ariel, my company is COM.Hh, hh hh hh...main.Student, &#123;&#123;Sliver 10 1234&#125; HDU 16&#125;Hi, I'm Sliver, my school is HDU.La la, la la la la...main.Employee, &#123;&#123;Ariel 8 4321&#125; COM 5000&#125;Hi, I'm Ariel, my company is COM.Hh, hh hh hh... 使用 interface{} 代表任意类型（作为接受任何类型的容器） 123456789101112131415161718192021222324252627282930313233343536package mainimport ( "fmt")type Queue []interface&#123;&#125;func (q *Queue) Push(v interface&#123;&#125;) &#123; *q = append(*q, v)&#125;func (q *Queue) Pop() interface&#123;&#125; &#123; head := (*q)[0] *q = (*q)[1:] return head&#125;func (q *Queue) IsEmpty() bool &#123; return len(*q) == 0&#125;func main() &#123; q := Queue&#123;1, 2, 3&#125; fmt.Println("Queue:", q) q.Push(4) q.Push(5) fmt.Println("After push:", q) fmt.Println("Queue q Pop:", q.Pop(), "Queue q:", q) fmt.Println("IsEmpty:", q.IsEmpty()) q.Push("abc") q.Push(123.45) q.Push(true) fmt.Println(q)&#125; 输出结果为： 12345Queue: [1 2 3]After push: [1 2 3 4 5]Queue q Pop: 1 Queue q: [2 3 4 5]IsEmpty: false[2 3 4 5 abc 123.45 true] io.Reader 接口的使用 123456789101112131415161718192021package mainimport ( "bytes" "fmt" "io" "os")func main() &#123; var b bytes.Buffer // 将字符串写入 Buffer b.Write([]byte("Hello,")) // 使用 Fprintf 将字符串拼接到 Buffer fmt.Fprintf(&amp;b, " world!") // 将 Buffer 的内容写到 Stdout io.Copy(os.Stdout, &amp;b)&#125; 输出结果为： 1Hello, world!% Go 资源管理与出错处理defer 的使用修改 return 的值： 123456789101112131415161718192021222324package mainimport ( "fmt")func main() &#123; double(3) double(5) tryDefer()&#125;func double(x int) (result int) &#123; defer func() &#123; fmt.Printf("double(%d) = %d\n", x, result) &#125;() return x + x&#125;func tryDefer() &#123; defer fmt.Println("Defer!") fmt.Println("1") fmt.Println("2") return fmt.Println("3")&#125; 输出结果为： 12345double(3) = 6double(5) = 1012Defer! 文件关闭和资源清理： 123456789101112131415161718192021222324252627282930313233package mainimport ( "bufio" "fmt" "os")func main() &#123; writeFile("defer.txt")&#125;func writeFile(filename string) &#123; file, err := os.Create(filename) if err != nil &#123; panic(err) &#125; defer func() &#123; file.Close() fmt.Println("File close successfully!") &#125;() writer := bufio.NewWriter(file) defer func() &#123; writer.Flush() fmt.Println("Writer flush successfully!") &#125;() for i := 0; i &lt; 20; i++ &#123; fmt.Fprintln(writer, i) &#125; fmt.Println("Finished.")&#125; 输出结果为： 123FinishedWriter flush successfully!File close successfully! defer 的执行方式类似其它语言中的析构函数，在函数体执行结束后，按照调用顺序的相反顺序逐个执行 defer 在函数发生严重错误时也会执行 defer 支持匿名函数的调用 defer 常用于资源清理、文件关闭、解锁以及记录时间等操作 通过与匿名函数配合可在 return 之后修改函数计算结果 如果函数体内某个变量作为 defer 时匿名函数的参数，则在定义 defer 时即已经获得了拷贝，否则则是引用某个变量的地址 painc 和 recover 的使用panic 停止当前程序执行 一直向上返回，执行每一层的 defer 如果没有遇见 recover，程序退出 recover 仅在 defer 调用中使用 获取 panic 的值 如果无法处理，可重新 panic 12345678910111213141516171819202122package mainimport ( "errors" "fmt")func main() &#123; tryRecover()&#125;func tryRecover() &#123; defer func() &#123; r := recover() if err, ok := r.(error); ok &#123; fmt.Println("An error occured:", err) &#125; else &#123; panic(r) &#125; &#125;() panic(errors.New("this is an error"))&#125; 输出结果为： 1An error occured: this is an error Go 并发编程goroutine 简单开启多个 goroutine： 123456789101112131415161718package mainimport ( "fmt" "time")func main() &#123; for i := 0; i &lt; 10; i++ &#123; go func(i int) &#123; for &#123; fmt.Printf("Hello from goroutine %d\n", i) &#125; &#125;(i) &#125; // 防止 main() 直接结束杀掉了其他 goroutine，延时一段时间 time.Sleep(time.Millisecond)&#125; 输出结果为： 1234567891011121314Hello from goroutine 1Hello from goroutine 1Hello from goroutine 1Hello from goroutine 1Hello from goroutine 1...Hello from goroutine 4Hello from goroutine 4Hello from goroutine 4Hello from goroutine 4Hello from goroutine 9Hello from goroutine 9Hello from goroutine 9Hello from goroutine 9 goroutine 相当于协程 coroutine 协程是一种轻量级线程 协程是非抢占式多任务处理，由协程主动交出控制权 协程是编译器/解释器/虚拟机层面的多任务 多个协程可以在一个线程或多个线程上运行 1234567891011121314151617181920package mainimport ( "fmt" "time")func main() &#123; var a [10]int for i := 0; i &lt; 10; i++ &#123; go func(i int) &#123; for &#123; a[i]++ &#125; &#125;(i) &#125; // 防止 main() 直接结束杀掉了其他 goroutine，延时一段时间 time.Sleep(time.Millisecond) fmt.Println(a)&#125; 如果执行以上代码，会发现程序其实进入了死循环，因为 goroutine 需要主动释放控制权，否则第一个 goroutine 将会一直占用。 1234567891011121314151617181920212223package mainimport ( "fmt" "runtime" "time")func main() &#123; var a [10]int for i := 0; i &lt; 10; i++ &#123; go func(i int) &#123; for &#123; a[i]++ // 一个协程交出控制权后，其余协程也将可以继续进行操作 runtime.Gosched() &#125; &#125;(i) &#125; // 防止 main() 直接结束杀掉了其他 goroutine，延时一段时间 time.Sleep(time.Millisecond) fmt.Println(a)&#125; 输出结果为： 1[523 493 436 414 439 416 442 431 405 449] 代码相当于在 main() 函数中开启了 10 个 goroutine，main() 之后执行 time.Sleep() 阻塞自己，出让控制权给其余10个 goroutine，这 10 个 goroutine 互相出让控制权，最后 main() 阻塞完毕，打印输出数组 a。 再来个例子： 123456789101112131415161718package mainimport ( "fmt" "time")func say(s string) &#123; for i := 0; i &lt; 5; i++ &#123; time.Sleep(100 * time.Millisecond) fmt.Println(s) &#125;&#125;func main() &#123; go say("world") say("hello")&#125; 输出结果为： 12345678910helloworldworldhellohelloworldhelloworldworldhello 可以得到，在 Go 语言中： 任何函数只需要加上 go 就能给调度器运行 不需要在定义时区分是否是异步函数 调度器会在合适的点进行切换（如：I/O，channel，等待锁，runtime.Gosched()等） channel channel 是 goroutine 沟通的桥梁，大都是阻塞同步的 通过 make 创建，close 关闭 channel 是引用类型 可以使用 for range 来迭代不断操作 channel 可以设置单向或双向通道 可以设置缓存大小，在未被填满前不会发生阻塞 简单使用 channel： 12345678910111213141516171819202122232425262728package mainimport ( "fmt" "time")func main() &#123; chaner()&#125;func worker(c chan int) &#123; for &#123; n := &lt;-c fmt.Println(n) &#125;&#125;func chaner() &#123; c := make(chan int) go worker(c) for i := 0; i &lt; 10; i++ &#123; c &lt;- i &#125; time.Sleep(time.Millisecond)&#125; 输出结果为： 123456789100123456789 使用多个 goroutine： 123456789101112131415161718192021222324252627282930package mainimport ( "fmt" "time")func main() &#123; chaner()&#125;func worker(id int, c chan int) &#123; for &#123; n := &lt;-c fmt.Printf("Worker %d received %c\n", id, n) &#125;&#125;func chaner() &#123; var channels [10]chan int for i := 0; i &lt; 10; i++ &#123; channels[i] = make(chan int) go worker(i, channels[i]) &#125; for i := 0; i &lt; 10; i++ &#123; channels[i] &lt;- 'A' + i &#125; time.Sleep(time.Millisecond)&#125; 输出结果为： 12345678910Worker 0 received AWorker 4 received EWorker 3 received DWorker 1 received BWorker 7 received HWorker 5 received FWorker 6 received GWorker 8 received IWorker 2 received CWorker 9 received J 使用工厂函数生成 channel： 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( "fmt" "time")func main() &#123; chaner()&#125;func createWorker(id int) chan&lt;- int &#123; c := make(chan int) go func() &#123; for &#123; fmt.Printf("Worker %d received %c\n", id, &lt;-c) &#125; &#125;() return c&#125;func chaner() &#123; var channels [10]chan&lt;- int for i := 0; i &lt; 10; i++ &#123; channels[i] = createWorker(i) &#125; for i := 0; i &lt; 10; i++ &#123; channels[i] &lt;- 'A' + i &#125; for i := 0; i &lt; 10; i++ &#123; channels[i] &lt;- 'a' + i &#125; time.Sleep(time.Millisecond)&#125; 输出结果为： 1234567891011121314151617181920Worker 0 received AWorker 5 received FWorker 1 received BWorker 2 received CWorker 3 received DWorker 4 received EWorker 6 received GWorker 7 received HWorker 8 received IWorker 9 received JWorker 0 received aWorker 8 received iWorker 1 received bWorker 9 received jWorker 2 received cWorker 3 received dWorker 4 received eWorker 5 received fWorker 6 received gWorker 7 received h 适时关闭 channel： 1234567891011121314151617181920212223242526272829303132package mainimport ( "fmt" "time")func main() &#123; chaner()&#125;func worker(c chan int) &#123; for &#123; if n, ok := &lt;-c; !ok &#123; break &#125; else &#123; fmt.Printf("received %d\n", n) &#125; &#125;&#125;func chaner() &#123; c := make(chan int) go worker(c) for i := 0; i &lt; 10; i++ &#123; c &lt;- i &#125; close(c) // 关闭 channel time.Sleep(time.Millisecond)&#125; 输出结果为： 12345678910received 0received 1received 2received 3received 4received 5received 6received 7received 8received 9 自定义信号量，通知其它 goroutine： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( "fmt")type worker struct &#123; in chan int done chan bool&#125;func main() &#123; chaner()&#125;func doWork(id int, c chan int, done chan bool) &#123; for &#123; for n := range c &#123; fmt.Printf("Worker %d received %c\n", id, n) done &lt;- true &#125; &#125;&#125;func createWorker(id int) worker &#123; w := worker&#123; in: make(chan int), done: make(chan bool), &#125; go doWork(id, w.in, w.done) return w&#125;func chaner() &#123; var workers [10]worker for i := 0; i &lt; 10; i++ &#123; workers[i] = createWorker(i) &#125; for i := 0; i &lt; 10; i++ &#123; workers[i].in &lt;- 'a' + i &#125; for _, work := range workers &#123; &lt;-work.done &#125; for i := 0; i &lt; 10; i++ &#123; workers[i].in &lt;- 'A' + i &#125; for _, work := range workers &#123; &lt;-work.done &#125;&#125; 输出结果为： 1234567891011121314151617181920Worker 1 received bWorker 6 received gWorker 2 received cWorker 8 received iWorker 4 received eWorker 5 received fWorker 0 received aWorker 7 received hWorker 9 received jWorker 3 received dWorker 3 received DWorker 0 received AWorker 4 received EWorker 5 received FWorker 6 received GWorker 7 received HWorker 8 received IWorker 9 received JWorker 1 received BWorker 2 received C 使用 sync 包： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( "fmt" "sync")type worker struct &#123; in chan int done func()&#125;func main() &#123; chaner()&#125;func doWork(id int, w worker) &#123; for &#123; for n := range w.in &#123; fmt.Printf("Worker %d received %c\n", id, n) w.done() &#125; &#125;&#125;func createWorker(id int, wg *sync.WaitGroup) worker &#123; w := worker&#123; in: make(chan int), done: func() &#123; wg.Done() &#125;, &#125; go doWork(id, w) return w&#125;func chaner() &#123; var workers [10]worker var wg sync.WaitGroup for i := 0; i &lt; 10; i++ &#123; workers[i] = createWorker(i, &amp;wg) &#125; wg.Add(20) for i := 0; i &lt; 10; i++ &#123; workers[i].in &lt;- 'a' + i &#125; for i := 0; i &lt; 10; i++ &#123; workers[i].in &lt;- 'A' + i &#125; wg.Wait()&#125; 输出结果为： 1234567891011121314151617181920Worker 0 received aWorker 0 received AWorker 8 received iWorker 9 received jWorker 2 received cWorker 1 received bWorker 7 received hWorker 3 received dWorker 3 received DWorker 2 received CWorker 5 received fWorker 1 received BWorker 4 received eWorker 6 received gWorker 6 received GWorker 4 received EWorker 5 received FWorker 9 received JWorker 7 received HWorker 8 received I select 可处理一个或多个 channel 的发送与接收 同时有多个可用的 channel 时按随机顺序处理 可用空的 select 来阻塞 main 函数 可设置超时 使用 select 非阻塞式获取数据： 1234567891011121314151617181920212223242526272829303132333435package mainimport ( "fmt" "math/rand" "time")func generator() chan int &#123; out := make(chan int) go func() &#123; i := 0 for &#123; time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond) out &lt;- i i++ &#125; &#125;() return out&#125;func main() &#123; var c1, c2, c3 = generator(), generator(), generator() // 非阻塞式获取 for &#123; select &#123; case n := &lt;-c1: fmt.Println("Received form c1:", n) case n := &lt;-c2: fmt.Println("Received form c2:", n) case n := &lt;-c3: fmt.Println("Received form c3:", n) &#125; &#125;&#125; 输出结果为： 1234567891011121314151617181920212223242526Received form c3: 0Received form c3: 1Received form c3: 2Received form c3: 3Received form c2: 0Received form c1: 0Received form c3: 4Received form c3: 5Received form c1: 1Received form c2: 1Received form c2: 2Received form c2: 3Received form c1: 2Received form c3: 6Received form c1: 3Received form c3: 7Received form c2: 4Received form c3: 8Received form c2: 5Received form c1: 4Received form c3: 9Received form c2: 6Received form c2: 7Received form c1: 5Received form c3: 10... 构建生产者消费者模型： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package mainimport ( "fmt" "math/rand" "time")func createProducer() chan int &#123; // 不断通过 channel 产生新数据 out := make(chan int) go func() &#123; i := 0 for &#123; // 随机在 [0,1000) 毫秒内生成数据 time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond) out &lt;- i i++ &#125; &#125;() return out&#125;func customer(id int, c chan int) &#123; // 相当于从 channel 获取数据并消耗数据 for n := range c &#123; // 控制每200毫秒消耗数据 time.Sleep(time.Duration(200) * time.Millisecond) fmt.Printf("Customer %d received %d\n", id, n) &#125;&#125;func createCustomer(id int) chan&lt;- int &#123; // 生成一个 customer c := make(chan int) go customer(id, c) return c&#125;func main() &#123; var p1, p2 = createProducer(), createProducer() c := createCustomer(0) // 构建消费者生产者模型 // values 存储生产者生成的数据，相当于数据队列 var values []int tm := time.After(10 * time.Second) // 定时10s后结束程序 tick := time.Tick(time.Second) // 每隔1秒产生一个 tick 信号 for &#123; var activeCustomerr chan&lt;- int var activeValue int if len(values) &gt; 0 &#123; activeCustomerr = c activeValue = values[0] &#125; select &#123; case n := &lt;-p1: // 生产者插入信息 values = append(values, n) case n := &lt;-p2: values = append(values, n) case activeCustomerr &lt;- activeValue: // 消费者消耗信息 values = values[1:] case &lt;-tick: // 每隔一秒打印当前数据队列情况 fmt.Println("Quene:", values) case &lt;-tm: // 到达10s定时时间后结束程序 fmt.Println("Bye.") return &#125; &#125;&#125; 输出结果为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Customer 0 received 0Quene: [1 1]Customer 0 received 0Customer 0 received 1Customer 0 received 1Customer 0 received 2Customer 0 received 2Quene: [3 4]Customer 0 received 3Customer 0 received 3Customer 0 received 4Customer 0 received 4Customer 0 received 5Quene: [6 6]Customer 0 received 5Customer 0 received 6Customer 0 received 6Customer 0 received 7Customer 0 received 8Quene: [8 9 9]Customer 0 received 7Customer 0 received 8Customer 0 received 9Customer 0 received 9Customer 0 received 10Quene: [11 12 11]Customer 0 received 10Customer 0 received 11Customer 0 received 12Customer 0 received 11Customer 0 received 12Quene: [13 14]Customer 0 received 13Customer 0 received 13Customer 0 received 14Customer 0 received 14Customer 0 received 15Quene: [16]Customer 0 received 15Customer 0 received 16Customer 0 received 17Customer 0 received 16Customer 0 received 18Quene: []Customer 0 received 19Customer 0 received 17Customer 0 received 18Quene: [20 20 21]Customer 0 received 19Customer 0 received 20Customer 0 received 20Customer 0 received 21Customer 0 received 22Bye. Go 标准库http 通过 http.Get() 访问 URL： 12345678910111213141516171819202122package mainimport ( "fmt" "net/http" "net/http/httputil")func main() &#123; resp, err := http.Get("http://www.imooc.com") if err != nil &#123; fmt.Println(err) &#125; defer resp.Body.Close() s, err := httputil.DumpResponse(resp, true) if err != nil &#123; fmt.Println(err) &#125; fmt.Printf("%s\n", s)&#125; 将 request 包装一下： 1234567891011121314151617181920212223242526package mainimport ( "fmt" "net/http" "net/http/httputil")func main() &#123; request, err := http.NewRequest(http.MethodGet, "http://www.imooc.com", nil) request.Header.Add("User-Agent", "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1") resp, err := http.DefaultClient.Do(request) if err != nil &#123; fmt.Println(err) &#125; defer resp.Body.Close() s, err := httputil.DumpResponse(resp, true) if err != nil &#123; fmt.Println(err) &#125; fmt.Printf("%s\n", s)&#125; rand 123456789101112131415161718192021222324252627282930313233package mainimport ( "fmt" "math/rand" "time")func main() &#123; // 初始化随机数种子 rand.Seed(time.Now().UnixNano()) // rand.Intn() 返回一个随机的整数 r，0 &lt;= r &lt; n fmt.Printf("rand.Intn(100): %d, %d\n", rand.Intn(100), rand.Intn(100)) // rand.Float64() 返回一个64位浮点数 f，0.0 &lt;= f &lt; 1.0 fmt.Printf("rand.Float64(): %f\n", rand.Float64()) // 要让伪随机数生成器有确定性，可以给它一个明确的种子 fmt.Println("Seed from s1:") s1 := rand.NewSource(42) r1 := rand.New(s1) fmt.Println(r1.Intn(100)) fmt.Println(r1.Intn(100)) // 如果使用相同的种子生成的随机数生成器，将会产生相同的随机数序列 fmt.Println("Seed from s2:") s2 := rand.NewSource(42) r2 := rand.New(s2) fmt.Println(r2.Intn(100)) fmt.Println(r2.Intn(100)) // 返回一个有n个元素的，[0,n)范围内整数的伪随机排列的切片 fmt.Println("Rand n slice:", rand.Perm(10))&#125; 输出结果为： 123456789rand.Intn(100): 71, 58rand.Float64(): 0.206703Seed from s1:587Seed from s2:587Rand n slice: [2 3 7 6 0 5 9 4 1 8] math 123456789101112131415161718192021222324package mainimport ( "fmt" "math")func main() &#123; fmt.Println(math.Abs(float64(-100))) // 绝对值 fmt.Println(math.Ceil(5.0)) // 向上取整 fmt.Println(math.Floor(5.8)) // 向下取整 fmt.Println(math.Mod(11, 3)) // 取余数，同 11 % 3 fmt.Println(math.Modf(5.26)) // 分别获得整数和小数部分 fmt.Println(math.Pow(3, 2)) // x 的 y 次方 fmt.Println(math.Pow10(4)) // 10的 n 次方 fmt.Println(math.Sqrt(8)) // 开平方 fmt.Println(math.Cbrt(8)) // 开立方 fmt.Println(math.Pi) // π 的值 fmt.Println(math.Max(5, 9)) // 获得 5 和 9 中的最大值 fmt.Println(math.Min(5, 9)) // 获得 5 和 9 中的最小值 fmt.Println(math.Hypot(3, 4)) // 勾股定理 fmt.Println(math.Sin(math.Pi * 30.0 / 180)) // sin 函数 fmt.Println(math.IsNaN(30)) // 判断是否为合法数字&#125; 输出结果为： 1234567891011121314151005525 0.25999999999999989100002.828427124746190323.1415926535897939550.5false sort 正向排序： 12345678910111213141516171819package mainimport ( "fmt" "sort")func main() &#123; // 使用 sort 函数对 int、float、string 类型进行正向排序 intList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125; floatList := []float64&#123;4.2, 5.9, 11.3, 18.8, 50.4, 99.9, 31.4, 27.88, 3.14&#125; stringList := []string&#123;"a", "c", "b", "d", "f", "i", "z", "x", "w", "y"&#125; sort.Ints(intList) sort.Float64s(floatList) sort.Strings(stringList) fmt.Printf("%v\n%v\n%v\n", intList, floatList, stringList)&#125; 输出结果为： 123[0 1 2 3 4 5 6 7 8 9][3.14 4.2 5.9 11.3 18.8 27.88 31.4 50.4 99.9][a b c d f i w x y z] 逆向排序： 12345678910111213141516171819package mainimport ( "fmt" "sort")func main() &#123; // 使用 sort 函数对 int、float、string 类型进行逆向排序 intList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125; floatList := []float64&#123;4.2, 5.9, 11.3, 18.8, 50.4, 99.9, 31.4, 27.88, 3.14&#125; stringList := []string&#123;"a", "c", "b", "d", "f", "i", "z", "x", "w", "y"&#125; sort.Sort(sort.Reverse(sort.IntSlice(intList))) sort.Sort(sort.Reverse(sort.Float64Slice(floatList))) sort.Sort(sort.Reverse(sort.StringSlice(stringList))) fmt.Printf("%v\n%v\n%v\n", intList, floatList, stringList)&#125; 输出结果为： 123[9 8 7 6 5 4 3 2 1 0][99.9 50.4 31.4 27.88 18.8 11.3 5.9 4.2 3.14][z y x w i f d c b a] sort 包中有一个 sort.Interface 接口，该接口有三个方法 Len()、Less(i, j) 和 Swap(i, j)。通用排序函数 sort.Sort 可以排序任何实现了 sort.Inferface 接口的对象（变量）。对于 [] int、[] float64 和 [] string 除了使用特殊指定的函数外，还可以使用改装过的类型 IntSclice 、Float64Slice 和 StringSlice，然后直接调用它们对应的 Sort() 方法；因为这三种类型也实现了 sort.Interface 接口，所以可以通过 sort.Reverse 来转换这三种类型的 Interface.Less 方法来实现逆向排序，这就是前面第二个排序的使用。 实现自定义结构体的排序接口： 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( "fmt" "sort")type Person struct &#123; Name string // 姓名 Age int // 年龄&#125;// 按照 Person.Age 从大到小排序type PersonSlice []Personfunc (p PersonSlice) Len() int &#123; // 重写 Len() 方法 return len(p)&#125;func (p PersonSlice) Swap(i, j int) &#123; // 重写 Swap() 方法 p[i], p[j] = p[j], p[i]&#125;func (p PersonSlice) Less(i, j int) bool &#123; // 重写 Less() 方法， 从大到小排序 return p[j].Age &lt; p[i].Age&#125;func main() &#123; people := []Person&#123; &#123;"zhang san", 12&#125;, &#123;"li si", 30&#125;, &#123;"wang wu", 52&#125;, &#123;"zhao liu", 26&#125;, &#125; fmt.Println(people) sort.Sort(PersonSlice(people)) // 按照 Age 的逆序排序 fmt.Println(people) sort.Sort(sort.Reverse(PersonSlice(people))) // 按照 Age 的升序排序 fmt.Println(people)&#125; 输出结果为： 123[&#123;zhang san 12&#125; &#123;li si 30&#125; &#123;wang wu 52&#125; &#123;zhao liu 26&#125;][&#123;wang wu 52&#125; &#123;li si 30&#125; &#123;zhao liu 26&#125; &#123;zhang san 12&#125;][&#123;zhang san 12&#125; &#123;zhao liu 26&#125; &#123;li si 30&#125; &#123;wang wu 52&#125;] strconv 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( "fmt" "strconv")func main() &#123; // 返回字符串表示的整数值 a, err := strconv.Atoi("68") if err != nil &#123; fmt.Println(err) &#125; fmt.Printf("%T, %d\n", a, a) // 将整数数值转化为字符串 b := strconv.Itoa(77) fmt.Printf("%T, %s\n", b, b) // 指定字符串表示整数值的进制，结果必须指定是能无溢出赋值的整数类型 c, err := strconv.ParseInt("010010", 2, 64) if err != nil &#123; fmt.Println(err) &#125; fmt.Printf("%T, %d\n", c, c) d, err := strconv.ParseInt("FF", 16, 64) if err != nil &#123; fmt.Println(err) &#125; fmt.Printf("%T, %d\n", d, d) // 解析一个表示浮点数的字符串并返回其值 e, err := strconv.ParseFloat("123.15", 64) if err != nil &#123; fmt.Println(err) &#125; fmt.Printf("%T, %f\n", e, e)&#125; 输出结果为： 12345int, 68string, 77int64, 18int64, 255float64, 123.150000 strings 12345678910111213141516171819202122232425262728293031package mainimport ( "fmt" "strings")var print = fmt.Printlnfunc main() &#123; print("Contains: ", strings.Contains("sliver", "li")) print("Count: ", strings.Count("sliver", "e")) print("HasPrefix: ", strings.HasPrefix("sliver", "sl")) print("HasSuffix: ", strings.HasSuffix("sliver", "er")) print("Index: ", strings.Index("sliver", "e")) print("LastIndex: ", strings.LastIndex("slivere", "e")) print("Join: ", strings.Join([]string&#123;"a", "b"&#125;, "-")) print("Repeat: ", strings.Repeat("a", 5)) print("Replace: ", strings.Replace("foo", "o", "0", -1)) print("Replace: ", strings.Replace("foo", "o", "0", 1)) print("Split: ", strings.Split("a-b-c-d-e", "-")) print("Fields: ", strings.Fields("a b c\nd\te")) print("ToLower: ", strings.ToLower("sliver")) print("ToUpper: ", strings.ToUpper("sliver")) print("Trim: ", strings.Trim("sliver", "sr")) print("TrimLeft: ", strings.TrimLeft("sliver", "sl")) print("TrimRight: ", strings.TrimRight("sliverrr", "r")) print("TrimSpace: ", strings.TrimSpace(" sliver ")) print("Len: ", len("hello")) print("Char:", "hello"[1])&#125; 输出结果为： 1234567891011121314151617181920Contains: trueCount: 1HasPrefix: trueHasSuffix: trueIndex: 4LastIndex: 6Join: a-bRepeat: aaaaaReplace: f00Replace: f0oSplit: [a b c d e]Fields: [a b c d e]ToLower: sliverToUpper: SLIVERTrim: liveTrimLeft: iverTrimRight: sliveTrimSpace: sliverLen: 5Char: 101]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIL in Python]]></title>
    <url>%2F2018%2F04%2F01%2FGIL-in-Python%2F</url>
    <content type="text"><![CDATA[“有人说，Python 的多线程是鸡肋。” 多线程继承自上次的进程和线程，这次来说说 Python 中的多线程。 先附上一个多线程爬虫。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import osimport threadingfrom hashlib import md5from functools import partialfrom multiprocessing import Poolimport requestsfrom bs4 import BeautifulSoupbs = partial(BeautifulSoup, features='lxml')headers = &#123; "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"&#125;def spider(html): divs = bs(html).select("div[class='pic']") for div in divs: a = div.find_all('a')[0] img = div.find_all('img')[0] yield &#123;'link': a['href'], 'image': img['src']&#125;def download(link): try: html = requests.get(link, headers=headers).text except: print('Connection failed') return False div = bs(html).select("div[id='picture']")[0] images = div.select('img') for i, image in enumerate(images): source = image['src'] try: src = requests.get(source, headers=headers).content except: print('Spider &#123;&#125; failed.'.format(i)) return False name = md5(source.encode('utf8')).hexdigest() with open('source/&#123;&#125;.jpg'.format(name), 'wb') as f: f.write(src) print('&#123;&#125;.jpg download successfully!'.format(name))def main(): try: html = requests.get('http://www.meizitu.com/a/sexy.html', headers=headers).text except: print('Connection failed!') else: if not os.path.exists('source'): os.mkdir('source') for letter in spider(html): link = letter['link'] thread = threading.Thread(target=download, args=(link, )) thread.start()if __name__ == '__main__': main() 我们都知道，CPU 很快，很多时候，都是 CPU 在等待我们、等待程序的运行结束。 往往一个程序的运行都会开启一个进程，但在一定时间内，CPU 只能执行一个进程，一个进程在这个时刻可以进入 CPU 的临界区，访问 CPU 提供的资源。但 CPU 很快，I/O 操作很慢，如果一个进程只有一个线程，并且 I/O 操作是在一次计算并输出的结果的操作之前的，这个时候，势必要等待很慢的 I/O 操作先执行完，才能再执行之后的计算操作。假如这个结果是要让用户看的，用户要等到 I/O 操作完毕才能查看结果，这是很让人不耐烦的。 多线程可以把占据长时间的进程中的任务放到后台去处理，将更简单快速的线程先执行。所以，在一些等待的任务实现上：如用户输入、文件读写和网络收发数据等，多线程就比较有用了。CPU 通过线程调度算法，频繁的进行线程切换，当正在执行的一个线程需要进行 I/O 操作或者需要访问内存的时候，CPU 可以先放置这个线程，转而调度进程队列上的其他线程，被放置的线程处于阻塞状态，等待其 I/O 操作或者访问内存操作结束后，该线程就重新回到进 CPU 的怀抱。因此，通过多线程我们可以释放一些珍贵的资源，比如内存占用资源等。 当然，多进程也是可以的，但是线程和进程相比，要轻量一些，CPU 的进程调度算法，较线程调度算法，要慢一些。 想一想，有一个多核 CPU，如4核 CPU，一个核同一时间只能运行一个进程，一个进程可以运行多个线程，但一次也只能运行一个线程。不过因为是多核 CPU，（理论上）可以在多个核上运行同一个进程的多个线程，这样就实现了多个线程的并行。多核 CPU 的存在，提高了同一进程执行多个任务的效率。 这么厉害的多线程，Python 当然是支持的，但它能发挥多核 CPU 的优势，同时执行多个线程吗？ 答案是不行的，因为 GIL 的存在。 GIL什么是 GIL？GIL 的全称是 Global Interpreter Lock(全局解释器锁)，来源是 Python 设计之初的考虑，为了数据安全所做的决定。 Python 多线程如何执行？在 Python 中，一个线程的执行需要经过一下步骤： 获取 GIL。 执行代码直到 sleep 或者是 Python 虚拟机将其挂起。 释放 GIL。 可见，某个线程想要执行，必须先拿到 GIL，我们可以把 GIL 看作是执行某个线程必需的令牌，只有拿到这个令牌的线程才能被 Python 解释器执行，并且在一个 Python 进程中，GIL只有一个。拿不到 GIL 的线程，就不允许进入 CPU 执行。 所以，就算你是100核 CPU，一个 Python 进程，同时也只能运行一个线程。可以得出，在多核 CPU 中，Python 多线程的效率并不高。 GIL 的触发与释放在 Python3.X中，GIL 使用计时器（执行时间达到阈值后，当前线程释放 GIL，其它线程相互竞争获取 GIL）触发与释放。 有些人会说 Python 的多线程是鸡肋，其实并不是这样。常规的程序代码，可以分为两种： CPU 密集型，如各种循环、计数运算等。在这种情况下，由于计算工作多，计时器很快就会达到阈值，然后触发 GIL 的释放与再竞争（多个线程来回切换是需要消耗资源的），所以 Python 下的多线程对 CPU 密集型代码并不友好。 I/O 密集型，如文件处理、网络爬虫等。多线程能够有效提升效率（单线程下有 I/O 操作会进行 I/O 等待，造成不必要的时间浪费并且占用 CPU，而开启多线程能在某个线程等待时，自动切换到另外一个线程，可以不浪费宝贵的 CPU 资源，从而提升程序执行效率)。所以 Python 的多线程对 I/O 密集型代码比较友好。 多进程Python 下使用多进程可以充分发挥多核 CPU 的优势，因为每个 Python 进程有各自独立的 GIL，可以保证互不干扰，也就真正意义上实现了程序的并行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import osimport threadingfrom hashlib import md5from functools import partialfrom multiprocessing import Poolimport requestsfrom bs4 import BeautifulSoupbs = partial(BeautifulSoup, features='lxml')headers = &#123; "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"&#125;def spider(html): divs = bs(html).select("div[class='pic']") for div in divs: a = div.find_all('a')[0] img = div.find_all('img')[0] yield &#123;'link': a['href'], 'image': img['src']&#125;def download(link): try: html = requests.get(link, headers=headers).text except: print('Connection failed') return False div = bs(html).select("div[id='picture']")[0] images = div.select('img') for i, image in enumerate(images): source = image['src'] try: src = requests.get(source, headers=headers).content except: print('Spider &#123;&#125; failed.'.format(i)) return False name = md5(source.encode('utf8')).hexdigest() with open('source/&#123;&#125;.jpg'.format(name), 'wb') as f: f.write(src) print('&#123;&#125;.jpg download successfully!'.format(name))def main(): try: html = requests.get('http://www.meizitu.com/a/sexy.html', headers=headers).text except: print('Connection failed!') else: if not os.path.exists('source'): os.mkdir('source') pool = Pool() pool.map(download, [letter['link'] for letter in spider(html)])if __name__ == '__main__': main() 对以上爬虫改为多进程实现，因为主要进行的是图片读写的操作，所以两种版本运行下来，感觉多线程的更快一点。因为多进程来回切换需要的时间也很多，对文件读取这样 I/O 操作，使用多线程会更舒服些。 总结个人觉得 Python 的多线程也不是鸡肋，只要找到适合使用的情形，多线程也还是有用武之地的。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和线程]]></title>
    <url>%2F2018%2F04%2F01%2F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[“进程，线程，傻傻分不清楚。” 操作系统在说进程之前，应该先说一下操作系统。 在计算机发明之前，人们处理大量的数学计算问题是通过人工处理的，耗费大量的人力和成本，并且避免不了错误的发生。为了处理大量的数学计算问题，人们发明了计算机。最初的计算机只能接受一些特定的指令，用户输入一个指令，计算机就做出一个操作。当用户在思考或者输入时，计算机就处于等待状态。显然这样做的结果是效率低下，毕竟在很多时候，计算机都处于等待状态。 批处理系统那么能不能把一系列需要操作的指令写下来，形成一个清单，一次性交给计算机，然后计算机通过不断得读取指令进行相应的操作？ 当然可以。 所以，批处理操作系统诞生了。用户将多个需要执行的程序写在磁带上，然后交由计算机去读取并逐个执行这些程序，并将输出结果写在另一个磁带上。 虽然批处理操作系统的诞生提高了任务处理的便捷性，但是仍然存在一个很大的问题： 假如有两个任务 A 和 B，需要读取大量的数据输入（I/O操作），而其实 CPU 只能处在等待状态，等任务 A 读取完数据再能继续进行，这样就白白浪费了 CPU 资源。于是人们就想，能否在任务 A 读取数据的过程中，让任务 B 去执行，当任务A读取完数据之后，暂停任务 B，让任务 A 继续执行？ 这时候又出现了几个问题：内存中始终都只有一个程序在运行，而想要解决上述问题，必然要在内存中装入多个程序，如何处理呢？多个程序使用的数据如何辨别？当一个程序暂停后，随后怎么恢复到它之前执行的状态呢？ 进程的发明这时候，人们就发明了进程，用进程来对应一个程序，每个进程来对应一定的内存地址空间，并且只能使用它自己的内存空间，各个进程之间互不干扰。进程同时也保存了程序每个时刻的运行状态，为进程切换提供了可能。当进程暂停时，它会保存当前进程的状态（进程标识，进程使用的资源等），在下一次切换回来时根据之前保存的状态进行恢复，接着继续执行。 并发并发是能够让操作系统从宏观上看起来在同一时间段执行了多个任务。换句话说，进程让操作系统的并发成为了可能。 虽然并发从宏观上看有多个任务在执行，但在事实上，对于单核 CPU 来说，任意具体时刻都只有一个任务在占用 CPU 资源。 竞争资源众所周知，各种各样的资源，都是有限的、稀缺的。对计算机资源来说，也是这样。进程是 CPU 资源的分配和调度的一个独立单元，简单来说，各种不同的进程，它们需要竞争计算机的资源。 对单核 CPU 来说，同一时间，只能运行一个进程，这是无法改变的事实。用户在使用个人 PC 时，会觉得很多应用程序都是并行的，看起来好像是这样，然而实际是 CPU 每隔一定的时钟周期，会把相关资源对某个进程开放（只允许一个进程在同一时间访问），一段时间后，各个进程都能拥有获得 CPU 资源的能力，也就完成了宏观上的并行。 所以，只有多核 CPU 才能完成真正的并行。 线程的引入出现了进程之后，操作系统的性能得到了大大的提升。虽然进程的出现解决了操作系统的并发问题，但是人们不满足，逐渐对实时性有了要求。因为一个进程在一个时间段内只能做一个事情，如果一个进程有多个子任务时，只能逐个得执行这些子任务，很影响效率。 Example: 对于监控系统这个进程来说：不仅要与服务器端进行通信获取图像数据并将图像信息显示在画面上，还要处理与用户的交互操作。如果在一个时刻该系统正在与服务器通信获取图像数据，而用户在监控系统上点击了一个按钮，那么系统只能等获取完图像后才能与用户进行交互操作。如果获取图像需要10s，用户就得等待10s。显然这样的系统，无法满足人们的需求。 线程那么能不能将这些子任务分开执行呢？即某个时刻系统正在与服务器通信获取图像数据，同时，一个用户在监控系统上点击了一个按钮，那么系统可以先暂停获取图像的操作，先与用户进行交互操作（用户操作一般执行时间很短），然后再继续获取图像。 为了处理这种情况，人们发明了线程，让一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务。在用户点击按钮的时候，可以暂停获取图像数据的线程，让出 CPU 资源，让线程获取这个进程的资源，响应用户的操作，响应完后再切换回来，获取图像数据的线程重新获取进程所拥有的资源。让用户感觉系统在同时做很多事，满足用户对实时性的要求。 所以，一个进程在一定时间得到的，是 CPU 对它的资源倾斜，这对一个进程来说，粒度有些太大了。而线程相当于更加轻量的进程，粒度更小，实现了进程内部的并发。同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文等），一个进程至少包括一个线程，线程是 CPU 调度执行的基本单位。 进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能。 进程和线程区别一个进程是一个独立（self contained）的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。 最大的区别是：是否单独占有内存地址空间（共享，同步，可靠性，开销） 进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。 进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。 进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。 再次概括一下：进程是操作系统进行资源分配的基本单位（进程之间互不干扰），而线程是操作系统进行调度的基本单位（线程间互相切换）。 多进程和多线程那么，上面举例的监控系统为什么要用一个进程实现（多线程）而不是多进程实现呢？ 答：多进程也可以实现，但是进程间通信没有线程间通信简单，一个进程提供的多线程环境，方便各个线程共享资源。 总而言之，进程可靠性高但是开销大，线程开销小但是可靠性低。根据不同情况选择不同模型。在需要并发处理并且需要共享一些变量的情况下，选择多线程。其他情况下，进程健壮性更好。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python密码学不完全指北（现代密码）]]></title>
    <url>%2F2018%2F03%2F31%2FPython%E5%AF%86%E7%A0%81%E5%AD%A62%2F</url>
    <content type="text"><![CDATA[“今天来说说流密码。” 学校关于密码学的课已经教到了序列密码和分组密码了，这里应该吐槽一下老教授出的书真的很烂，密码学这么好玩的课还是适合自学啊… 序列密码 序列密码也称为流密码（Stream Cipher），它是对称密码算法的一种。序列密码具有实现简单、便于硬件实施、加解密处理速度快、没有或只有有限的错误传播等特点，因此在实际应用中，特别是专用或机密机构中保持着优势，典型的应用领域包括无线通信、外交通信。 1949年 Shannon 证明了只有一次一密的密码体制是绝对安全的，这给序列密码技术的研究以强大的支持，序列密码方案的发展是模仿一次一密系统的尝试，或者说“一次一密”的密码方案是序列密码的雏形。如果序列密码所使用的是真正随机方式的、与消息流长度相同的密钥流，则此时的序列密码就是一次一密的密码体制。若能以一种方式产生一随机序列（密钥流），这一序列由密钥所确定，则利用这样的序列就可以进行加密，即将密钥、明文表示成连续的符号或二进制，对应地进行加密，加解密时一次处理明文中的一个或几个比特。 序列密码类似一次一密，不同的是“一次一密”使用的是真正的随机数流，而序列密码使用的是伪随机数流。真正的随机数流有很多的局限性，比如它要和需要加密的明文信息一样长，还要保证真随机数流的绝对保密，但是，既然能保证和明文一样长度的真随机数流绝对保密了，为什么还要对明文进行加密呢？这是矛盾的。虽然一次一密是绝对安全的，但它也是不切实际的，序列密码则更加符合实际。它的加密算法可以公开，但密钥可以通过 RSA 等公钥密码建立可靠信道来传输，因为密钥不是很长，所以对加密效率稍微低的 RSA 来说，传输是很快的。 设计序列密码的主要考虑因素： 加密序列的周期要长，若出现重复的周期过短，容易被爆破。 密钥流应该尽可能地接近真正随机数流的特征。 密钥长度要长，以避免穷举攻击。 关于线性反馈移位寄存器就不多说了，看深入浅出密码学即可。 分组密码 分组密码是将明文消息编码表示后的数字（简称明文数字）序列，划分成长度为 n 的组（可看成长度为 n 的矢量），每组分别在密钥的控制下变换成等长的输出数字（简称密文数字）序列。 简而言之，分组密码就是将明文分成一个一个组，然后分别使用密钥对每个组进行加密。 DES DES 全称为 Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。需要注意的是，在某些文献中，作为算法的 DES 称为数据加密算法（Data Encryption Algorithm,DEA），已与作为标准的 DES 区分开来。 DES 算是比较经典的分组加密算法了，它以64位为分组对数据加密，加密和解密用的是同一个算法。密钥长度也为64位，但实际上只有56位参与 DES 的运算（第8、16、24、32、40、48、56、64位是校验位，使得每个密钥都有奇数个1），分组后的明文组和56位的密钥按位替代或交换的方法形成密文组。 关于加密流程，在看雪看到了一个很好的总结：DES加密算法图解。 上图中还要加上对64位明文的初始 IP 置换，这里再附上书上的加密流程： 两张结合起来，对 DES 会有更加清晰的了解。 初始 IP 置换初始 IP 置换的目的是将输入的64位分组按位重新组合，并把输出分为Li、Ri两部分，每部分各长32位。 58 50 42 34 26 18 10 2 60 52 44 36 28 20 12 4 62 54 46 38 30 22 14 6 64 56 48 40 32 24 16 8 57 49 41 33 25 17 9 1 59 51 43 35 27 19 11 3 61 53 45 37 29 21 13 5 63 55 47 39 31 23 15 7 表中的数字代表新分组的第1位放原分组的第58位，第2位放到第50位…依此类推，新分组第64位放原分组的第7位的数据。置换后的数据分为 Li 和 Ri 两部分，Li 为新数据的左32位，Ri 为新数据的右32位。 扩展置换 E这个置换将 Ri 的由32位拓展成48位，以便之后与轮密钥进行异或操作。 32 1 2 3 4 5 4 5 6 7 8 9 8 9 10 11 12 13 12 13 14 15 16 17 16 17 18 19 20 21 20 21 22 23 24 25 24 25 26 27 28 29 28 29 30 31 32 1 密钥调度1234567891011121314151617PC_1 = [57, 49, 41, 33, 25, 17, 09, 01, 58, 50, 42, 34, 26, 18, 10, 02, 59, 51, 43, 35, 27, 19, 11, 03, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 07, 62, 54, 46, 38, 30, 22, 14, 06, 61, 53, 45, 37, 29, 21, 13, 05, 28, 20, 12, 04]PC_2 = [14, 17, 11, 24, 01, 05, 03, 28, 15, 06, 21, 10, 23, 19, 12, 04, 26, 08, 16, 07, 27, 20, 13, 02, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32] 密钥调度算法是将一开始给定的主密钥进行一定变换，生成16个48位的轮密钥。 首先经过 PC-1 变换，不考虑主密钥每个字节的第8位，将 DES 的密钥由64位减至56位，每个字节的第8位作为奇偶校验位。 接下来将得到的56位的密钥分成两部分，每部分为28位。 根据所在的轮数所要求的左移次数，对所给两部分密钥进行左移操作后合并为56位密钥。 上一步结束后，经过 PC-2 变换，将56位密钥压缩为48位，返回生成的轮密钥。 重复十六轮，完成所有的轮密钥生成。 轮数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 次数 1 1 2 2 2 2 2 2 1 2 2 2 2 2 2 1 S-盒替换12345678910111213141516171819202122232425262728293031323334353637383940414243# 构建8个S-盒模型S1 = [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7], [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8], [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0], [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]]S2 = [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10], [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5], [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15], [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]]S3 = [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8], [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1], [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7], [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]]S4 = [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15], [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9], [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4], [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]]S5 = [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9], [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6], [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14], [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]]S6 = [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11], [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8], [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6], [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]]S7 = [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1], [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6], [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2], [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]]S8 = [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7], [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2], [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8], [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]# S-盒S = [S1, S2, S3, S4, S5, S6, S7, S8] 密钥调度生成的当前48位轮密钥与经过扩展置换 E 后的 Ri 异或以后就会得到48位数据，将这个48位数据送入 S-盒 中，进行替代运算。 替代运算由8个不同的 S 盒完成，每个 S-盒 有6位输入4位输出。48位输入数据将分为8个6位的分组，一个分组对应一个 S 盒，对应的 S 盒对各小组进行替代操作。 例如，假设 S盒-8 的输入为110011，第1位和第6位组合为11，对应于 S盒-8 的第3行；第2位到第5位为1001，对应于 S盒-8 的第9列。S盒-8 的第3行第9列的数字为12，因此用12的二进制表示1100来代替110011。要注意的是，S-盒 的行列计数都是从0开始的。 P-盒置换S-盒 代替运算的32位输出按照 P-盒 进行置换。 1234P = [16, 07, 20, 21, 29, 12, 28, 17, 01, 15, 23, 26, 05, 18, 31, 10, 02, 08, 24, 14, 32, 27, 03, 09, 19, 13, 30, 06, 22, 11, 04, 25] 在最后，P-盒 置换的结果与最初的64位分组左半部分32位 Li 异或，然后产生一个新的分组（左32位为最初的 Ri，右32位为 P-盒 与最初的 Li 异或的结果），接着开始新的一轮。 IP-1 逆置换经过以上十六轮的变换后，最终迎来了最后的 IP-1 逆置换。 40 8 48 16 56 24 64 32 39 7 47 15 55 23 63 31 38 6 46 14 54 22 62 30 37 5 45 13 53 21 61 29 36 4 44 12 52 20 60 28 35 3 43 11 51 19 59 27 34 2 42 10 50 18 58 26 33 1 41 9 49 17 57 25 以上十六轮最后得到的64位结果，要先将左右32位两部分交换后再进行 IP-1 逆置换，才能得到密文。 Python 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256# -*- coding: UTF-8 -*-# operation.py__author__ = 'Sliver'__all__ = ['IpPermutation', 'InverseIpPermutation', 'CreateSubKeys', 'ExtendPermutation', 'SBoxPermutation', 'PBoxPermutation', 'xor', 'string2bin', 'bin2string']def IpPermutation(text): '''初始置换IP：将64位输入按 IP 规则置换后返回64位结果。''' IP = [58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7] return [text[IP[i] - 1] for i in range(64)]def InverseIpPermutation(text): '''逆初始置换IP^-1：将64位输入按 IP^-1 规则置换后返回64位结果。''' INVERSE_IP = [40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25] return [text[INVERSE_IP[i] - 1] for i in range(64)]def ExtendPermutation(text): '''扩展置换E：将32位输入按 E 规则置换后拓展为48位结果。''' E = [32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1] return [text[E[i] - 1] for i in range(48)]# 密钥调度所需的 PC-1 变换和 PC-2 变换PC_1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]PC_2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]def shift(text, movetimes): ''' 对给定的序列，左移指定次数，并返回移动后的序列。 如：[1, 2, 3, 4] &amp; movetimes = 1 -&gt; [2, 3, 4, 1]。 ''' return text[movetimes:] + text[:movetimes]def CreateSubKeys(primarykey): '''根据主密钥，生成十六个轮密钥。''' result = [] key56 = [primarykey[PC_1[i] - 1] for i in range(56)] MOVETIMES = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1] # 进行16轮子密钥生成 for i in range(16): # 每28位为一部分，分别进行循环左移 key28left = shift(key56[:28], MOVETIMES[i]) key28right = shift(key56[28:], MOVETIMES[i]) key56 = key28left + key28right # 对56位密钥进行 PC-2 变换，将其压缩为48位 key48 = [key56[PC_2[i] - 1] for i in range(48)] result.append(key48) return result# 构建8个S-盒模型S1 = [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7], [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8], [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0], [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]]S2 = [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10], [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5], [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15], [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]]S3 = [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8], [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1], [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7], [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]]S4 = [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15], [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9], [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4], [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]]S5 = [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9], [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6], [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14], [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]]S6 = [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11], [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8], [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6], [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]]S7 = [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1], [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6], [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2], [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]]S8 = [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7], [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2], [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8], [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]# S-盒S_BOX = [S1, S2, S3, S4, S5, S6, S7, S8]def dex2bin4(dex): ''' 将（不超过15的）十进制数转化成4位二进制字符串。 如：13 -&gt; '1101'。 ''' temp = bin(dex).replace('0b', '') length = len(temp) addzero = '0' * (4 - length) # 不足四位的在前面补0 return addzero + tempdef dex2bin8(dex): ''' 将十进制数转化成8位二进制字符串。 如：90 -&gt; '01011010' ''' temp = bin(dex).replace('0b', '') length = len(temp) addzero = '0' * (8 - length) # 不足四位的在前面补0 return addzero + tempdef SBoxPermutation(text): '''S-盒置换：将48位输入均分成长度为6的8个小组，每个小组按顺序进入相应的S盒各得到4位输出，返回合并后的32位结果。''' result = [] for i in range(0, 8): temp = text[i * 6:i * 6 + 6] row = int(str(temp[0]) + str(temp[-1]), 2) column = int(str(temp[1]) + str(temp[2]) + str(temp[3]) + str(temp[4]), 2) letter = S_BOX[i][row][column] result.append(dex2bin4(letter)) return [int(x) for x in ''.join(result)]def PBoxPermutation(text): '''P-盒置换：将32位输入按 P 规则置换后返回32位结果。''' P = [16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25] return [text[P[i] - 1] for i in range(32)]def xor(m, n): '''对两个序列进行各位异或操作，并返回所得结果。''' return [a ^ b for a, b in zip(m, n)]def char2bin(char): ''' 返回一个（ASCII）字符的8位二进制表示。 如：'A' -&gt; '01000001'。 ''' b = bin(ord(char)).replace('0b', '') space = 8 - len(b) return '0' * space + bdef string2bin(text): ''' 将含有8个字符的字符串转化成包含64位二进制数字的列表。 如：'ABCDEFGH' -&gt; [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0]。 ''' if len(text) != 8: return False temp = [char2bin(char) for char in text] return [int(number) for number in ''.join(temp)]def bin2string(text): ''' 将包含64位二进制数字的列表转化成含有8位字符的字符串。 如：[0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, -&gt; 'ABCDEFGH'。 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0] ''' if len(text) != 64: return False text = [str(number) for number in text] # 先将列表里的 int 类型转化为 str 类型 result = [] for i in range(8): binstring = ''.join(text[i * 8:i * 8 + 8]) result.append(chr(int(binstring, 2))) return ''.join(result)if __name__ == '__main__': print(dex2bin4(15)) print(dex2bin4(1)) print(shift([1, 2, 3, 4, 5], 2)) print(shift([1, 2, 3, 4, 5], 3)) print(char2bin('A')) print(char2bin('a')) print(string2bin('ABCDEFGH')) print(len(string2bin('ABCDEFGH'))) test = [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0] print(bin2string(test)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# -*- coding: UTF-8 -*-# DES.py__author__ = 'Sliver'from operation import IpPermutation, InverseIpPermutation, ExtendPermutation, \ CreateSubKeys, SBoxPermutation, PBoxPermutation, \ string2bin, bin2string, xordef cipher(message, key, mode='encrypt'): message = string2bin(message) key = string2bin(key) subkeys = CreateSubKeys(key) if mode == 'encrypt' else CreateSubKeys(key)[::-1] text = IpPermutation(message) for i in range(16): l, r = text[:32], text[32:] r_extend = ExtendPermutation(r) xor1 = xor(r_extend, subkeys[i]) s_box_result = SBoxPermutation(xor1) p_box_result = PBoxPermutation(s_box_result) xor2 = xor(l, p_box_result) text = r + xor2 text = text[32:] + text[:32] return bin2string(InverseIpPermutation(text))def fill(string): mod = len(string) % 8 space = 8 - mod return string + bytes([0 for _ in range(space)]).decode('utf-8')class DES: def __init__(self, message, key): self.message = message self.key = key @property def ciphertext(self): return self.__encrypt() @property def plaintext(self): return self.__decrypt() def __encrypt(self): output = [] length = len(self.message) times, mod = length // 8, length % 8 if mod: self.message = fill(self.message) times += 1 for i in range(times): result = cipher(self.message[i * 8:i * 8 + 8], self.key, 'encrypt') output.append(result) return ''.join(output) def __decrypt(self): output = [] length = len(self.message) times, mod = length // 8, length % 8 if not times: return None if mod: self.message = fill(self.message) length += 1 for i in range(times): result = cipher(self.message[i * 8:i * 8 + 8], self.key, 'decrypt') output.append(result) return ''.join(output).rstrip(b'\x00'.decode('utf-8'))if __name__ == '__main__': print(cipher('I LOVE Y', 'ABCDEFGH')) print(cipher(['¯', 'Ý', '\x0f', '\x90', '*', 'd', 'Ú', 'É'], 'ABCDEFGH', mode='decrypt')) cipher1 = DES('Sliver Love Ariel.', 'ABCDEFGH') print(cipher1.ciphertext) cipher2 = DES(cipher1.ciphertext, 'ABCDEFGH') print(cipher2.plaintext) 输出结果为： 1234¯Ý*dÚÉI LOVE Y³$ý»;N«Ì¥[æTÕõ·Þ2AîSliver Love Ariel. 加密时对明文没有数量要求，因为在加密过程中会进行填充操作，但是密钥一定要为8字节64位字符。代码没有对中文等字符进行相应加密操作，只能对英文等 ASCII 码编码的字符进行加解密操作。 附上 github 地址：https://github.com/SliverYou/DES-Cipher AES 高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称 Rijndael 加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于 FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。 在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。不同的密钥，它的加密轮数也是不一样的： AES 算法加密具体流程如下图： 在这里，只考虑密钥为128位时的 AES 加解密情况。 本来想继续写下去，不过看到了一篇特别详细具体的博客，就还是引个链接吧：https://blog.csdn.net/qq_28205153/article/details/55798628。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tips</tag>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络学习笔记]]></title>
    <url>%2F2018%2F03%2F21%2Fcomputer-networking-01%2F</url>
    <content type="text"><![CDATA[“好好学习，天天向上。” 计算机网络和因特网描述 具体组成描述因特网 因特网是一个世界范围的计算机网络，即它是一个互联了遍及全世界的数以亿计的计算机设备的网络。 所有与因特网相连的设备被称作主机（host）或者端系统（end system）。 端系统 端系统通过通信链路（communication link）和分组交换机（packet switch）连接到一起。 链路的传输速率以 bit/s 或者 bps 度量。 当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包用计算机网络的术语来说称为分组（packet）。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。 分组交换机 分组交换机从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。 两种最著名的分组交换机是路由器（router）和链路层交换机（link-layer switch）。这两种类型的交换机朝着最终目的地转发分组。 链路层交换机通常用于接人网中，而路由器通常用于网络核心中。 从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径（route 或 path）。 因特网服务提供商 端系统通过因特网服务提供商（Internet Service Provider，ISP）接入因特网。 每个 ISP 是一个由多个分组交换机和多段通信链路组成的网络。它们为端系统提供不同类型的网络接入，也为内容提供者提供因特网接入服务。 因特网就是将端系统彼此互联，因此为端系统提供接入的 ISP 也必须互联。（底层 ISP 通过高层 ISP 互联起来、各个 ISP 独立管理并各自运行着 IP 协议。） 协议 各个因特网部件都要运行一系列协议 protocol，这些协议控制着因特网中信息的接收与发送。 TCP 和 IP 是因特网中两个最重要的协议，统称为 TCP/IP。（Transmission Control Protocal，传输控制协议；Internet Protocal，网络协议） IP 协议定义了在路由器和端系统之间发送和接收的分组格式。 IETF 和 RFC 为了方便网络资源的共享，就需要在各个 ISP 中建立一个统一的标准，现在的因特网标准（Internet standard）由因特网工程任务组（Internet Engineering Task Force，IETF）研发。 IETF 的标准文档称为请求评论（Request For Comment，RFC），该文档技术性很强，并且相当详细。RFC 文档定义了 TCP、IP、HTTP 和 SMTP 等协议，目前已经有将近6000多个 RFC。 服务描述描述因特网大致有两个角度，一个是从具体组成部件来描述，另一个是从为应用程序特供的服务基础设施的角度即使用因特网的应用程序来描述。 应用程序 电子邮件、Web 冲浪、即时讯息、社交网络、IP 语音（VoIP）、流式视频、分布式游戏、对等（peer-to-peer，P2P）文件共享、因特网电视、远程注册等。这些应用程序成为分布式应用程序（distributed application），因为它们设计多台相互交换数据的端系统。 因特网应用程序运行在端系统上，即它们并不运行在网络核心中的分组交换机中。尽管分组交互机促进端系统之间的数据交换，但它们并不关心作为数据的源或宿的应用程序。 应用程序编程接口 与因特网相连的端系统提供了因特网应用程序编程接口（Application Programming Interface，API），该 API 规定了运行在一个端系统上的软件请求因特网基础设施向运行在另一个端系统上的特定目的软件交付数据的方式。 因特网 API 是一套发送软件必须遵循的规则集合，因此因特网能够将数据交付给目的地。 什么是协议？协议可以理解为一系列约定俗成的动作，就像人类活动中“问时间”这个行为需要遵循一定的规则一样，甲方问“几点了”，乙方得到请求，会答复现在几点钟；如果甲方问乙方今天天气怎么样，他一定不会返回现在是几点钟，而是今天天气怎么样；如果甲方用乙方听不懂的方言来询问乙方，那乙方可能会毫无反应，因为他听不懂。所以，协议具有一定的规则，需要双方去遵守。放在计算机网络中，互相通信的两个端系统不具有人类拥有的察言观色的能力，它只会对请求采取相应的回应。通信双方之间报文的接收和发送所采取的动作、报文的格式与次序同样需要由协议加以约束。所以，可以得到两个结论： 在因特网中，凡是涉及两个或多个远程通信实体的所有活动都受协议的制约。 一个协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和/或接收一条报文或其他事件所采取的动作。 网络边缘 通常把与因特网相连的计算机和其他设备称为端系统。因为它们位于网络边缘（The Network Edge），故而称为端系统。 端系统也称为主机，因为它们可以运行应用程序，即 主机 = 端系统。主机有时候又可以进一步划分为两类：客户端（slient）和服务器（server）。客户端非正式地等同于桌面 PC、智能手机等。服务器非正式地等同于更为强大的机器，拥有存储 Web 页面、流视频等。 多个服务器聚集在一起，就形成了数据中心（data center），它们共同协作，可以更好地为客户端提供服务。 接入网接入网（acess network），这里是指将端系统连接到其边缘路由器（edge router）的物理链路。边缘路由器是端系统到任何其他远程端系统路径上的第一台路由器。 家庭接入宽带住宅接入有两种最流行的类型：数字用户线（Digital Subscriber Line，DSL）和电缆（cable）。 DSL DSL：住户从本地电话公司处获得 DSL 因特网接入，所以 ISP 是本地电话公司。 数字用户线同时承载了数据和传统的电话信号，它们编码为不同的频率： 高速下行信道，位于 50kHz 到 1MHz 频段; 中速上行信道，位于 4kHz 到 50kHz 频段; 普通的双向电话信道，位于 0 到 4kHz 频段。 这种方法使单根 DSL 线路看起来就像有3根单独的线路，因此一个电话呼叫和一个因特网连接能够同时共享DSL 链路（频分复用技术）。在用户一侧，一个分频器把到达家庭的数据信号和电话信号分隔开来，并将数据信号转发给 DSL 调制解调器。在本地电话公司一侧，在本地中心局中，DSLAM（用户线接入复用器）把数据和电话信号分隔开，并将数据送往因特网中。数百甚至上千个家庭与同一个 DSLAM 相连。同时，DSL 标准定义了 12Mbps 下行和 1.8Mbps 上行传输速率。 电缆 电缆因特网接入（cable Internet acess）：住户从特供有限电视的公司获得了电缆因特网接入，所以 ISP 是本地电视公司。 光缆将电缆头端连接到地区枢纽，从这里使用传统的同轴电缆到达各家各户和公寓。每个地区枢纽通常支持500~5000个家庭。因为这个系统中应用了光纤和同轴电缆，所以它经常被称为混合光纤同轴（Hybrid Fiber Coax，HFC）。 电缆因特网接人需要特殊的调制解调器，称为电缆调制解调器（cable modem）。 电缆调制解调器通常是一个外部设备，通过一个以太网端口连接到家庭 PC。 在电缆头端，电缆调制解调器端接系统（Cable Modem Termination System，CMTS）起到如同 DSL 网络的 DSLAM 类似的功能，即将来自许多下行家庭中的电缆调制解调器发送的模拟信号转换回数字形式。 电缆调制解调器将 HFC 网络划分为下行和上行两个信道，并且接人通常是不对称的。它拥有高达 42.8 Mbps 的下行速率和高达 30.7 Mbps 的上行速率。 电缆因特网接入的一个重要特征是共享广播媒体，即共享上行和下行两个信道。 FTTH 光纤到户（Fiber To The Home，FTTH）：从本地中心局直接到家庭特供了一条光纤路径。 光纤分布方案： 最简单的光纤分布网络称为直接光纤，从本地中心局到每户设置一根光纤。 更为一般的是，从中心局出来的每根光纤实际上由许多家庭共享，直到相对接近这些家庭的位置，该光纤才分成每户一根光纤。 光纤分布体系结构: 主动光纤网络（Active Optical Network，AON）。 被动光纤网络（Passive Optical Network，PON）。 AON 基本上就是交换因特网，PON 利用分布方案2，将多个家庭集结在一个光纤分配器控制的共享光纤上，并将发送到分配器的分组在分配器处复制，再统一发送到本地电话和公司中心局中的光纤链路端接器（Optical Line Terminator，OLT）。 FTTH 有潜力提供每秒千兆比特范围的因特网接入速率。 拨号和卫星在一些不发达的地方，如乡村环境，能够使用卫星链路以超过 1Mbps 的速率与因特网相连。也可使用传统电话线的拨号来进行连接，只是它的速率只有 56kbps。 企业（和家庭）接入 在公司和大学校园以及在越来越多的家庭环境中，通常是用局域网（LAN）将端用户连接到边缘路由器。而以太网到目前为止是当前公司、大学和家庭网络中最为流行的接入技术。 使用以太网接入，用户通常以 100Mbps 速率接入以太网交换机，而服务器可能具有 1Gbps 甚至 10Gbps 的接入速率。 一个无线 LAN 用户通常必须位于接入点的几十米范围内。 基于 IEEE 802.11 技术的无线 LAN 接入，更为通俗得称为 WiFi，目前几乎无所不在。 广域无线网接入：3G 和 LTE iPhone、黑莓和安卓等设备越来越多地用来在移动中发送邮件、Web 冲浪、推特和下载音乐。这些设备应用了与移动电话相同的基础设施，通过蜂窝网提供商运营的基站来发送接收分组。与 WiFi 不同的是，一个用户仅需要位于基站的数万米（而不是几十米）范围内，即可接入互联网。 电信公司已经在所谓第三代（3G）无线技术中进行了大量投资，3G 为分组交换广域无线因特网接人提供了超过 1Mbps 的速率。甚至更高速率的广域接人技术及第四代（4G）广域无线网络已经在部署中。 LTE（Long-Term Evolution）来源于 3G 技术，它能够取得超过 10Mbps 的速率。 物理媒体从一个端系统到另一个端系统，一个比特需要不断的传输和接收，在这过程中，需要跨越一种物理媒体来传播该比特。 物理媒体分为两类 导引型媒体 非导引型媒体 具体物理媒体： 双绞铜线：目前局域网中的双绞线的数据速率从 10Mbps 到 10Gbps 不等。 同轴电缆：提供数十 Mbps 速率的因特网接入。 光纤：传输速率高达数十甚至数百 Gbps 的传输速率。 陆地无线电信道：不需要安装物理线路，具有穿墙、长距离通信的能力。 卫星无线电信道：能以数百 Mbps 速率运行在某些无法使用 DSL 或电缆因特网接入的区域。 网络核心网络核心，即由互联网端系统的分组交换机和链路构成的网状网络。 分组交换 为了将源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称之为分组（packet）。 每个分组都通过通信链路和分组交换机进行传送。 分组以等于该链路最大速率的速度传输通过通信链路。 存储转发传输 多数分组交换机在链路的输入端使用存储创房传输（store-and-forward transmission）机制。 存储转发机制是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。 一个长度为 L 比特的分组，链路的传输速率为 R 比特/秒，则从源端系统到目的端系统，这个分组经过一个分组交换机传输的时间为 2 * L / R 秒。经过 n - 1 个分组交换机（n 条链路），则传输时间为 n * L / R 秒。 这里可以看一道题： Equation 1.1 gives a formula for the end-to-end delay of sending one packet of length L over N links of transmission rate R. Generalize this formula for sending P such packets back-to-back over the N links. 答案： At time N*(L/R) the first packet has reached the destination, the second packet is stored in the last router, the third packet is stored in the next-to-last router, etc. At time N*(L/R) + L/R, the second packet has reached the destination, the third packet is stored in the last router, etc. Continuing with this logic, we see that at time N*(L/R) + (P-1)*(L/R) = (N+P-1)*(L/R) all packets have reached the destination. 弄明白后，可以加深对分组交换的存储转发机制的理解。 排队时延和分组丢失每个分组交换机有许多链路与之相连。对于每条相连的链路，该分组交换机具有一个输出缓存（output buffer；也称为输出队列，output queue）。它用于存储路由器准备发送至链路的分组。当所需要发送的分组很多时，不免会发生等待现象，需要等待的分组将会在输出缓存中等待，这就是排队时延。如果输出缓存被巨大的排队分组填满了，因为缓存容量有限，在这个情况下，已经塞不进去任何分组了，这样就会出现分组丢失，也就是丢包现象（packet lost），到达的分组或已经排队的分组之一将会被丢弃。 转发表和路由选择协议路由器从与它相连的一条通信链路得到分组，将其向与它相连的另一条通信链路转发。但是该路由器怎样决定它应当向哪条链路进行转发呢？ 在因特网中，每个端系统具有一个称为 IP 地址的地址。当源主机要向目的端系统发送一个分组时，源在该分组的首部包含了目的地的 IP 地址。如同邮政地址那样，该地址具有一种等级结构。当一个分组到达网络中的路由器时，路由器检查该分组的目的地址的一部分，并向一台相邻路由器转发该分组。更特别的是，每台路由器具有一个转发表（forwarding table），用于将目的地址（或目的地址的一部分）映射成为输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发现适当的出链路。路由器则将分组导向该出链路。并且，因特网具有一些特殊的路由选择协议（routing protocol），用于自动地设置这些转发表。 可以使用 traceroute 命令查看端到端路由： 电路交换在电路交换（circuit switching）网络中，在端系统间通信会话期间，预留了端系统间通信沿路径所需要的资源（缓存，链路传输速率）。在分组交换（packet switching）网络中，这些资源则不是预留的；会话的报文按需使用这些资源，其后果可能是不得不等待（即排队）接入通信线路。 电路交换相当于必须提前预约好的餐馆，成功后到达餐厅即可直接点菜吃饭；分组交换相当于无需预约的餐馆，但可能有排队才能吃上饭的时候。 进行电路交换时，需先建立一条称为电路的端到端连接（end-to-end connection），在连接期间，网络会预留恒定的传输速率，即为发送方和接收方预留了带宽，以确保发送方能以恒定速率向接收方发送数据。 预留四条电路时，进行一次连接只能使用正常带宽的四分之一，这既是优点，也是弊端。 电路交换网络中的复用 FDM 频分复用（FDM，Frequency Division Multiplexing）就是将用于传输信道的总带宽划分成若干个子频带（或称子信道），每一个子信道传输一路信号。频分复用要求总频率宽度大于各个子信道频率之和，同时为了保证各子信道中所传输的信号互不干扰，应在各子信道之间设立隔离带，这样就保证了各路信号互不干扰（条件之一）。频分复用技术的特点是所有子信道传输的信号以并行的方式工作，每一路信号传输时可不考虑传输时延，因而频分复用技术取得了非常广泛的应用。频分复用技术除传统意义上的频分复用（FDM）外，还有一种是正交频分复用（OFDM）。 TDM 时分复用（TDM，Time Division Multiplexing）就是将提供给整个信道传输信息的时间划分成若干时间片（简称时隙），并将这些时隙分配给每一个信号源使用，每一路信号在自己的时隙内独占信道进行数据传输。时分复用技术的特点是时隙事先规划分配好且固定不变，所以有时也叫同步时分复用。其优点是时隙分配固定，便于调节控制，适于数字信息的传输；缺点是当某信号源没有数据传输时，它所对应的信道会出现空闲，而其他繁忙的信道无法占用这个空闲的信道，因此会降低线路的利用率。时分复用技术与频分复用技术一样，有着非常广泛的应用，电话就是其中最经典的例子，此外时分复用技术在广电也同样取得了广泛地应用，如 SDH，ATM，IP 和 HFC 网络中 CM 与 CMTS 的通信都是利用了时分复用的技术。 对于 FDM，每条链路连续地得到部分带宽。对于 TDM，每条电路在短时间间隔（即时隙）中周期性的得到所有带宽。 结论分组交换的批评者经常争辩说，分组交换不适合实时服务（例如，电话和视频会议），因为它的端到端时延是可变的和不可预测的（主要是因为排队时延的变动和不可预测所致）。分组交换的支持者却争辩道：①它提供了比电路交换更好的带宽共享；②它比电路交换更简单，更有效，实现成本更低。概括而言，嫌餐馆预订麻烦的人宁可要分组交换而不愿意要电路交换。 总而言之： 电路交换不考虑需求，而预先分配了传输链路的使用，这使得已分配而并不需要的链路时间未被利用；分组交换按需分配链路使用。链路传输能力将在所有用户之间逐分组地被共享，这些用户有分组需要在链路上传输。 网络的网络因特网是一个网络的网络，它是由数以亿计的用户构成的。而要想保证用户之间的连接，接入的 ISP 自身必须互联。今天的网络由十多个第一层 ISP 和数十万个较低层 ISP 组成。ISP 覆盖的区域有所不同，有些跨越多个大洲和大洋，有些限于很小的地理区域。较低层的 ISP 与较高层的 ISP 相连，较高层 ISP 彼此互联。用户和内容提供商是较低层 ISP 的客户，较低层 ISP 是较高层 ISP 的客户。近年来，主要的内容提供商也已经创建自己的网络，直接在可能的地方与较低层 ISP 互联。 分组交换网中的时延、丢包和吞吐量时延的类型 处理时延：检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分。 排队时延：在队列中，当分组在链路上等待传输时，它经受排队时延。 传输时延：交换机仅当所有已经到达的分组被传输后，才能传输刚到达的分组。传输时延其实就是将所有分组的比特推（传输）向链路所需要的时间。 传播时延：两台路由器之间的距离除以传播速率即为传播时延，而传播速率取决于该链路的物理媒体。 一个类比可以阐明传输时延和传播时延的概念。考虑一条公路每100km有一个收费站，如图1-17所示。可认为收费站间的公路段是链路，收费站是路由器。假定汽车以100km/h的速度在该公路上行驶（即传播）（即当一辆汽车离开一个收费站时，它立即加速到100km/h并在收费站间维持该速度）。假定这时有10辆汽车的车队在行驶，并且这10辆汽车以固定的顺序互相跟随。可以认为每辆汽车是一个比特，该车队是一个分组。同时假定每个收费站以每辆车12s的速度服务（即传输）一辆汽车，由于时间是深夜，因此该车队是公路上唯一一批汽车。最后，假定无论该车队的第一辆汽车何时到达收费站，它在入口处等待，直到其他9辆汽车到达并整队依次前行。（因此，整个车队在它能够“转发”之前，必须存储在收费站。）收费站将整个车队推向公路所需要的时间是（10辆车）/（5辆车/min）=2min。该时间类比于一台路由器中的传输时延。因此，一辆汽车从一个收费站出口行驶到下一个收费站所需要的时间是100h/（100km/h）=1h。这个时间类比于传播时延。因此，从该车队存储在收费站前到该车队存储在下一个收费站前的时间是“传输时延”和“传播时间”总和，在本例中为62min。 流量强度和丢包 流量强度（traffic intensity）：La/R La/R→0：几乎没有分组到达，并且到达间隔很大，平均排队时延接近于0。 La/R→1：可能有很大的平均排队时延。 La/R &gt; 1：比特到达队列的平均速率超过从该队列传输出去的速率，队列的增加趋于无界。 丢包：到达分组发现满队列时将被丢弃。（丢失分组的数量随着流量强度的增加而增加） 吞吐量 瞬时吞吐量：任何瞬间主机B接收来自主机A文件的速率。 平均吞吐量：在一段时间内接收文件的平均速率。 从服务器到客户的文件传输的吞吐量是 min{R1，R2，…，RN}，即沿着服务器和客户之间路径的瓶颈链路的速率。 因特网中对吞吐量的限制因素通常是接入网。 未完待续]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Notes</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字签名是什么（转）]]></title>
    <url>%2F2018%2F03%2F16%2F%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[“Talk about the digital signature💸” 最近学习密码学相关知识时，有一些知识感觉有点模糊。查阅资料后发现阮一峰老师翻译的一篇好文章，比较清晰地讲解了公钥私钥和数字签名证书等，特此遵循 CC BY-NC-ND 3.0 协议转发。还有一篇简书的文章，好像不支持私自转发，就引一个链接吧：什么是数字签名和证书？。 作者：David Youd 翻译：阮一峰 原文网址：http://www.youdzone.com/signature.html 翻译地址：http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html 1. 鲍勃有两把钥匙，一把是公钥，另一把是私钥。 2. 鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。 3. 苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。 4. 鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。 5. 鲍勃给苏珊回信，决定采用”数字签名”。他写完后先用Hash函数，生成信件的摘要（digest）。 6. 然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。 7. 鲍勃将这个签名，附在信件下面，一起发给苏珊。 8. 苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。 9. 苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。 10. 复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。 11. 后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。 12. 鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。 13. 苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。 14. 下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。 15. 首先，客户端向服务器发出加密请求。 16. 服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。 17. 客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。 18. 如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。 19. 如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。 20. 如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。 （完）]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Tips</tag>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链入门简明教程]]></title>
    <url>%2F2018%2F03%2F15%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[“人人都说，不说才怪。” 区块链（blockchain）是眼下的大热门，新闻媒体大量报道，一些大佬也都在口口相传。但我想，不是所有人都真正了解区块链，一些人其实只是不懂装懂而已。查阅了多方资料，感谢阮一峰老师的文章，还有菜鸟教程，百度百科等。我将这些资料和自己的理解整理汇总起来，希望能有所启发。 本质区块链是什么？用一句话来说，它是一种特殊的 分布式数据库。 那什么是分布式数据库呢？分布式数据库就是将数据信息单独存放在每台计算机上，且存储的信息是一致并且保持同步的，如果有一两台计算机坏了，信息也不会丢失，因为还可以在其他的计算机上查看到这些信息。 因为区块链是一种特殊的数据库，所以它的主要作用是 储存信息。任何需要保存的信息，都可以写入区块链，也可以从里面读取。 其次，任何人都可以架设自己的服务器或者使用自己的笔记本电脑、手机等，加入区块链网络，成为其中一个节点。区块链的世界里面，是没有中心节点的，并且每个节点都是平等的，因为每个节点都保存着整个数据库，区块链包含的信息都会存储在所有加入到区块链网络的节点当中。你可以向任何一个节点，写入或者读取数据，因为所有节点最后都会同步，以保证区块链一致。 可以抽象为：区块链是由一个个记录着各种各样信息的小区块链接起来组成的一个大区块，因为都是区块并且它们都是串行链接的，前一个和后一个保持着微妙的联系，所以它被叫做区块链。这就像盖房子，当你打好地基，准备好水泥后，就要将手上的砖块一层一层堆砌起来，这样堆叠起来的砖头是不能再拆掉的，否则会损坏整个房子。每个砖头上面还写着各种各样的信息，比如：这是块砖是谁叠的，是什么时候叠的，是什么材质的砖等。 如果想要有直观感受，可以去这里看一下：Distributed Blockchain 核心特点区块链有一个核心特点，就是 去中心化。为了了解去中心化，我们先来了解什么是中心化。 其实在现实生活中，有很多中心化的例子。比如平时浏览各大视频网站，阅读新闻资讯或者网上购物。这么多形形色色的网站肯定且必须有一台或多台服务器把这些资源和信息准备好，以供人们浏览翻阅。但是如果这些服务器坏了的话，人们也就无法访问了。因为为它们是中心化的。所谓擒贼先擒王，也是这个道理。 再举个例子，在淘宝上购买商品，有 挑选商品-&gt;购买商品-&gt;将钱托管在淘宝的支付宝平台上-&gt;淘宝提醒商家发货-&gt;客户确认无误收货-&gt;商家得到客户事先已经托管在支付宝上的钱 一套流程。这个交易，其实是有第三方介入的。考虑极端情况，如果支付宝故障或赖账，那么，交易其实是未能达成的，而且将会带来不必要的损失。如果没有第三方介入，就像现实中在商店购买东西一样，双方达成协议并确认无误后，即可完成一笔交易，这样的模式，就是去中心化。去中心化可以免去不必要的第三方资源，也可以避免双方除了交易信息以外的个人信息泄露，最重要的，它可以排除第三方控制交易的风险。 所以，身为去中心化代表的区块链，它是彻底无中心的。其他的数据库都有管理员，但是区块链没有。如果有人想对区块链添加审核，这也是实现不了的，因为它的设计目标就是防止大公司、大集团拥有管理权，掌控了整个平台，为所欲为。 因为无法管理，区块链才能做到无法被控制，而正是因为无人控制，区块链才火速流行了起来。 但是，没有了管理员，人人都可以往里面写入数据，怎么才能保证数据是可信的呢？如果数据被坏人修改了，又该怎么办呢？请接着往下读，这就是区块链奇妙的地方。 区块区块链由一个个区块（block）组成（第一个区块称为创世区块）。区块很像数据库的记录，每次写入数据，就是创建一个区块。 以比特币为例，矿工通过挖矿来创建新的区块。此外比特币采用的 PoW（工作量证明机制）共识机制，理解起来很简单：你能够获得多少货币，取决于你挖矿贡献的有效工作，根据你的工作量证明来分配货币。比如比特币、莱特币，都是基于 PoW 的虚拟货币，你的算力越高，挖矿时间越长，你获得的币就越多。 当然该机制内部实现很复杂，有很多细节，比如：挖矿难度自动调整、区块奖励逐步减半等，这些因素都是基于经济学原理，能吸引和鼓励更多人参与。 我们可以看到，每个区块包含两个部分： 区块头（Head）：记录当前区块的特征值。 区块体（Body）：包含实际数据。 区块头包含了当前区块的多项特征值： 生成时间。 实际数据（即区块体）的哈希。 上一个区块的哈希。 ……. 这里，你需要理解什么叫 哈希（hash），这是理解区块链必需的。 所谓 哈希 就是计算机可以对任意内容，计算出一个长度相同的特征值。区块链的哈希长度是256位，这就是说，不管原始内容是什么，最后都会计算出一个256位的二进制数字。而且可以保证，只要原始内容不同，对应的哈希一定是不同的。 可以用一个简单的 Python 脚本来说明： 1234567891011import hashlibblockchain = hashlib.sha256('blockchain'.encode('utf-8')).hexdigest()blockchains = hashlib.sha256('blockchains'.encode('utf-8')).hexdigest()bitcoin = hashlib.sha256('bitcoin'.encode('utf-8')).hexdigest()bitcoins = hashlib.sha256('bitcoins'.encode('utf-8')).hexdigest()print(blockchain)print(blockchains)print(bitcoin)print(bitcoins) 打印结果是： 1234ef7797e13d3a75526946a3bcf00daec9fc9c9c4d51ddc7cc5df888f74dd434d199cf6497afaa87b8ce79a4a5f4ca90a579773d6770650f0819179309ed8461906b88c087247aa2f07ee1c5956b8e1a9f4c7f892a70e324f1bb3d161e05ca107bb1e84e5753592ece4010051fab177773d917b0e788f7d25c74c5e0fc63903aa9 可以看到，不同的内容产生的哈希是不一样的（其实不管怎么样，都是有可能存在哈希冲突的，只是概率较低）。这里，我们可以得出几个关于哈希的重要结论： 等长性：不管原始信息多长或者多短, 计算出来的哈希值都具有固定的长度。 单向性：由原文获得哈希值很容易,但是根据哈希值推测原文是不可能的。 确定性：同一个原始信息用相同的哈希算法永远得到同一个哈希值。 分散性：即使原始信息只有微小改动（即使只改动一个比特），也会导致哈希值面目全非。 应用在区块中，我们可以得到： 不同区块的哈希是不一样的，可以通过哈希标识区块。 如果区块的内容变了，它的哈希也一定会改变。 哈希的不可修改性区块与哈希是一一对应的，每个区块的哈希都是针对 区块头（Head） 计算的。也就是说，把区块头的各项特征值，按照顺序连接在一起，组成一个很长的字符串，再对这个字符串计算哈希。 hash = sha256(区块头) 上面就是区块哈希的计算公式，sha256 是区块链的哈希算法。注意，这个公式里面只包含区块头，不包含区块体，也就是说，哈希由区块头唯一决定。 前面说过，区块头包含很多内容，其中有当前区块体的哈希，还有上一个区块的哈希。这意味着，如果当前区块体的内容变了，或者上一个区块的哈希变了，一定会引起当前区块的哈希改变。 这一点对区块链也有着重大意义。如果有人修改了一个区块，该区块的哈希就变了。为了让后面的区块还能连到它（因为下一个区块包含上一个区块的哈希），该人必须依次修改后面所有的区块，否则被改掉的区块就脱离区块链了。由于后面要提到的原因，哈希的计算很耗时，短时间内修改多个区块几乎不可能发生，除非有人掌握了全网 51% 以上的计算能力。关于 51%攻击 可以参考两篇文章：51%攻击解析 &amp; 51%以上算力集中在中国，这是个隐患么？。 正是通过这种联动机制，区块链保证了自身的可靠性，数据一旦写入，就无法被篡改。这就像历史一样，发生了就是发生了，从此再无法改变。 现在，我们可以做一个小实验来感受一下，创建几个包含简单内容的区块： 现在如果我们篡改第一个区块链里的内容，后续区块的哈希将会发生错误： 这也证明了区块链中哈希的不可修改性。 挖矿 中本聪（这是假名，真实身份至今未知）最初设计比特币时规定每产生 210000 个区块，比特币奖励减半一次，直至比特币不能再被细分。因为比特币和黄金一样总量有限。所以比特币被称为数字黄金。比特币的生产也俗称挖矿。 挖矿是将一段时间内比特币系统中发生的交易进行确认，并记录在区块链上形成新区块的过程，挖矿的人叫做矿工。简单说来，挖矿就是记账的过程，矿工是记账员，区块链就是账本。职业矿工进行挖矿工作，一天下来，电费破万也是轻而易举的。 怎样激励矿工来挖矿呢？比特币系统的记账权力是去中心化的，即每个矿工都有记账的权力。成功抢到记账权的矿工，会获得系统新生的比特币奖励。因此，挖矿就是生产比特币的过程。 由于必须保证节点之间的同步，所以新区块的添加速度不能太快。试想一下，你刚刚同步了一个区块，准备基于它生成下一个区块，但这时别的节点又有新区块生成，你不得不放弃做了一半的计算，再次去同步。因为每个区块的后面，只能跟着一个区块，你永远只能在最新区块的后面，生成下一个区块。所以，你别无选择，一听到信号，就必须立刻同步。 中本聪故意让添加新区块变得很困难。他的设计是，平均每 10 分钟，全网才能生成一个新区块，一小时也就 6 个。这种产出速度不是通过命令达成的，而是故意设置了海量的计算。也就是说，只有通过极其大量的计算，才能得到当前区块的有效哈希，从而把新区块添加到区块链。由于计算量太大，所以快不起来。挖矿的困难来源于计算有效哈希的难度，这就好比在全世界的沙子里面，找到一粒符合条件的沙子。 难度系数也许你可能会有一个疑问，人们都说挖矿很难，可是挖矿不就是用计算机算出一个哈希吗，这正是计算机的强项啊，怎么会变得很难，迟迟算不出来呢？ 那先来了解一下算力的概念。在通过挖矿得到比特币的过程中，我们需要找到其相应的解，而要找到其解，并没有固定算法，只能靠计算机随机的哈希碰撞。一台矿机每秒钟能做多少次哈希碰撞，就是其 算力 的代表，单位写成 hash/s。算力可以简单的理解为计算能力。 目前主流的矿机为 14T 左右的计算量级，即一台矿机就能每秒做至少 1.4*10^13 次方次哈希碰撞，我们可以说，这一台矿机有 14T 的算力。那么，矿机每秒钟能做执行那么多次哈希碰撞，为什么挖矿还是很难呢？ 其实不是任意一个哈希都可以的，只有满足条件的哈希才会被区块链接受。这个条件特别苛刻，使得绝大部分哈希都不满足要求，必须重算。 原来，区块头包含一个 难度系数（difficulty），这个值决定了计算哈希的难度。举例来说，第 100000 个区块的难度系数是 14484.16236122。 区块链协议规定，使用一个常量除以难度系数，可以得到 目标值（target）。显然，难度系数越大，目标值就越小。 哈希的有效性跟目标值密切相关，只有小于目标值的哈希才是有效的，否则哈希无效，必须重算。由于目标值非常小，哈希小于该值的机会极其渺茫，可能计算10亿次，才算中一次。这就是采矿如此之慢的根本原因。 前面说过，当前区块的哈希由区块头唯一决定。如果要对同一个区块反复计算哈希，就意味着，区块头必须不停地变化，否则不可能算出不一样的哈希。区块头里面所有的特征值都是固定的，为了让区块头产生变化，中本聪故意增加了一个随机项，叫做 Nonce。 Nonce 其实是一个没有什么实际意义的很大的随机值。由于 Nonce 是哈希的一部分，Nonce 改变了，这个区块的哈希也会改变了。矿工的作用其实就是猜出 Nonce 的值，使得区块头的哈希可以小于目标值，从而能够写入区块链。Nonce 是非常难猜的，目前只能通过穷举法一个个试错。根据协议，Nonce 是一个32位的二进制值，即最大可以到 21.47 亿。第 100000 个区块的 Nonce 值是 274148111，可以理解成，矿工从0开始，一直计算了 2.74 亿次，才得到了一个有效的 Nonce 值，使得算出的哈希能够满足条件。 运气好的话，也许一会就找到了 Nonce。运气不好的话，可能算完了 21.47 亿次，都没有发现 Nonce，即当前区块体不可能算出满足条件的哈希。这时，协议允许矿工改变区块体，开始新的计算。 我们通过一个 Python 脚本来来模拟一下区块的哈希计算： 123456import hashlibfor nonce in range(15961902): content = 'Hello, world!' hash = content + str(nonce) print(hash, hashlib.sha256(hash.encode('utf-8')).hexdigest()) 输出结果为： 12345678Hello, world!0 1312af178c253f84028d480a6adc1e25e81caa44c749ec81976192e2ec934c64Hello, world!1 e9afc424b79e4f6ab42d99c81156d3a17228d6e1eef4139be78e948a9332a7d8Hello, world!2 ae37343a357a8297591625e7134cbea22f5928be8ca2a32aa475cf05fd4266b7......Hello, world!4249 c004190b822f1669cac8dc37e761cb73652e7832fb814565702245cf26ebb9e6Hello, world!4250 0000c3af42fc31103f1fdc0151fa747ff87349a4714df7cc52ea464e12dcd4e9......Hello, world!15961901 00000061eba1b9261c3d441584a892e9286b20d79b294fc6a450315f7773250d 哈希值前面的0越多，代表这个哈希值也就越小，可以看到，经过4250次的运算后，可以找到前面有4个0的哈希值，而进行15961901次运算后，才能找到前面有6个0的哈希值。 难度系数动态调节挖矿具有随机性，没法保证正好十分钟产出一个区块，有时一分钟就算出来了，有时几个小时可能也没结果。总体来看，随着硬件设备的提升，以及矿机的数量增长，计算速度一定会越来越快。 为了将产出速率恒定在十分钟，中本聪还设计了难度系数的动态调节机制。他规定，难度系数每两周（2016个区块）调整一次。如果这两周里面，区块的平均生成速度是9分钟，就意味着比法定速度快了10%，因此接下来的难度系数就要调高10%；如果平均生成速度是11分钟，就意味着比法定速度慢了10%，因此接下来的难度系数就要调低10%。 难度系数越调越高（目标值越来越小），也就导致了挖矿越来越难。 分叉即使区块链是可靠的，现在还有一个问题没有解决：如果两个人同时向区块链写入数据，也就是说，同时有两个区块加入，因为它们都连着前一个区块，就形成了分叉。这时应该采纳哪一个区块呢？ 现在的规则是，新节点总是采用最长的那条区块链。如果区块链有分叉，将看哪个分支在分叉点后面，先达到6个新区块（称为”六次确认”）。按照10分钟一个区块计算，一小时就可以确认。 由于新区块的生成速度由计算能力决定，所以这条规则就是说，拥有大多数计算能力的那条分支，就是正宗的区块链。 工作流程到这里，我们已经可以总结一下区块链的工作流程了，以比特币对区块链的应用为例： 买卖双方根据各自所需使用比特币进行交易，形成交易记录。 互联网上的任何一名用户都可以使用自己的电脑成为一个节点，将这个交易记录收集到一个区块的数据结构中，并寻找与之匹配的 Nonce 值，使整个区块的哈希值由若干个0开头以小于建造一个区块需要的目标值。 哪个节点最先找到这个 Nonce，也就最先创造了这个区块，系统会把这个区块广播到网络中交给所有其余节点投票。 每个节点都会审核交易记录是否准确、Nonce 值是否有效等，如果都没有问题，就投赞成票，如果多数节点都投赞成票共识就达成了。 达成共识后，这个新区块被加到区块链中。 交易被确认完成。 总结区块链作为无人管理的分布式数据库，从2009年开始已经运行了8年，没有出现大的问题。这证明它是可行的。 但是，为了保证数据的可靠性，区块链也有自己的代价。一是效率，数据写入区块链，最少要等待十分钟，所有节点都同步数据，则需要更多的时间；二是能耗，区块的生成需要矿工进行无数无意义的计算，这是非常耗费能源的。 因此，区块链的适用场景，其实非常有限。 不存在所有成员都信任的管理当局。 写入的数据不要求实时使用。 挖矿的收益能够弥补本身的成本。 如果无法满足上述的条件，那么传统的数据库是更好的解决方案。 目前，区块链最大的应用场景（可能也是唯一的应用场景），就是以比特币为代表的加密货币。 参考来源 理解区块链 区块链入门教程(菜鸟教程) 区块链入门教程(阮一峰的网络日志)]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python密码学不完全指北（古典密码）]]></title>
    <url>%2F2018%2F03%2F05%2FPython%E5%AF%86%E7%A0%81%E5%AD%A61%2F</url>
    <content type="text"><![CDATA[“这是成为黑客的必经之路。” 什么是密码学？密码学是一门非常古老的学科，是把人们能够读懂的消息变换成不易读懂的信息用来隐藏信息内容，使得窃听者无法理解消息的内容，同时又能够让合法用户把变换的结果还原成能够读懂的消息。 密码学的发展经历了3个阶段：（1）古典密码。这个时期的密码应该被称之为艺术，而不是科学，是古代人民智慧的结晶，典型的密码有阴符、藏头诗、石蜡密信、反切密码（明代戚继光）、凯撒密码和天书等。（2）近代密码。1949年，伟大科学家香农发表了著名的《保密系统的通信理论》和《通信的数学理论》两篇文章，使得密码学从此由艺术走上了科学的道路，成为一门学科。（3）现代密码学。1976年，美国国家标准局公布了数据加密标准（DES），这一对称密码标准在世界上广泛流传和应用；同年，密码学家、图灵奖获得者Diffie和Hellman（2016年图灵奖）发表了《密码学的新方向》，开创了公钥密码学的新纪元。 下面就来说说一些古典加密法。 凯撒加密法 凯撒加密法，或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。 其基本思想是：通过把字母移动一定的位数来实现加密和解密。例如，密钥代表的是把明文字母向后移动的位数。如果密钥为3，那么明文字母 B 就变成了密文的 E，依次类推，X 将变成 A，Y 变成 B，Z 变成 C。 也就是说，当密钥 key = 3 时，明文字母表和密文字母表分别是： 12明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC 使用时，加密者查找明文字母表中需要加密的消息中的每一个字母所在位置，并且写下密文字母表中对应的字母。需要解密的人则根据事先已知的密钥反过来操作，得到原来的明文。 那么，密钥有多少种可能呢？ 有26个。因为当 key = 26 时，它的效果是和 key = 0 的效果是一样的，并且密文和明文的结果是一样的。 所以，通过穷举法，是可以轻松破解凯撒加密的。 根据凯撒加密法的原理，可以得到加解密算法的函数： 123456789101112131415161718192021222324252627282930from pprint import pprintimport stringLETTERS = string.ascii_uppercase # 获得二十六个英文大写字母def CaesarCipher(message, key, mode): ''' message: 明文 key: 密钥（在0~25之间） mode: 设定模式：加密（encrypt）；解密（decrypt） ''' translated = '' # 翻译后字符串 for symbol in message: if symbol.upper() in LETTERS: index = LETTERS.find(symbol.upper()) if mode == 'encrypt': # 判断当前是加密模式还是解密模式 index = (index + key) % len(LETTERS) elif mode == 'decrypt': index = (index - key) % len(LETTERS) if symbol.isupper(): # 判断字符是大写还是小写，以此决定加密或解密后是大写还是小写 translated = translated + LETTERS[index] # 空字符串一个个加上翻译后得到的字符 elif symbol.islower(): translated = translated + LETTERS[index].lower() else: # 如果需要翻译的字符不在26个大写字母的范围内，就直接保持原样加入 translated = translated + symbol return translatedprint(CaesarCipher('I love you.', 13, 'encrypt'))print(CaesarCipher('V ybir lbh.', 13, 'decrypt')) 输出结果为： 12V ybir lbh.I love you. 因为加密密钥其实是知道的，根据所有的密钥对密文进行解密，得到的结果里肯定是包含正确的明文的： 1234567891011121314151617181920import stringLETTERS = string.ascii_uppercase # 获得二十六个英文大写字母def CaesarCipherHacker(message): '''根据密文 message 和范围在 0~25 之间的密钥 key 实施暴力破解''' for key in range(len(LETTERS)): translated = '' # 翻译后字符串 for symbol in message: if symbol.upper() in LETTERS: index = (LETTERS.find(symbol.upper()) - key) % len(LETTERS) if symbol.isupper(): # 判断字符是大写还是小写，以此决定加密或解密后是大写还是小写 translated = translated + LETTERS[index] # 空字符串一个个加上翻译后得到的字符 elif symbol.islower(): translated = translated + LETTERS[index].lower() else: # 如果需要翻译的字符不在26个大写字母的范围内 translated = translated + symbol print('&#123;:&gt;2&#125;: &#123;&#125;'.format(key, translated))CaesarCipherHacker('V ybir lbh.') 输出结果为： 1234567891011121314151617181920212223242526 0: V ybir lbh. 1: U xahq kag. 2: T wzgp jzf. 3: S vyfo iye. 4: R uxen hxd. 5: Q twdm gwc. 6: P svcl fvb. 7: O rubk eua. 8: N qtaj dtz. 9: M pszi csy.10: L oryh brx.11: K nqxg aqw.12: J mpwf zpv.13: I love you.14: H knud xnt.15: G jmtc wms.16: F ilsb vlr.17: E hkra ukq.18: D gjqz tjp.19: C fipy sio.20: B ehox rhn.21: A dgnw qgm.22: Z cfmv pfl.23: Y belu oek.24: X adkt ndj.25: W zcjs mci. 可以得到，密钥为13的结果是正确的可读的明文。 这里附上一个网页版的凯撒加密轮盘：CipherWheel 维吉尼亚加密法 人们在单一恺撒密码的基础上扩展出多表密码，称为“维吉尼亚”密码。该方法最早记录在吉奥万·巴蒂斯塔·贝拉索（ Giovan Battista Bellaso）于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的密码》（意大利语：La cifra del. Sig. Giovan Battista Bellaso）中。 所以说，虽然维吉尼亚加密法和凯撒加密法类似，但是维吉尼亚加密法拥有更多的密钥，所以也被称为多表替代加密法。而它的安全性，相较于其他古典加密法，是很高的，曾一度被称作 不可破译的加密法。 相比凯撒加密轮盘，维吉尼亚加密法形成的是一个巨大的方阵。 方阵用第一行代表明文字母，第一列代表密钥字母。它们包围的区域就是加密表，每一行都是不重复的26个字母，但下一行相对于上一行，会发生一次位移。 如果明文只用其中某一个进行加密，那么这就只是简单的恺撒加密法了。但如果用方阵中不同的行加密不同的字母，它就是一种强大的加密法了。 例如，加密者可以用第5行来加密第1个字母，再用第20行来加密第2个字母，然后根据第13行来加密第3个字母，不断选择不同的行，加密的程度也就越高。 我们可以根据上面的图对如下明文进行加密：TO BE OR NOT TO BE THAT IS THE QUESTION当选定 RELATIONS 作为密钥时，加密过程是：明文第一个字母为 T，密钥第一个字母为 R，因此可以得到 R 行 T 列的值为 K，将 T 换成 K。依此类推，得出对应关系如下： 123密钥：RELAT IONSR ELATI ONSRE LATIO NSREL明文：TOBEO RNOTT OBETH ATIST HEQUE STION密文：KSMEH ZBBLK SMEMP OGAJX SEJCS FLZSY 现在可以用代码去实现了。 使用维吉尼亚加密法对信息进行加密和解密12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# vigenereCipher.pyimport stringLETTERS = string.ascii_uppercase # 获得二十六个英文大写字母def VigenèreCipher(message, key, mode): ''' message: 明文 key: 密钥（不定长单词串） mode: 设定模式：加密（encrypt）；解密（decrypt） ''' translated = [] # 翻译后字符串 keyIndex = 0 key = key.upper() for symbol in message: index = LETTERS.find(symbol.upper()) if index != -1: # 如果 index 等于 -1 代表 symbol 不在 LETTERS 中 if mode == 'encrypt': index = (index + LETTERS.find(key[keyIndex])) % len(LETTERS) # 判断当前是加密模式还是解密模式 elif mode == 'decrypt': index = (index - LETTERS.find(key[keyIndex])) % len(LETTERS) # 将翻译后的字符加入到 translated 列表 if symbol.isupper(): translated.append(LETTERS[index]) elif symbol.islower(): translated.append(LETTERS[index].lower()) keyIndex += 1 # 不断移动密钥的索引，如果索引与密钥长度相等，就要重新置0 if keyIndex == len(key): keyIndex = 0 else: translated.append(symbol) return ''.join(translated) # 将翻译后的字符组合成字符串def vigenèreEncrypt(message, key): return VigenèreCipher(message, key, 'encrypt')def vigenèreDecrypt(message, key): return VigenèreCipher(message, key, 'decrypt')if __name__ == '__main__': print(vigenèreEncrypt('Nothing is possible.', 'Ariel')) print(vigenèreDecrypt('Nfbltnx qw aojammlv.', 'Ariel')) print(vigenèreEncrypt('I have a lot of money.', 'mathematics')) print(vigenèreDecrypt('U htci m lhb qx yoglc.', 'mathematics')) 输出结果为： 1234Nfbltnx qw aojammlv.Nothing is possible.U htci m lhb qx yoglc.I have a lot of money. 爆破维吉尼亚加密法我们可以先来了解一下维吉尼亚加密法的背景： 公元16世纪晚期，法国外交官维吉尼亚（Vigenere）提出著名的维吉尼亚方阵密表和维吉尼亚密码(Vigenerecypher)，这是一种多表加密的替代密码。Vigenere 密码的出现，使得先前对单表置换用的简单频率分析方法失效。公元1863年，普鲁士少校卡西斯基（Kasiski）提出了 Kasiski 法，此方法从密钥的长度着手破解Vigenere 密码。 基本思想 通常，用 Vigenere 密码加密，明文中的相同字母在密文中不会对应相同的字母。但是，如果两个相同字母序列间距正好是密钥长度的倍数时，也可能产生相同的密文序列。寻找重复出现的字母序列，并求其长度的过程被称为 Kasiski 试验，即 Kasiski 法。Kasiski 法 在解密 Vigenere 密码时，利用的是多表体系的弱点：相同的明文字母组，在明文序列中间隔的字母数为 d（d 是密钥的长度）的倍数时，则明文字母组对应的密文字母组也必相同。反之则不一定，但相同的概率很大。如果将密文中相同字母组找出来，并对其间隔的距离进行研究，找出它们的最大公因子，则该因子是密钥长度的概率是较大的。 基本原理 基于 Kasiski 法的基本思想，Kasiski 法 测试过程如下：首先对密文中任意两个紧邻字符的出现位置进行统计，然后记下它们各次间出现的间隔。然后写出这些间隔对应数字的因数，最后对这些因数进行统计，一般来说，次数出现最多的几个因数极有可能就是密钥字符串的长度。其依据是：对于两个连续出现的字符在这次与下次出现的间隔极有可能是采用相同密钥加密形成的，从而这之间的间隔也极有可能就是密钥长度的倍数。一般在使用 Kasiski 法测试密钥长度时，先搜索长度至少为3的相同的密文段，记录这些相同密文段到起始点之间的距离；假如得到如下几个距离 X1,X2,...，猜测密钥长度 m 为这些 Xi 的最大公因子的因子。 分析步骤 在密文中标出重复的三个或多个字符序列； 对每一个字符序列，记下序列第一个字符的起始位置； 计算每个重复序列与第一个序列间的距离； 对每个距离求出所有因数有效的因数； 密钥的长度极有可能为步骤4中的出现次数较多的前面几位因数。 知道如何得到密钥的长度后，还要了解一个现象：英文字母的频度。 英文中每个字母出现的频度并不都是一样的，曾有人对大量的英文书籍、文献和字典等做过统计，并汇总如下表： 可以看到，ETAOIN 是英文中出现频度最高的六个字母，而 VKJXQZ 则是出现频度最低的六个字母。 使用凯撒加密法或者维吉尼亚加密法时，都只是将原来的字母进行一定计算后再移位，替换成别的字母。原先的字母会变，但它们的频度不会变。明文加密后形成的密文，它的字母所拥有的频度，是与明文是差不多的。 给定一个文本： “I rc ascwuiluhnviwuetnh,osgaa ice tipeeeee slnatsfietgi tittynecenisl. e fo f fnc isltn sn o a yrs sd onisli ,l erglei trhfmwfrogotn,l stcofiit.aea wesn,lnc ee w,l eIh eeehoer ros iol er snh nl oahsts ilasvih tvfeh rtira id thatnie.im ei-dlmf i thszonsisehroe, aiehcdsanahiec gv gyedsB affcahiecesd d lee onsdihsoc nin cethiTitx eRneahgin r e teom fbiotd n ntacscwevhtdhnhpiwru” 我们统计一下这个文本中每个单词的频率，并对它进行从高到低排序：EISNTHAOCLRFDGWVMUYBPZXQJK。 将获得的排序好的字母和英文中出现频率从高到底的字母进行一一比较。我们可以看到：文本的字母频率表里的前六个字母，有四个在英文字母频率表的前六个字母里；文本的字母频率表里的后六个字母，有五个在英文字母频率表的后六个字母里。这意味着这个文本的字母出现频度很接近英文中的字母出现频度，我们定义这为频率匹配分值，而例子中的频率匹配分值应该为9。这意味着如果找对了密钥，通过密钥解密得到的明文，它会有较高的频率匹配分值。再进一步想，知道密钥的长度后，从初始位置开始，每隔密钥长度取一个字母，组成一个字符串，我们用26个字母直接对这个字符串进行解密，如果得到的频率匹配分值较高，说明这个密钥可能包含这个字母。得到密钥每个位置可能拥有的字符后，排列组合一下密钥，轮番带入进行解密，就有可能找到正确的密钥了。整理一下思路，可以敲代码了。 为了完成爆破，我们需要先解决计算频率匹配分值的问题，可以创建一个 freqAnalysis.py 文件，里面写入： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# affineCipher.pyimport stringenglishLetterFreq = &#123;'E': 12.70, 'T': 9.06, 'A': 8.17, 'O': 7.51, 'I': 6.97, 'N': 6.75, 'S': 6.33, 'H': 6.09, 'R': 5.99, 'D': 4.25, 'L': 4.03, 'C': 2.78, 'U': 2.76, 'M': 2.41, 'W': 2.36, 'F': 2.23, 'G': 2.02, 'Y': 1.97, 'P': 1.93, 'B': 1.29, 'V': 0.98, 'K': 0.77, 'J': 0.15, 'X': 0.15, 'Q': 0.10, 'Z': 0.07&#125;ETAOIN = 'ETAOINSHRDLCUMWFGYPBVKJXQZ'def getLetterCount(message): '''根据给定的 message，计算每个英文字母出现的次数，并返回一个结构为 '字母：频度' 的字典''' # 初始化一个包含二十六个大写英文字母的字典，默认值为0 letterCount = dict.fromkeys(string.ascii_uppercase, 0) for letter in message.upper(): if letter in letterCount: letterCount[letter] += 1 # 计数，相当于得到频度 return letterCountdef getFrequencyOrder(message): '''根据给定的 message，计算每个英文字母出现的次数对英文字母进行排序，并返回包含频度从高到低的字母的字符串''' letterToFreq = getLetterCount(message) freqToLetter = &#123;&#125; # 创建键为频度，值为字母列表的字典，相同频度的字母在一个列表中 for letter in string.ascii_uppercase: freqToLetter.setdefault(letterToFreq[letter], []).append(letter) # 将字母列表的值按照 ETAOIN 字符串内的字母顺序逆序排序，并合并成一个字符串 # 为什么要逆序呢？比如 D 和 W 的频度都是1，因为英文字母中，D 出现的频度大于 W，现在在消息中 D 和 W 频度相等，也就代表 W 的频度其实更大一些，也就要排在 D 的前面 for freq in freqToLetter: freqToLetter[freq].sort(key=ETAOIN.find, reverse=True) freqToLetter[freq] = ''.join(freqToLetter[freq]) # 根据频度从大到小排序，并创建一个遵从这个顺序的字母列表 freqToLetter = sorted(freqToLetter.items(), key=lambda x: x[0], reverse=True) freqOrder = [x[1] for x in freqToLetter] return ''.join(freqOrder)def englishFreqMatchScore(message): '''计算频率匹配分值''' freqOrder = getFrequencyOrder(message) matchScore = 0 # 统计前六位字符和后六位字符与 ETAOIN 字符串的匹配程度 for commonLetter in ETAOIN[:6]: if commonLetter in freqOrder[:6]: matchScore += 1 for uncommonLetter in ETAOIN[-6:]: if uncommonLetter in freqOrder[-6:]: matchScore += 1 return matchScoreif __name__ == '__main__': message = 'ddddbbbaaceeffj' print(getLetterCount(message)) print(getFrequencyOrder(message)) print(englishFreqMatchScore(message)) 这样就搞定了频率分析的问题。如果明文包含了大量的英文时，就有可能获得了正确的密钥。如果我们一个个看解密后的文字，费时劳神，可以通过字典文件，根据字符串是否在字典文件中判断它是不是英文。请参考 detectEnglish.py &amp; dictionary.txt。 完成了以上的准备工作，还要按照一开始的分析步骤，计算密钥的可能长度，创建密钥可能的字母组合，实施爆破。上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211# hacker.pyimport itertools, re, stringimport freqAnalysis, detectEnglish, vigenereCipherLETTERS = string.ascii_uppercase # 获得26个大写的英文字母NONLETTERS_PATTERN = re.compile('[^A-Z]') # 预先编译去除大写字母外字符的模式MAX_KEY_LENGTH = 16 # 设置可接受的最大的 key 的长度SILENT_MODE = False # 静默模式，如果不想程序输出运行过程，就设置为 FalseNUM_MOST_FREQ_LETTERS = 4 # 设定备选字符的长度def findRepeatSequencesSpacings(message): '''找到 message 中所有的长度为 3~6 的重复序列，并计算每个重复序列离最开始的序列的间距。''' message = NONLETTERS_PATTERN.sub('', message.upper()) seqSpacings = &#123;&#125; for seqLen in range(3, 6): for seqStart in range(len(message) - seqLen): seq = message[seqStart:seqStart + seqLen] for i in range(seqStart + seqLen, len(message) - seqLen): if message[i:i + seqLen] == seq: seqSpacings.setdefault(seq, []).append(i - seqStart) return seqSpacingsdef getUsefulFactors(num): '''返回有意义的因数。比如1是没有意义的，因数太大也是没有意义的。因为所求的因数是为了反映密钥的长度，如果太大，比如大于16，就很难再有效时间内完成后续的爆破。 比如 getUsefulFactors(144) 将会返回 [2, 72, 3, 48, 4, 36, 6, 24, 8, 18, 9, 16, 12]。 ''' if num &lt; 2: return [] factors = [] for i in range(2, MAX_KEY_LENGTH + 1): if num % i == 0: factors.append(i) factors.append(num // i) if 1 in factors: factors.remove(1) return list(set(factors))def getMostCommonFactors(seqFactors): ''' seqFactors 是一个字典，它的键是重复序列, 值是因数列表。 比如 seqFactors = &#123;'GFD': [2, 3, 4, 6, 9, 12, 18, 23, 36, 46, 69, 92, 138, 207], 'ALW': [2, 3, 4, 6, ...], ...&#125;。 将返回一个包含因数和因数出现次数元组的列表。 ''' factorCounts = &#123;&#125; for seq in seqFactors: factorList = seqFactors[seq] for factor in factorList: if factor not in factorCounts: factorCounts[factor] = 0 factorCounts[factor] += 1 # 筛选得到小于16的因数列表 factorsByCount = [] for factor in factorCounts: if factor &lt;= MAX_KEY_LENGTH: # factorsByCount 可能是包含这样值的列表：[(3, 497), (2, 487), ...]，即包含了 (factor, factorCount) 元组的列表 factorsByCount.append((factor, factorCounts[factor])) # 根据因数出现的次数从大到小排序 factorsByCount.sort(key=lambda x: x[1], reverse=True) return factorsByCountdef kasiskiExamination(ciphertext): '''卡西斯基试验法，根据重复序列和它们间隔的键值对，计算得到密钥有可能的长度。''' # 得到重复序列和其间隔的键值对 repeatedSeqSpacings = findRepeatSequencesSpacings(ciphertext) # 获得重复序列间隔值的所有有效因数 seqFactors = &#123;&#125; for seq in repeatedSeqSpacings: seqFactors[seq] = [] for spacing in repeatedSeqSpacings[seq]: seqFactors[seq].extend(getUsefulFactors(spacing)) # 获得排序好的包含重复序列因数和其出现次数的列表 factorsByCount = getMostCommonFactors(seqFactors) # 获得包含 key 可能长度的列表 allLikelyKeyLengths = [twoIntTuple[0] for twoIntTuple in factorsByCount] return allLikelyKeyLengthsdef getNthSubkeysLetters(n, keyLength, message): '''从指定第 n 个位置开始，每隔 keyLength 长度，就取一个字符，直到遍历结束，返回取出的字符组合的字符串。 举例： 1. getNthSubkeysLetters(1, 3, 'ABCABCABC') returns 'AAA' 2. getNthSubkeysLetters(2, 3, 'ABCABCABC') returns 'BBB' 3. getNthSubkeysLetters(3, 3, 'ABCABCABC') returns 'CCC' 4. getNthSubkeysLetters(1, 5, 'ABCDEFGHI') returns 'AF' ''' message = NONLETTERS_PATTERN.sub('', message) i = n - 1 letters = [] while i &lt; len(message): letters.append(message[i]) i += keyLength return ''.join(letters)def attemptHackWithKeyLength(ciphertext, mostLikelyKeyLength): '''根据 key 可能的长度和计算好的 key 每一位可能包含的字符，对密文进行爆破''' ciphertextUp = ciphertext.upper() allFreqScores = [] for nth in range(1, mostLikelyKeyLength + 1): # 获得间距为 mostLikelyKeyLength 的相邻字符组成的字符串 nthLetters = getNthSubkeysLetters(nth, mostLikelyKeyLength, ciphertextUp) freqScores = [] for possibleKey in LETTERS: # 分别用二十六个字母对获得的字符串进行爆破并计算频率匹配分值 decryptedText = vigenereCipher.vigenèreDecrypt(nthLetters, possibleKey) keyAndFreqMatchTuple = (possibleKey, freqAnalysis.englishFreqMatchScore(decryptedText)) # freqScores 列表将会包含 mostLikelyKeyLength 个元组，元组包含了用于爆破的密钥和计算得到的频率匹配分值 freqScores.append(keyAndFreqMatchTuple) # 按照频率匹配分值进行从大到小排序 freqScores.sort(key=lambda x: x[1], reverse=True) allFreqScores.append(freqScores[:NUM_MOST_FREQ_LETTERS]) # 只添加 freqScores 列表中排名前 NUM_MOST_FREQ_LETTERS 个元组，默认添加前四个 if not SILENT_MODE: for i in range(len(allFreqScores)): # 输出密钥的字母可能是哪些，默认只有四个 print('* Possible letters for letter &#123;&#125; of the key: '.format(i + 1), end='') for freqScore in allFreqScores[i]: print('&#123;&#125; '.format(freqScore[0]), end='') print() # 创建密钥可能长度的各种字母组合 for indexes in itertools.product(range(NUM_MOST_FREQ_LETTERS), repeat=mostLikelyKeyLength): # 根据 allFreqScores 里的元素创建可能的密钥 possibleKey = '' for i in range(mostLikelyKeyLength): possibleKey += allFreqScores[i][indexes[i]][0] if not SILENT_MODE: print('Attempting with key: &#123;&#125;'.format(possibleKey)) decryptedText = vigenereCipher.vigenèreDecrypt(ciphertextUp, possibleKey) if detectEnglish.isEnglish(decryptedText, wordPercentage=60): # 根据原来输入的 ciphertext 来复原字母的大小写 origCase = [] for i in range(len(ciphertext)): if ciphertext[i].isupper(): origCase.append(decryptedText[i].upper()) else: origCase.append(decryptedText[i].lower()) decryptedText = ''.join(origCase) # 反馈给用户检查是否找到了正确的密钥 print('&gt; Possible plaintext hack with key &#123;&#125;:'.format(possibleKey)) print('[',decryptedText[:200], ']') # only show first 200 characters choice = input('&gt; Enter (y)es for done, or press Enter for continue: ') if choice == 'y' or choice == 'Y' or choice == 'yes': return decryptedText print() # 如果一直没有发现正确的密钥，说明爆破失败 return Nonedef hackVigenere(ciphertext): '''试验卡西斯基试验法来爆破维吉尼亚加密法''' allLikelyKeyLengths = kasiskiExamination(ciphertext) if allLikelyKeyLengths: if not SILENT_MODE: keyLengthStr = ' '.join([ str(length) for length in allLikelyKeyLengths]) print('Kasiski Examination results say the most likely key lengths are: ' + keyLengthStr) for keyLength in allLikelyKeyLengths: if not SILENT_MODE: print('\nAttempting hack with key length &#123;&#125; (&#123;&#125; possible keys)...'.format(keyLength, NUM_MOST_FREQ_LETTERS ** keyLength)) hackedMessage = attemptHackWithKeyLength(ciphertext, keyLength) if hackedMessage != None: break elif not allLikelyKeyLengths or hackedMessage == None: # 如果卡西斯基试验法没有得到结果，就选择暴力破解 if not SILENT_MODE: print('Unable to hack message with likely key length(s). Brute forcing key length...') for keyLength in range(1, MAX_KEY_LENGTH + 1): if keyLength not in allLikelyKeyLengths: if not SILENT_MODE: print('Attempting hack with key length &#123;&#125; (&#123;&#125; possible keys)...'.format(keyLength, NUM_MOST_FREQ_LETTERS ** keyLength)) hackedMessage = attemptHackWithKeyLength(ciphertext, keyLength) if hackedMessage != None: break return hackedMessagedef main(message): hackedMessage = hackVigenere(message) if hackedMessage != None: print() print(hackedMessage) else: print('Failed to hack.')if __name__ == '__main__': message1 = """Adiz Avtzqeci Tmzubb wsa m Pmilqev halpqavtakuoi, lgouqdaf, kdmktsvmztsl, izr xoexghzr kkusitaaf. Vz wsa twbhdg ubalmmzhdad qz hce vmhsgohuqbo ox kaakulmd gxiwvos, krgdurdny i rcmmstugvtawz ca tzm ocicwxfg jf "stscmilpy" oid "uwydptsbuci" wabt hce Lcdwig eiovdnw. Bgfdny qe kddwtk qjnkqpsmev ba pz tzm roohwz at xoexghzr kkusicw izr vrlqrwxist uboedtuuznum. Pimifo Icmlv Emf DI, Lcdwig owdyzd xwd hce Ywhsmnemzh Xovm mby Cqxtsm Supacg (GUKE) oo Bdmfqclwg Bomk, Tzuhvif'a ocyetzqofifo ositjm. Rcm a lqys ce oie vzav wr Vpt 8, lpq gzclqab mekxabnittq tjr Ymdavn fihog cjgbhvnstkgds. Zm psqikmp o iuejqf jf lmoviiicqg aoj jdsvkavs Uzreiz qdpzmdg, dnutgrdny bts helpar jf lpq pjmtm, mb zlwkffjmwktoiiuix avczqzs ohsb ocplv nuby swbfwigk naf ohw Mzwbms umqcifm. Mtoej bts raj pq kjrcmp oo tzm Zooigvmz Khqauqvl Dincmalwdm, rhwzq vz cjmmhzd gvq ca tzm rwmsl lqgdgfa rcm a kbafzd-hzaumae kaakulmd, hce SKQ. Wi 1948 Tmzubb jgqzsy Msf Zsrmsv'e Qjmhcfwig Dincmalwdm vt Eizqcekbqf Pnadqfnilg, ivzrw pq onsaafsy if bts yenmxckmwvf ca tzm Yoiczmehzr uwydptwze oid tmoohe avfsmekbqr dn eifvzmsbuqvl tqazjgq. Pq kmolm m dvpwz ab ohw ktshiuix pvsaa at hojxtcbefmewn, afl bfzdakfsy okkuzgalqzu xhwuuqvl jmmqoigve gpcz ie hce Tmxcpsgd-Lvvbgbubnkq zqoxtawz, kciup isme xqdgo otaqfqev qz hce 1960k. Bgfdny'a tchokmjivlabk fzsmtfsy if i ofdmavmz krgaqqptawz wi 1952, wzmz vjmgaqlpad iohn wwzq goidt uzgeyix wi tzm Gbdtwl Wwigvwy. Vz aukqdoev bdsvtemzh rilp rshadm tcmmgvqg (xhwuuqvl uiehmalqab) vs sv mzoejvmhdvw ba dmikwz. Hpravs rdev qz 1954, xpsl whsm tow iszkk jqtjrw pug 42id tqdhcdsg, rfjm ugmbddw xawnofqzu. Vn avcizsl lqhzreqzsy tzif vds vmmhc wsa eidcalq; vds ewfvzr svp gjmw wfvzrk jqzdenmp vds vmmhc wsa mqxivmzhvl. Gv 10 Esktwunsm 2009, fgtxcrifo mb Dnlmdbzt uiydviyv, Nfdtaat Dmiem Ywiikbqf Bojlab Wrgez avdw iz cafakuog pmjxwx ahwxcby gv nscadn at ohw Jdwoikp scqejvysit xwd "hce sxboglavs kvy zm ion tjmmhzd." Sa at Haq 2012 i bfdvsbq azmtmd'g widt ion bwnafz tzm Tcpsw wr Zjrva ivdcz eaigd yzmbo Tmzubb a kbmhptgzk dvrvwz wa efiohzd.""" message2 = """Ej xvvvfea riiw azzwjmcqik dw ew wi r hcmhiu syl witgxm v hfuewm (pzcp bcid) kz Q byvkd Q rej lcgdrx lz iktvsdm olve. Mco ek lsm nedw eqhi, Z ola yijhpzvxvdj zpreayo varq qzjq kzpu vru lsmdv vezbdsesw iwyjw. T evw mwcg xsexwqxxvv lvy lrv yw dhvs hpvx Z olvoiu lz lj azls ut pzxp. Q ceu swevcj wikzpcwo qi qrls iih jg T kcsjw ew kyikfm olrl. T ldhe'l vvja zl lb olv ltuz, fll xg qiiq dmiwv gq azpw-ozzol nsd jvwvv zv olv xlko xyse Q rej yzwy ek elbc.""" main(message1) #main(message2) 输出结果为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104Kasiski Examination results say the most likely key lengths are: 3 2 6 4 12 8 9 16 5 11 10 15 7 14 13Attempting hack with key length 3 (64 possible keys)...* Possible letters for letter 1 of the key: A L M E* Possible letters for letter 2 of the key: S N O C* Possible letters for letter 3 of the key: V I Z BAttempting with key: ASVAttempting with key: ASIAttempting with key: ASZAttempting with key: ASBAttempting with key: ANVAttempting with key: ANIAttempting with key: ANZAttempting with key: ANBAttempting with key: AOVAttempting with key: AOIAttempting with key: AOZAttempting with key: AOBAttempting with key: ACVAttempting with key: ACIAttempting with key: ACZAttempting with key: ACBAttempting with key: LSVAttempting with key: LSIAttempting with key: LSZAttempting with key: LSBAttempting with key: LNVAttempting with key: LNIAttempting with key: LNZAttempting with key: LNBAttempting with key: LOVAttempting with key: LOIAttempting with key: LOZAttempting with key: LOBAttempting with key: LCVAttempting with key: LCIAttempting with key: LCZAttempting with key: LCBAttempting with key: MSVAttempting with key: MSIAttempting with key: MSZAttempting with key: MSBAttempting with key: MNVAttempting with key: MNIAttempting with key: MNZAttempting with key: MNBAttempting with key: MOVAttempting with key: MOIAttempting with key: MOZAttempting with key: MOBAttempting with key: MCVAttempting with key: MCIAttempting with key: MCZAttempting with key: MCBAttempting with key: ESVAttempting with key: ESIAttempting with key: ESZAttempting with key: ESBAttempting with key: ENVAttempting with key: ENIAttempting with key: ENZAttempting with key: ENBAttempting with key: EOVAttempting with key: EOIAttempting with key: EOZAttempting with key: EOBAttempting with key: ECVAttempting with key: ECIAttempting with key: ECZAttempting with key: ECBAttempting hack with key length 2 (16 possible keys)...* Possible letters for letter 1 of the key: O A E Z* Possible letters for letter 2 of the key: M S I DAttempting with key: OMAttempting with key: OSAttempting with key: OIAttempting with key: ODAttempting with key: AMAttempting with key: ASAttempting with key: AIAttempting with key: ADAttempting with key: EMAttempting with key: ESAttempting with key: EIAttempting with key: EDAttempting with key: ZMAttempting with key: ZSAttempting with key: ZIAttempting with key: ZDAttempting hack with key length 6 (4096 possible keys)...* Possible letters for letter 1 of the key: A E O P* Possible letters for letter 2 of the key: S D G H* Possible letters for letter 3 of the key: I V X B* Possible letters for letter 4 of the key: M Z Q A* Possible letters for letter 5 of the key: O B Z A* Possible letters for letter 6 of the key: V I K ZAttempting with key: ASIMOV&gt; Possible plaintext hack with key ASIMOV:[ Alan Mathison Turing was a British mathematician, logician, cryptanalyst, and computer scientist. He was highly influential in the development of computer science, providing a formalisationof the con ]&gt; Enter (y)es for done, or press Enter for continue: yAlan Mathison Turing was a British mathematician, logician, cryptanalyst, and computer scientist. He was highly influential in the development of computer science, providing a formalisation of the concepts of "algorithm" and "computation" with the Turing machine. Turing is widely considered to be the father of computer science and artificial intelligence. During World War II, Turing worked for the Government Code and Cypher School (GCCS) at Bletchley Park, Britain's codebreaking centre. For a time he was head of Hut 8, the section responsible for German naval cryptanalysis. He devised a number of techniques for breaking German ciphers, including the method of the bombe, an electromechanical machine that could find settings for the Enigma machine. After the war he worked at the National Physical Laboratory, where he created one of the first designs for a stored-program computer, the ACE. In 1948 Turing joined Max Newman's Computing Laboratory at Manchester University, where he assisted in the development of the Manchester computers and became interested in mathematical biology. He wrote a paper on the chemical basis of morphogenesis, and predicted oscillating chemical reactions such as the Belousov-Zhabotinsky reaction, which were first observed in the 1960s. Turing's homosexuality resulted in a criminal prosecution in 1952, when homosexual acts were still illegal in the United Kingdom. He accepted treatment with female hormones (chemical castration) as an alternative to prison. Turing died in 1954, just over two weeks before his 42nd birthday, from cyanide poisoning. An inquest determined that his death was suicide; his mother and some others believed his death was accidental. On 10 September 2009,following an Internet campaign, British Prime Minister Gordon Brown made an official public apology on behalf of the British government for "the appalling way he was treated." As of May 2012 a private member's bill was before the House of Lords which would grant Turing a statutory pardon if enacted. 仿射加密法仿射加密法类似凯撒加密法，只是它将凯撒加密中的加法改成了乘法和加法的结合。仿射加密中的加密和解密算法为： C = Ek(m) = (k1 × m + k2) mod nM = Dk(c) = k3(c - k2) mod n，其中 (k3 × k1) mod 26 = 1。 仿射加密具有可逆性的条件是 gcd(k1, n) = 1。当 k1 = 1 时，仿射加密就变为了加法加密也就是凯撒加密，当 k2 = 0 时，仿射密码变为了乘法加密。这两种情况带来的加密效果都是较弱的，所以应尽量避免。 仿射加密中的密钥空间的大小为 n·φ(n)。当 n 为26个英文字母时，φ(n) = 12，因此仿射加密的密钥空间为 12 × 26 = 312。 因为其加密和解密大部分思路与凯撒加密、维吉尼亚加密相同，所以直接附上源代码。算法较难点就是求最大公因数的欧几里得除法和求模逆的拓展欧几里得除法，内容颇多，请参考度娘。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import sysimport mathimport random#LETTERS = """ !"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~""" # note the space at the frontLETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'def modInverse(a, m): '''返回a的逆，使 a * a^-1 = 1 mod(m)''' if math.gcd(a, m) != 1: # 如果不 a 和 m 不互质，则 a^-1 不存在 return None # 欧几里得拓展除法 u1, u2, u3 = 1, 0, a v1, v2, v3 = 0, 1, m while v3 != 0: q = u3 // v3 v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3 return u1 % mdef getRandomKey(): '''生成一个随机的 key，其中 key = keyA * len(LETTERS) + keyB，且 keyA 和 len(LETTERS) 要互质''' while True: keyA = random.randint(2, len(LETTERS)) keyB = random.randint(2, len(LETTERS)) if math.gcd(keyA, len(LETTERS)) == 1: key = keyA * len(LETTERS) + keyB print('Generate key:', key) return keydef getKeyParts(key): '''将给定的 key 分解成 keyA 和 keyB 两个 key''' keyA, keyB = key // len(LETTERS), key % len(LETTERS) return (keyA, keyB)def checkKeys(keyA, keyB, mode): '''检查 keyA 和 keyB 是否符合标准''' if keyA == 1 and mode == 'encrypt': sys.exit('The affine cipher becomes incredibly weak when key A is set to 1. Choose a different key.') if keyB == 0 and mode == 'encrypt': sys.exit('The affine cipher becomes incredibly weak when key B is set to 0. Choose a different key.') if keyA &lt; 0 or keyB &lt; 0 or keyB &gt; len(LETTERS) - 1: sys.exit('Key A must be greater than 0 and Key B must be between 0 and %s.' % (len(LETTERS) - 1)) if math.gcd(keyA, len(LETTERS)) != 1: sys.exit('Key A (%s) and the letter set size (%s) are not relatively prime. Choose a different key.' % (keyA, len(LETTERS))) def AffineEncrypt(message, key): '''对信息用仿射加密法进行加密''' keyA, keyB = getKeyParts(key) checkKeys(keyA, keyB, 'encrypt') ciphertext = '' for letter in message: if letter.upper() in LETTERS: index = LETTERS.find(letter.upper()) if letter.isupper(): ciphertext += LETTERS[(index * keyA + keyB) % len(LETTERS)] else: ciphertext += LETTERS[(index * keyA + keyB) % len(LETTERS)].lower() else: ciphertext += letter return ciphertextdef AffineDecrypt(message, key): '''对信息用仿射加密法进行解密''' keyA, keyB = getKeyParts(key) checkKeys(keyA, keyB, 'decrypt') plaintext = '' modInverseOfKeyA = modInverse(keyA, len(LETTERS)) for letter in message: if letter.upper() in LETTERS: index = LETTERS.find(letter.upper()) if letter.isupper(): plaintext += LETTERS[(index - keyB) * modInverseOfKeyA % len(LETTERS)] else: plaintext += LETTERS[(index - keyB) * modInverseOfKeyA % len(LETTERS)].lower() else: plaintext += letter return plaintext if __name__ == '__main__': message = 'Every human being is intended to have a character of his own; to be what no others are, and to do what no other can do.' key = getRandomKey() ciphertext = AffineEncrypt(message, key) print(ciphertext) plaintext = AffineDecrypt(ciphertext, key) print(plaintext) 输出结果为： 123Generate key: 142Gngtc viumz rgazq ay azdgzbgb de vmng m wvmtmwdgt el vay esz; de rg svmd ze edvgty mtg, mzb de be svmd ze edvgt wmz be.Every human being is intended to have a character of his own; to be what no others are, and to do what no other can do. 对仿射加密法，我们可以实施爆破，因为它实际的密钥数量并不多，带入每个可能的密钥进行解密，并判断解密后的字符串是否为准确的英文，如果是，就有可能是找到了正确的密钥。 所以，需要导入一个英文字典，根据字符是否在英文字典中，可以判断这个字符是不是英文字母。因为可能会有误差，所以需要设定误差的取值范围。 具体实现可以参考我的源码：detectEnglish.py &amp; dictionary.txt 根据上面的思路，我们可以实施爆破： 123456789101112131415161718192021222324252627282930313233import mathimport affineCipherimport detectEnglishSILENT_MODE = Falsedef hackAffine(message): print('Hacking...') for key in range(len(affineCipher.LETTERS) ** 2): keyA = affineCipher.getKeyParts(key)[0] if math.gcd(keyA, len(affineCipher.LETTERS)) != 1: continue decryptedText = affineCipher.AffineDecrypt(message, key) if not SILENT_MODE: print('Trying key &#123;&#125;... [&#123;&#125;]'.format(key, decryptedText[:40])) if detectEnglish.isEnglish(decryptedText): print('\nPossible plaintext:') print('Key: %s' % (key)) print('Plaintext: \n' + decryptedText[:200]) choice = input('Enter (y)es for done, or press Enter for continue: ') if choice == 'y' or choice == 'Y': return decryptedText print() return Noneif __name__ == '__main__': message = 'Qfqda lyuob vqsbe sk sbrqbjqj ri lofq o clodocrqd ix lsk imb; ri vq mlor bi irlqdk odq, obj ri ji mlor bi irlqd cob ji.' hackAffine(message) 输出结果为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100Hacking...Trying key 26... [Qfqda lyuob vqsbe sk sbrqbjqj ri lofq o ]Trying key 27... [Pepcz kxtna uprad rj raqpaipi qh knep n ]Trying key 28... [Odoby jwsmz toqzc qi qzpozhoh pg jmdo m ]Trying key 29... [Ncnax ivrly snpyb ph pyonygng of ilcn l ]Trying key 30... [Mbmzw huqkx rmoxa og oxnmxfmf ne hkbm k ]Trying key 31... [Lalyv gtpjw qlnwz nf nwmlwele md gjal j ]Trying key 32... [Kzkxu fsoiv pkmvy me mvlkvdkd lc fizk i ]Trying key 33... [Jyjwt ernhu ojlux ld lukjucjc kb ehyj h ]Trying key 34... [Ixivs dqmgt niktw kc ktjitbib ja dgxi g ]Trying key 35... [Hwhur cplfs mhjsv jb jsihsaha iz cfwh f ]Trying key 36... [Gvgtq boker lgiru ia irhgrzgz hy bevg e ]Trying key 37... [Fufsp anjdq kfhqt hz hqgfqyfy gx aduf d ]Trying key 38... [Etero zmicp jegps gy gpfepxex fw zcte c ]Trying key 39... [Dsdqn ylhbo idfor fx foedowdw ev ybsd b ]Trying key 40... [Crcpm xkgan hcenq ew endcnvcv du xarc a ]Trying key 41... [Bqbol wjfzm gbdmp dv dmcbmubu ct wzqb z ]Trying key 42... [Apank vieyl faclo cu clbaltat bs vypa y ]Trying key 43... [Zozmj uhdxk ezbkn bt bkazkszs ar uxoz x ]Trying key 44... [Ynyli tgcwj dyajm as ajzyjryr zq twny w ]Trying key 45... [Xmxkh sfbvi cxzil zr ziyxiqxq yp svmx v ]Trying key 46... [Wlwjg reauh bwyhk yq yhxwhpwp xo rulw u ]Trying key 47... [Vkvif qdztg avxgj xp xgwvgovo wn qtkv t ]Trying key 48... [Ujuhe pcysf zuwfi wo wfvufnun vm psju s ]Trying key 49... [Titgd obxre ytveh vn veutemtm ul orit r ]Trying key 50... [Shsfc nawqd xsudg um udtsdlsl tk nqhs q ]Trying key 51... [Rgreb mzvpc wrtcf tl tcsrckrk sj mpgr p ]Trying key 78... [Otoba viywj hogjk gm gjxojdod xu vwto w ]Trying key 79... [Fkfsr mzpna yfxab xd xaofaufu ol mnkf n ]Trying key 80... [Wbwji dqger pwors ou orfwrlwl fc debw e ]Trying key 81... [Nsnaz uhxvi gnfij fl fiwnicnc wt uvsn v ]Trying key 82... [Ejerq lyomz xewza wc wzneztet nk lmje m ]Trying key 83... [Vavih cpfdq ovnqr nt nqevqkvk eb cdav d ]Trying key 84... [Mrmzy tgwuh fmehi ek ehvmhbmb vs turm u ]Trying key 85... [Didqp kxnly wdvyz vb vymdysds mj klid l ]Trying key 86... [Uzuhg boecp numpq ms mpdupjuj da bczu c ]Trying key 87... [Lqlyx sfvtg eldgh dj dgulgala ur stql t ]Trying key 88... [Chcpo jwmkx vcuxy ua uxlcxrcr li jkhc k ]Trying key 89... [Tytgf andbo mtlop lr loctoiti cz abyt b ]Trying key 90... [Kpkxw reusf dkcfg ci cftkfzkz tq rspk s ]Trying key 91... [Bgbon ivljw ubtwx tz twkbwqbq kh ijgb j ]Trying key 92... [Sxsfe zmcan lskno kq knbsnhsh by zaxs a ]Trying key 93... [Jojwv qdtre cjbef bh besjeyjy sp qroj r ]Trying key 94... [Afanm hukiv tasvw sy svjavpap jg hifa i ]Trying key 95... [Rwred ylbzm krjmn jp jmarmgrg ax yzwr z ]Trying key 96... [Inivu pcsqd biade ag adridxix ro pqni q ]Trying key 97... [Zezml gtjhu szruv rx ruizuozo if ghez h ]Trying key 98... [Qvqdc xkayl jqilm io ilzqlfqf zw xyvq y ]Trying key 99... [Hmhut obrpc ahzcd zf zcqhcwhw qn opmh p ]Trying key 100... [Ydylk fsigt ryqtu qw qthytnyn he fgdy g ]Trying key 101... [Pupcb wjzxk iphkl hn hkypkepe yv wxup x ]Trying key 102... [Glgts naqob zgybc ye ybpgbvgv pm nolg o ]Trying key 103... [Xcxkj erhfs qxpst pv psgxsmxm gd efcx f ]Trying key 130... [Ybyla xkeiv zyovg oc ovtyvhyh tm xiby i ]Trying key 131... [Dgdqf cpjna edtal th taydamdm yr cngd n ]Trying key 132... [Ilivk huosf jiyfq ym yfdifrir dw hsli s ]Trying key 133... [Nqnap mztxk ondkv dr dkinkwnw ib mxqn x ]Trying key 134... [Svsfu reycp tsipa iw ipnspbsb ng rcvs c ]Trying key 135... [Xaxkz wjdhu yxnuf nb nusxugxg sl whax h ]Trying key 136... [Cfcpe boimz dcszk sg szxczlcl xq bmfc m ]Trying key 137... [Hkhuj gtnre ihxep xl xecheqhq cv grkh r ]Trying key 138... [Mpmzo lyswj nmcju cq cjhmjvmv ha lwpm w ]Trying key 139... [Ruret qdxbo srhoz hv homroara mf qbur b ]Trying key 140... [Wzwjy vicgt xwmte ma mtrwtfwf rk vgzw g ]Trying key 141... [Bebod anhly cbryj rf rywbykbk wp aleb l ]Trying key 142... [Gjgti fsmqd hgwdo wk wdbgdpgp bu fqjg q ]Trying key 143... [Lolyn kxrvi mlbit bp bigliulu gz kvol v ]Trying key 144... [Qtqds pcwan rqgny gu gnlqnzqz le patq a ]Trying key 145... [Vyvix uhbfs wvlsd lz lsqvseve qj ufyv f ]Trying key 146... [Adanc zmgkx baqxi qe qxvaxjaj vo zkda k ]Trying key 147... [Fifsh erlpc gfvcn vj vcafcofo at epif p ]Trying key 148... [Knkxm jwquh lkahs ao ahfkhtkt fy junk u ]Trying key 149... [Pspcr obvzm qpfmx ft fmkpmypy kd ozsp z ]Trying key 150... [Uxuhw tgaer vukrc ky krpurdud pi texu e ]Trying key 151... [Zczmb ylfjw azpwh pd pwuzwizi un yjcz j ]Trying key 152... [Eherg dqkob feubm ui ubzebnen zs dohe o ]Trying key 153... [Jmjwl ivptg kjzgr zn zgejgsjs ex itmj t ]Trying key 154... [Orobq nauyl poelw es eljolxox jc nyro y ]Trying key 155... [Twtgv sfzdq utjqb jx jqotqctc oh sdwt d ]Trying key 182... [Gxgta jwocp dgkpi ku kpvgpfgf vq jcxg c ]Trying key 183... [Rirel uhzna orvat vf vagraqrq gb unir n ]Trying key 184... [Ctcpw fskyl zcgle gq glrclbcb rm fytc y ]Trying key 185... [Nenah qdvjw knrwp rb rwcnwmnm cx qjen j ]Trying key 186... [Ypyls boguh vycha cm chnyhxyx ni bupy u ]Trying key 187... [Jajwd mzrfs gjnsl nx nsyjsiji yt mfaj f ]Trying key 188... [Uluho xkcqd ruydw yi ydjudtut je xqlu q ]Trying key 189... [Fwfsz ivnbo cfjoh jt joufoefe up ibwf b ]Trying key 190... [Qhqdk tgymz nquzs ue uzfqzpqp fa tmhq m ]Trying key 191... [Bsbov erjxk ybfkd fp fkqbkaba ql exsb x ]Trying key 192... [Mdmzg pcuiv jmqvo qa qvbmvlml bw pidm i ]Trying key 193... [Xoxkr anftg uxbgz bl bgmxgwxw mh atox t ]Trying key 194... [Izivc lyqer fimrk mw mrxirhih xs lezi e ]Trying key 195... [Tktgn wjbpc qtxcv xh xcitcsts id wpkt p ]Trying key 196... [Every human being is intended to have a ]Possible plaintext:Key: 196Plaintext:Every human being is intended to have a character of his own; to be what no others are, and to do what no other can do.Enter (y)es for done, or press Enter for continue: y 轻松爆破。所以可以得到：仿射加密法，其实也是很不安全的。 Playfair 加密法 Playfair密码（英文：Playfair cipher 或 Playfair square）是一种使用一个关键词方格来加密字符对的加密法，1854年由查尔斯·惠斯通（Charles Wheatstone）的英国人发明。 它有一些不太明显的特征： 密文的字母数一定是偶数。 任意两个同组的字母都不会相同，如果出现这种字符必是乱码和虚码。 因为它使用方便而且可以让频度分析法变成瞎子，所以在1854到1855年的克里米亚战争和1899年的布尔战争中有广泛应用。但在1915年的一战中被破译了。 Playfair 加密法编写分三步： 编制密码表 整理明文 编写密文（构成部分：1.密钥 2.明文 3.密文） 加密编制密码表第一步是编制密码表。在这个 5 * 5 的密码表中，共有5行5列字母。第一行（或第一列）是密钥，其余按照字母顺序。密钥是一个单词或词组，若有重复字母，可将后面重复的字母去掉。当然也要把使用频率最少的字母去掉。并且，如果密钥同时包含 I 和 J，可以将密钥中的 J 替换成 I 或者将密码表填充的时候去掉 Q。如：密钥是 Live and learn，格式化后则为 liveandr。如果密钥过长可占用第二行或列。如密钥 crazy dog，可编制成： 0 1 2 3 4 0 C R A Z Y 1 D O G B E 2 F H I \ J K L 3 M N P Q S 4 T U V W X 或 0 1 2 3 4 0 C D F M T 1 R O H N U 2 A G I \ J P V 3 Z B K Q W 4 Y E L S X 大部分资料使用的是第一种填充方式，所以这里选择第一种。 整理明文第二步是整理明文。将明文每两个字母组成一组。如果出现两个相同的字母，则在第一个字母后添加 X 构成一组，第二个相同的字母与它后面的字母构成一组；如果只剩下最后一个字母，则在其后添加 X 构成一组。当然，也可以将 X 换成其它字母（比如 Q）。如 communist，应整理成 CO MX MU NI ST；balloon 应整理成 BA LX LO ON。 编写密文加密规则： 每两个整理好的明文字符进行加密。 同行不同列：依次取右边一位。 同列不同行：依次取下边一位。 不同行且不同列：依次取对角线横向一位。 如，依照第一个表，明文 Where there is life, there is hope. 12可先整理为：WH ER ET HE RE IS LI FE TH ER EI SH OP EX 然后密文为：UK OY DX LO YO LP FK LD UF OY GL NL GN LY 解密解密规则： 同行不同列：依次取左边一位。 同列不同行：依次取上边一位。 不同行且不同列：依次取对角线竖向一位。 根据以上思路，可以用 Python 去实现加解密算法： 编制密码表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def removeDuplicate(key, dup=0): ''' 将 key 中的非字母字符和重复字符删去并返回一个新的 key 字符串 key: 需要格式化的密钥 dup: 代表密钥选择的格式化方法：将 I 和 J 都视为 I（dup=0）;将 I 和 J 视为两个字符，选择在填充密码表的时候去除 Q， 但是要确保密钥中不包含 Q，否则还是按照第一种格式化方法（dup=1) ''' key = key.upper() if dup == 0: # 根据格式化方法对 key 进行初步格式化 key = key.replace('J', 'I') else: if 'Q' in key: key = key.replace('J', 'I') s, newKey= set(), list() # 建立一个过滤集合和 newKey 列表 temp = [ char for char in key if char.isalpha() ] # 去除非字母符号并将字母大写 for char in temp: # 根据哈希表的原理查询当前字符是否已经存在 if char not in s: newKey.append(char) s.add(char) return ''.join(newKey) # 整理成字符串 print(removeDuplicate('Crazy dog'))print(removeDuplicate('Live and learn'))def createTable(key, dup=0): ''' 根据格式化后的 newKey 建立密码表 key: 需要格式化的密钥 dup: 代表密钥选择的格式化方法：将 I 和 J 都视为 I（dup=0）;将 I 和 J 视为两个字符，选择在填充密码表的时候去除 Q， 但是要确保密钥中不包含 Q，否则还是按照第一种格式化方法（dup=1) ''' newKey = removeDuplicate(key, dup) # 返回格式化后的 key letters = 'ABCDEFGHIKLMNOPQRSTUVWXYZ' if dup == 0 or 'Q' in newKey else 'ABCDEFGHIJKLMNOPRSTUVWXYZ' # 根据格式化方法整理 letters passwordTable = [] for i in range(25): if i &lt; len(newKey): passwordTable.append(newKey[i]) # 填充 newKey else: for char in letters: if char not in passwordTable: passwordTable.append(char) # 填充不在密码表中的英文字母 break # return list(map(list, zip(*([iter(passwordTable)] * 5)))) # 将一维列表转化为二维列表 return passwordTableprint(createTable('Crazy dog'))print(createTable('Live and learn'))print(createTable('Sliver')) 输出结果为： 123456CRAZYDOGLIVEANDR['C', 'R', 'A', 'Z', 'Y', 'D', 'O', 'G', 'B', 'E', 'F', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'S', 'T', 'U', 'V', 'W', 'X']['L', 'I', 'V', 'E', 'A', 'N', 'D', 'R', 'B', 'C', 'F', 'G', 'H', 'K', 'M', 'O', 'P', 'Q', 'S', 'T', 'U', 'W', 'X', 'Y', 'Z']['S', 'L', 'I', 'V', 'E', 'R', 'A', 'B', 'C', 'D', 'F', 'G', 'H', 'K', 'M', 'N', 'O', 'P', 'Q', 'T', 'U', 'W', 'X', 'Y', 'Z'] 整理明文 123456789101112131415161718def arrangeText(message): '''整理明文中的英文字符，并进行分组处理''' temp = [ char.upper() for char in message if char.isalpha() ] # 去除其他字符，保留英文字母并转化为大写 newMessage = [] while temp: if len(temp) != 1: if temp[1] == temp[0]: newMessage.append((temp[0], 'X')) temp = temp[1:] # 相当于剔除已经分组成功的字母 else: newMessage.append((temp[0], temp[1])) temp = temp[2:] else: # 如果分组只剩最后一个字母时 newMessage.append((temp[0], 'X')) break return newMessageprint(arrangeText('I love you.')) 输出结果为： 1[('I', 'L'), ('O', 'V'), ('E', 'Y'), ('O', 'U')] 对明文进行加密： 12345678910111213141516171819202122232425262728293031323334353637383940414243def encryptPlayFair(message, key, dup=0): '''对明文使用密钥进行加密''' newMessage = arrangeText(message) table = createTable(key, dup) translated = [] for a, b in newMessage: # 获取 a 和 b 的下标 index1, index2, flag = table.index(a), table.index(b), False # 创建 [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]] ranged 区间列表 # 判断 a 和 b 是否在同一行，如果在同一行，flag = True ranged = list(map(list, zip(*([iter(range(25))] * 5)))) for group in ranged: if index1 in group and index2 in group: flag = True # a 和 b 在同一列时 if (index2 - index1) % 5 == 0: # char1, char2 = table[(index1 + 5) % 25], table[(index2 + 5) % 25] # a 和 b 在同一行时 elif flag: if index1 in &#123;4, 9, 14, 19, 24&#125;: char1, char2 = table[index1 - 4], table[index1 + 1] elif index2 in &#123;4, 9, 14, 19, 24&#125;: char1, char2 = table[index1 + 1], table[index2 - 4] else: char1, char2 = table[index1 + 1], table[index2 + 1] # a 和 b 既不在同一行也不在同一列时 else: length1, length2 = index1 % 5, index2 % 5 length = abs(length2 - length1) if length1 &gt; length2: char1, char2 = table[index1 - length], table[index2 + length] else: char1, char2 = table[index1 + length], table[index2 - length] translated.append(char1 + char2) return ''.join(translated)print(encryptPlayFair('I love you.', 'Sliver')) 输出结果为： 1VIQLVZNW 对密文进行解密： 123456789101112131415161718192021222324252627282930313233343536373839def decryptPlayFair(message, key, dup=0): '''对密文使用密钥进行解密''' # 大部分思路与加密相同 messageGroups = list(zip(*([iter('VIQLVZNW')] * 2))) table = createTable(key, dup) translated = [] for a, b in messageGroups: index1, index2, flag = table.index(a), table.index(b), False ranged = list(map(list, zip(*([iter(range(25))] * 5)))) for group in ranged: if index1 in group and index2 in group: flag = True if (index2 - index1) % 5 == 0: char1, char2 = table[(index1 - 5) % 25], table[(index2 - 5) % 25] elif flag: if index1 in &#123;0, 5, 10, 15, 20&#125;: char1, char2 = table[index1 + 4], table[index1 - 1] elif index2 in &#123;0, 5, 10, 15, 20&#125;: char1, char2 = table[index1 - 1], table[index2 + 4] else: char1, char2 = table[index1 - 1], table[index2 - 1] else: length1, length2 = index1 % 5, index2 % 5 length = abs(length2 - length1) if length1 &gt; length2: char1, char2 = table[index1 - length], table[index2 + length] else: char1, char2 = table[index1 + length], table[index2 - length] translated.append(char1 + char2) return ''.join(translated)print(decryptPlayFair('VIQLVZNW', 'Sliver')) 输出结果为： 1ILOVEYOU 换位加密法以上的加密法，其实都是将字母进行移位或替换来进行加密的。而换位加密法不是把字符替换成其他字符，而是搞乱消息符号的顺序，使原来的消息不可读。 从最简单的换位加密法来说，我们可以先拿 Common sense is not so common. 这个明文进行练手。在这里，先选择一个数字密钥 8。 我们创建一个 4 行 8 列的明文表格，这是根据 row = len(message) // key + 1; col = key 得出的，不全的地方不填充： C o m m o n s e n s e i s n o t s o c o m m o n . ✖️ ✖️ 根据表格，我们选择每一列的字母，再见每一列的字母拼接，就是我们加密好的密文了，即 Cenoonommstmme oo snnio. s s c。 解密时，只需要将刚才的表格反转一下，再按列取字母拼接即可： C e n o o n o m m s t m m e o o s n n i o . s ✖️ s c ✖️ 可得到明文为：Common sense is not so common. 加密代码实现： 123456789101112131415def TranspositionEncrypt(message, key): ''' message: 明文 key: 密钥（推荐是小于明文一半长度的数字） ''' cipherrext = [''] * key # 创建密文列表，里面包含 key 个列，先用空字符初始化 for col in range(key): index = col while index &lt; len(message): cipherrext[col] += message[index] # 相当与构建了 key 列 (len(message) // key + 1) 行的二维表格，每次取同一列的数据 index += key return '[' + ''.join(cipherrext) + ']' # 防止看不清尾部可能存在的空格，所以加上中括号进行包围print(TranspositionEncrypt('When I see you again.', 8))print(TranspositionEncrypt('Common sense is not so common.', 8)) 输出结果为： 12[Wegheae inyn o.Iu sa][Cenoonommstmme oo snnio. s s c] 解密代码实现： 1234567891011121314151617def TranspositionDecrypt(message, key): ''' message: 密文 key: 密钥（推荐是小于明文一半长度的数字） ''' numOfColumns, numOfRows = len(message) // key + 1, key numOfShadedBoxex = numOfColumns * numOfRows - len(message) plaintext = [''] * numOfColumns col, row = 0, 0 for symbol in message: plaintext[col] += symbol col += 1 if (col == numOfColumns) or (col == numOfColumns - 1 and row &gt;= numOfRows - numOfShadedBoxex): row, col = row + 1, 0 return ''.join(plaintext)print(TranspositionDecrypt('Wegheae inyn o.Iu sa', 8)) 输出结果为： 12When I see you again.Common sense is not so common. 也可以根据给定的置换进行换位加密，比如给定一个置换密钥对明文 Hide the gold in the tree stump. 进行加密： 1 2 3 4 5 6 7 8 2 5 8 6 1 3 7 4 首先需要将明文按照密钥的长度进行分组，即每组八个，不足八个就拿一开始的字母去凑，比如上面的明文可以整理成 [&#39;Hide the&#39;] [&#39; gold in&#39;] [&#39; the tre&#39;] [&#39;e stump.&#39;] 四组。 根据所给的置换密钥，对第一组数据，相当于是让原本是位置是第二个的字符，现在放在第一个，原本是第五个位置的字符，现在放在第二个…所以 [&#39;Hide the&#39;] 转化为 [&#39;i etHdh&#39;]，[&#39; gold in&#39;] 转化为 [&#39;egdn oi&#39;]。 将所有置换后的字符拼接起来，可以得到加密密文：i etHdhegdn oilt et hre u.mespt 解密时，我们根据密钥求逆置换密钥，也就是： 1 2 3 4 5 6 7 8 5 1 6 8 2 4 7 3 重复分组，分别置换，即可得到明文：Hide the gold in the tree stump. 加密代码实现： 12345678910111213141516171819def PermutationEncrypt(message, key): ''' message: 明文 key: 密钥（是一个数字字符串，里面的数字是连续的，但是位置是打乱的，如'25861374'） ''' newMessage = [char for char in message] # 不想保留其他字符时，可以改成：[char for char in message if char.isalpha()] numOfChars, numOfGroups = len(key), len(newMessage) // len(key) + 1 blanks = numOfGroups * len(key) - len(newMessage) # 计算出分组不足的空间 if blanks &lt; len(key): newMessage += newMessage[:blanks] # 用前面的字母进行补全以完成接下来分组 groups = list(map(list, zip(*[iter(newMessage)] * len(key)))) # 按每组长度为 len(key) 进行分组 temp = [] for group in groups: for index in key: temp.append(group[int(index) - 1]) # 根据置换密钥进行置换加密 return '[' + ''.join(temp) + ']' # 防止看不清尾部可能存在的空格，所以加上中括号进行包围print(PermutationEncrypt('Hide the gold in the tree stump.', key = '25861374'))print(PermutationEncrypt('I hid the gold in the kitchen.', key = '25861374')) 输出结果为： 12[i etHdhegdn oilt et hre u.mespt][ dh Ihti lideg o ei ntkhcn .thIe] 解密代码实现： 123456789101112131415161718192021222324252627def inversePermutation(key): '''根据给定 key 求它的逆置换''' # 先根据给定的 key 创建映射，如 key = '25861374' 时，创建的映射为：&#123;'2': 1, '5': 2, '8': 3, '6': 4, '1': 5, '3': 6, '7': 7, '4': 8&#125; dictMap = &#123;k: v for k, v in zip(key, range(1, len(key) + 1))&#125; # 根据键排序，按上面的例子可以得到：[('1', 5), ('2', 1), ('3', 6), ('4', 8), ('5', 2), ('6', 4), ('7', 7), ('8', 3)] sortedMap = sorted(dictMap.items(), key=lambda x: x[0]) # 得到排序好后的映射的值，也就是逆置换：['5', '1', '6', '8', '2', '4', '7', '3'] inverse = [str(item[1]) for item in sortedMap] return ''.join(inverse) # 将逆转置列表转化为字符串print(inversePermutation('25861374'))def PermutationDecrypt(message, key): ''' message: 密文 key: 密钥（是一个数字字符串，里面的数字是连续的，但是位置是打乱的，如'25861374'） ''' inverseKey = inversePermutation(key) newMessage = list(map(list, zip(*[iter(message)] * len(inverseKey)))) temp = [] for group in newMessage: for index in inverseKey: temp.append(group[int(index) - 1]) return ''.join(temp)print(PermutationDecrypt('i etHdhegdn oilt et hre u.mespt', '25861374'))print(PermutationDecrypt(' dh Ihti lideg o ei ntkhcn .thIe', '25861374')) 输出结果为： 12Hide the gold in the tree stump.I hid the gold in the kitchen.I 因为涉及补全字符的问题，所以输出结果跟原明文相比可能会多出几个字符。 参考资料 百度百科 深入浅出密码学 Python密码学编程 Playfair密码(C语言实现) (密码学)维吉尼亚密码加解密原理及其破解算法Java实现]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tips</tag>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[番茄工作法总结]]></title>
    <url>%2F2018%2F03%2F04%2F%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[“不得不说，这年头，番茄也能让你学会专注。” 什么是番茄工作法？ 番茄工作法是弗朗西斯科•西里洛于1992年创立的。他在大学生活的头几年，曾一度苦于学习效率低下，“于是我和自己打赌，下猛药，狠狠鄙视自己说：‘我能学一会儿习吗？真正学上10分钟？’我得找个计时教练，谁来替我掐表呢？后来我找到了，是一枚厨房定时器，形状像‘西红柿’（Pomodoro ，意大利语的‘番茄’）。就这样，我邂逅了我的番茄钟。” 番茄工作法是一套简单的工具和流程，用以提升你个人和所在团队的生产力，从而做到： 减轻时间焦虑 提升集中力和注意力，减少中断 增强决策意识 唤醒激励和持久激励 巩固达成目标的决心 完善预估流程，精确地保质保量 改进工作学习流程 强化决断力，快刀斩乱麻 什么是番茄钟？它仅仅是一个计时器，用来衡量设定好时间的时间周期。 以 25 分钟为一个番茄钟周期，周期开始时用计时器计时，抛弃脑中的时间焦虑，全身心投入手中的工作中，直到计时器响起，就立刻停止工作。以短时间作为目标，增加工作完成的满足感。每个番茄钟之间用 3~5 分钟的时间进行休息，休息时，要全身心抛开工作任务，让大脑充分吸收过去 25 分钟的脑力震荡。劳逸结合，激发下个番茄钟工作的动力。每 4 个番茄钟结束后应要多休息一会儿，时间设定为 15~30 分钟。 如何制定番茄钟？所需工具：一枚番茄钟，一支铅笔，三张白纸（表格）。 第一张纸（活动清单）：记录近期事务的活动清单，将所有最近需要做的事情（20~30项）都记录在纸上，不分顺序，完成后即可划掉。可几天共用一张 活动清单。 第二张纸（今日待办）：记录今日待办事项。每天的工作开始前，选择活动清单中的事情按照今天的可分配时间放入 今日待办 表格中，并计划好执行这一任务所需的番茄钟数。 第三张纸（记录表格）：在每天工作结束之前需要记录三个方面的信息，以便日后对比改进自己的番茄钟。 1234记录信息：①每日完成的番茄钟数。②早晨未想到后来临时加入的计划外紧急事务。③由于估计的时间不足以完成某一项目标，后来又加上的番茄钟数。 如何执行番茄钟？ 记录近期事务到 活动清单。 每天早晨从 活动清单 中选择待办事项，抄入到 今日待办。 从 今日待办 中选择一项自己觉得最重要的一项活动，开始番茄钟。 番茄钟响铃后，停下工作，休息片刻，并记下一个番茄钟标记。 休息结束，开始下一个番茄钟。 完成后活动后记录，未未完成则放到下个番茄钟去完成或者选择其它时段去完成。 晚上下班前需要总结自己的番茄钟总数、活动完成数和番茄钟进行时的中断数，并添加到 记录表格。 在之后的番茄钟设定和流程执行时，根据 记录表格 进行分析、观察和改进，得到提高。 如何去处理执行中的中断？ 内部中断（自身引起） 可控制中断：如想喝水，需要回复某人电子邮件，突然想到要给谁打电话等。解决方法：接受、记录并继续。把中断记录到今日待办中的 计划外紧急 中，并做标记进行跟踪，然后继续自己的番茄钟。等到后续某个番茄钟完成，才处理这些 计划外紧急 任务。 不可控制中断：如想上厕所，要准时抢票等。解决方法：去完成这些不可控制的中断。但回来时，需要把刚才正在进行的番茄钟作废，而不能继续进行之前的番茄钟。以防养成容易中断的习惯，这将会打乱工作节奏。 外部中断（外界引起） 可延后中断：如电话来访，电子邮件寄来，同事需要与你商讨问题等。解决方法：可以告诉别人现在自己正忙，告诉他想在稍后再与他商量或者打电话，并将这件事记录到今日待办中的 计划外紧急 中，等到之后的某个番茄钟再进行事件处理。 不可延后中断：不可抗力因素事件等。解决方法：处理事件，并报废番茄钟。 小贴士 当一个番茄钟结束后，要立刻停止工作，把对时间的依赖完全交给番茄钟。 在番茄钟内提早完成了任务，应该回顾一下所做的或者重复一下所学的，直到番茄钟结束。 一些琐碎的占用时间少的事情可以放在一个番茄钟内完成。 在休息时间内，就不要想前一个番茄钟或后一个番茄钟的事情。要把握休息时间，劳逸结合。 番茄钟的选择要在休息结束后进行。 每个番茄钟开始后，要选择当前 今日待办 列表中最重要的事，而不一定是上个番茄钟未完成的的事。这样可以确保每次做的事都是有用、高效和重要的。 番茄钟的时间是处理事务时间的最小计量单位，不可拆分。 使用番茄钟时，只要认真专注于要处理的事项即可。而对全局的纵览和思考应该放到早晨的规划中。 晚间和月底，是计量工作效率和得失的好时光。 番茄钟不是一定要设定为 25 分钟，这只是作者在进行大量实践和总结后给的建议时间。使用者可以立足于自身情况对时间进行修改（比如执行番茄钟过程中中断很多，可以适当缩减番茄钟设定时间）。但都要在执行上一次设定的番茄钟周期一段时间（比如两周）后才能确认修改，以便确定它是不是真的适合自己。频繁的更改只会打乱供暖工作节奏，带来不好的影响。毕竟，长期的执行和感受，才能真正判断它是否合适自己。 推荐 番茄工作法图解]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Tomato</tag>
        <tag>Work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python代码风格指南（自译）]]></title>
    <url>%2F2018%2F03%2F03%2FPython%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[“人生苦短，我用 Python。” 英语渣，但就是很想翻译它。 当你询问一个程序员为什么最爱 Python 语言的时候，他们常说它可读性很高。确实，高度的可读性是设计 Python 这门语言的核心。 一个使 Python 代码易读且易理解的原因是 Python 语言相对完善的编码指南和 Pythonic 风格。 并且，当一个经验丰富的 Python 开发者指着一段代码说：“这段代码并不 Pythonic” 的时候，这常常意味着这些代码没有遵循一个普遍的代码准则，没有通过最好的方式表达出它的意图。 虽然在一些极端情况下，关于如何用 Python 代码表达意图的最好方式没有达成共识，但这样的情况是比较少的。 一般概念明确的代码虽然任何类型的魔法方法都可以通过 Python 来实现，但是最明确和最直接的方式往往是最好的。 Bad 123def make_complex(*args): x, y = args return dict(**locals()) Good 12def make_complex(x, y): return &#123;'x': x, 'y': y&#125; 在上面优秀的代码中，函数明确地显式调用 x 和 y, 明确的返回相关字典。开发者通过读第一行和最后一行就可以知道函数的用法。 一行一句尽管在一些复杂语句中，例如 列表生成式 是被允许的，并且这些语句可以展现简洁的表达能力。但将不相关的语句放在同一行是很差的代码风格。 Bad 123456print 'one'; print 'two'if x == 1: print 'one'if &lt;complex comparison&gt; and &lt;other complex comparison&gt;: # do something Good 12345678910print 'one'print 'two'if x == 1: print 'one' cond1 = &lt;complex comparison&gt;cond2 = &lt;other complex comparison&gt;if cond1 and cond2: # do something 函数参数函数的参数可以有四种不同的方式： 1.位置参数位置参数是强制性的，并且它们没有默认值。它们是最简单的参数形式，可以用少量的函数参数，用来表达函数意义的全部部分，而它们的位置顺序是自然的，是被严格要求的。例如，在 send(message, recipient) 或者 point(x, y) 这些函数中，函数的使用者并不会对函数的使用觉得很困难，这些函数仅仅需要两个参数，并按照顺序传入即可。 在这两种情况下，可以在调用函数时使用参数的名称赋值，这样做可以切换参数的顺序，例如调用实例 send(recipient=&#39;World&#39;, message=&#39;Hello&#39;) 和 point(y=2, x=1)，但与直接的调用 send(&#39;Hello&#39;, &#39;World&#39;) 和 point(1, 2) 相比，这会降低可读性并且将会不必要地冗长。 2. 关键字参数关键字参数不是强制性的，并且它们具有默认值。它们通常是用于发送给函数的可选参数。当一个函数有多于两个或者三个位置参数的时候，函数参数样式就很难记忆了。这个时候，使用具有默认值的关键字参数是很有帮助的。例如，一个完整的 send 函数可以定义成 send(message, to, cc=None, bcc=None)，这里的 cc 和 bcc 参数是可选的，当没有传值时默认为 None。 使用关键字参数调用一个函数可以通过 Python 以多种方式完成。例如，可以在定义中遵循参数的顺序，而不必明确命名参数，比如 send(&#39;Hello&#39;, &#39;World&#39;, &#39;Cthulhu&#39;, &#39;God&#39;) 是将密件发送给上帝。我们也可以使用命名参数而无需遵循参数顺序来调用函数，比如 send(&#39;Hello again&#39;, &#39;World&#39;, bcc=&#39;God&#39;, cc=&#39;Cthulhu&#39;)。如果没有任何强有力的理由不去遵循最接近函数定义的语法： send(&#39;Hello&#39;, &#39;World&#39;, cc=&#39;Cthulhu&#39;, bcc=&#39;God&#39;)，那么这两种方式都应该是要极力避免的。 作为一个方面的说明，请遵循 YAGNI 原则。通常，移除一个用作“以防万一”但却看起来从未使用的可选参数（以及它在函数中的逻辑），比添加一个所需的新的可选参数和它的逻辑要来的困难。 3. 任意参数列表任意参数列表是函数传值的第三种方式，如果一个函数意图通过定义可扩展数目的位置参数实现更好的表达，那么可以定义 *args 的结构。在函数体中，args 是包含所有剩余参数的元组。例如，我们可以用任意长度的位置参数作为参数去调用 send(message, *args) 这个函数，比如 send(&#39;Hello&#39;, &#39;God&#39;, &#39;Mom&#39;, &#39;Cthulhu&#39;)。在此函数体中，args 相当于 (&#39;God&#39;,&#39;Mom&#39;, &#39;Cthulhu&#39;)。 尽管如此，这种结构有一些缺点，应谨慎使用。如果一个函数接收到相同性质的参数列表，通常将其定义为一个参数，这样函数为更为清晰，而这个参数可以是一个列表或其他任何序列。在这里，如果 send 参数有多个接受者，将之定义成 send(message, recipients) 会更明确。调用它时就使用 send(&#39;Hello&#39;, [&#39;God&#39;, &#39;Mom&#39;, &#39;Cthulhu&#39;])。这样的话，函数的使用者可以事先将接收者们维护成列表形式，这为传递各种不能被转变成其他序列的序列（包括迭代器）带来了可能。 4. 任意关键字参数字典关键字参数字典是最后一种函数传参的方式，如果函数要求一系列待定的命名参数，我们可以使用 **kwargs 的结构。在函数体中，kwargs 是一个 字典，它包含所有传递给函数但没有被其他关键字参数捕捉的命名参数。 和任意参数列表中所需注意的一样，这些强大的技术是要用在被证明确实需要用到它们的时候，它们不应该被用在能用更简单和更明确的结构就可以充分表达意图的函数中。 编写函数的时候采用何种参数形式，是用位置参数，还是可选关键字参数，是否使用形如任意参数列表等的高级技术，这些都由程序员自己决定的。如果能明智地遵循上面的建议，就可能且非常愉悦地写出这样的 Python 函数： 易读（名字和参数不需要解释） 易改（添加新的关键字参数不会破坏代码的其他部分） 避免魔法方法Python 对黑客来说是一个强有力的工具，它拥有非常丰富的 hooks 和 tools，允许使用者施展几乎任何形式的技巧。比如，它可以做到： 改变对象的创建和初始化的方式 改变 Python 解释器引入模块的方式 在 Python 中嵌入 C 程序代码 然而，这些操作都有着许多缺陷，更好的方式是使用最直接的方式达到目的。这些操作最主要的缺陷在于当使用这些方式时，程序可读性将发生很大改变。许多代码分析工具，例如: pylint 或者 pyflakes 是无法解析这些 &quot;magic&quot; code 的。 Python 开发者应该知道这些近乎无限的可能性，因为它让我们拥有了 没有不可能完成的任务 的自信。但是知道如何，尤其是何时不能使用它们是非常重要的。 一个 Pythonista 就像一位功夫大师，他知道如何用一个手指杀死对方，但他从不会那么去做。 我们都是负责任的用户通过上面知道 Python 有许多的技巧，但其中一些是有潜在危险的。一个好的范例是：任何用户都能够重写对象的属性和方法（Python中没有 “private” 关键字）。这种哲学不同于其他高级语言，如 Java。因为 Java 中有许多防止滥用的机制。而这种哲学其实是在表达： We are all responsible users。 这并不意味着，比如说，Python 中没有属性是私有的，也不意味着没有合适的封装方法。与其依赖在开发者和代码之间树立起的一道道隔墙，Python 社区更愿意依靠一些约定，来表明这些元素不应该被直接访问，而应该是私有的。 私有属性实现细节的主要约定是对所有的 内部变量 前添加一个下划线。如果用户破坏约定去访问前缀带有下划线的变量，当被修改后的代码产生问题时，都是客户端代码的责任。 使用这些约定是被广泛鼓励的：任何不想被客户端代码使用的属性或者方法都应该加上一个前缀下划线。这样可以更好的将代码进行职责划分，也方便对已有的代码进行修改；私有属性公有化总是有可能的，而公有属性私有化可能会是很难的操作。 返回值当一个函数变得复杂时，在函数体中使用有多个返回值的语句并不少见。然而，为了保证明确的意图和可读性，应在函数体中避免使用返回多个值的语句。 在函数中主要有两种返回情况：当函数正常运行时，返回结果；当一个错误的情况产生，返回输入错误的参数，或者其他导致函数不能正常运行的原因。 如果在第二种情况不想抛出异常，应该返回一个值（比如 None 或者 False），指明函数没有正常执行。在这种情况下，最好尽早返回检测到的错误信息。这将有利于后续改善函数的结构。 在正常情况下，当一个函数中有多个返回出口点时，会变得很难去调试和返回结果。所以最好保持单个出口点，这会有助于提取某些代码路径，并且，多个出口点往往意味着代码需要重构了。 1234567891011def complex_function(a, b, c): if not a: return None # Raising an exception might be better if not b: return None # Raising an exception might be better # Some complex code trying to compute x from a, b and c # Resist temptation to return x if succeeded if not x: # Some Plan-B computation of x return x # One single exit point for the returned value x will help # when maintaining the code. 惯用方法编程惯用方法是一种代码编写的方式，Python 的惯用方法通常被称为 Pythonic。 尽管通常有一种（而且最好只有一种）明显的方式去将代码写得 Pythonic；但对 Python 初学者来说，写出惯用法式的 Python 代码的方式是不太明显的。所以，好的惯用法必须有意识地获取。 下面是一些 Python 惯用法： 解包如果你知道一个列表或者元组的长度，你可以将其解包并为它的元素取名。比如，enumerate() 会对列表中的每个项提供包含索引和列表数据两个元素的元组： 12for index, item in enumerate(some_list): # 使用index和item做一些工作 也可以通过这种方式交换两个变量： 1a, b = b, a 嵌套解包任务： 1a, (b, c) = 1, (2, 3) 在 Python3 中，扩展解包的新方法在 PEP 3132 有介绍: 1234a, *rest = [1, 2, 3]# a = 1, rest = [2, 3]a, *middle, c = [1, 2, 3, 4]# a = 1, middle = [2, 3], c = 4 创建一个可忽略的变量如果需要赋值但不需要变量（比如，使用解包方法），可以使用 __： 12filename = 'foobar.txt'basename, __, ext = filename.rpartition('.') 注意： 123许多 Python 风格指南建议使用单下划线而不是双下划线。然而，单下划线普遍在 gettext() 函数中用作别名，也常被用在交互式命令行中保存最后一次操作的值。所以，使用双下划线更清晰方便，并能够消除一些使用情况的干扰。 创建一个长度为 N 且所有元素相同的列表1four_nones = [None] * 4 创建一个长度为 N 的列表因为列表是可变的，* 操作对于同样的列表会创建创建 N 个原列表的引用，这可能不是你想要的结果。正确的写法应该是使用列表生成式： 1four_lists = [[] for __ in xrange(4)] 注意： 1在 Python3 中应该使用 range() 而不是 xrange()。 根据列表来创建字符串根据列表来创建字符串的一个常见用法是在空的字符串上使用 str.join(list)。 12letters = ['s', 'p', 'a', 'm']word = ''.join(letters) 这会将 word 变量赋值为 spam。这个惯用法可以用在列表和元组中。 在序列中查找一个元素有时我们需要在序列中查找元素。让我们来看看这两个选择：列表和集合。 举个例子： 12345678s = set(['s', 'p', 'a', 'm'])l = ['s', 'p', 'a', 'm']def lookup_set(s): return 's' in sdef lookup_list(l): return 's' in l 即使这两个函数看起来完全一样，但因为 lookup_set(s) 是利用了 Python 中的集合类型是 可哈希 的特性，两者的查询性能是完全不同的。为了判断一个项是否在列表中，Python 将会查看每个元素直到它找到匹配的项。这是非常耗时的，尤其是对长列表来说。另一方面，在集合中，项的哈希值将会告诉 Python 应在集合的哪里去查找匹配的元素。结果是，即使集合很大，但因为哈希表的原理，查询的速度也会很快。在字典中，查询也是同样的原理。 因为这些性能上的差异，在下列场合中使用集合或者字典而不是列表，通常会是个好主意： 序列中包含大量的元素 需要在序列中重复地查找元素 序列中没有重复的项 对于小的序列，或者你不会频繁查找的序列，建立哈希所消耗的额外时间和内存开销经常会大过改进搜索速度所节省的时间和内存开销。 Python之禅也被称为 PEP 20，它是 Python 设计的指导准则。 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those!Python之禅 by Tim Peters优美胜于丑陋（Python以编写优美的代码为目标）明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）可读性很重要（优美的代码是可读的）即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）不要包容所有错误，除非您确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）当存在多种可能，不要尝试去猜测而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）虽然这并不容易，因为您不是 Python 之父（这里的 Dutch 是指 Guido ）做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）如果您无法向人描述您的方案，那肯定不是一个好方案；反之亦然（方案测评标准）命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召） 如果想要了解一些具有 Python 风格的例子，可以访问 these slides from a Python user group。 PEP8PEP 8 是 Python 事实上的代码风格指南，我们可以在 pep8.org 上获得高质量的 PEP 8 版本详细介绍。 强烈推荐阅读这部分。整个 Python 社区都尽力遵循本文档中规定的准则。一些项目可能受其影响，而其他项目可以参考修改建议。 也就是说，让你的 Python 代码遵循 PEP 8 通常是个好主意，这也有助于在与其他开发人员一起工作时使代码更加具有可持续性和维护性。命令行程序 pycodestyle（以前叫做 pep8），可以检查代码一致性。可在终端上运行以下命令来安装它： 1$ pip install pycodestyle 然后在文件或者很多文件中运行，如果检测到问题，会得到违反 PEP8 准则的报告 123456789$ pycodestyle optparse.pyoptparse.py:69:11: E401 multiple imports on one lineoptparse.py:77:1: E302 expected 2 blank lines, found 1optparse.py:88:5: E301 expected 1 blank line, found 0optparse.py:222:34: W602 deprecated form of raising exceptionoptparse.py:347:31: E211 whitespace before '('optparse.py:357:17: E201 whitespace after '&#123;'optparse.py:472:29: E221 multiple spaces before operatoroptparse.py:544:21: W601 .has_key() is deprecated, use 'in' 程序 autopep8 能自动将代码格式化成 PEP 8 风格。可用以下指令安装此程序： 1$ pip install autopep8 使用以下命令来格式化一个文件： 1$ autopep8 --in-place optparse.py 不包含 --in-place 标志将会使得程序直接将更改的代码输出到控制台，以供审查。--aggressive 标志则会执行更多实质性的变化，而且可以多次使用以达到更佳的效果。 约定遵循以下的一些约定可以以让您的代码更加易读。 检查变量是否等于常量你不需要明确的与 None、True 或者 0比较，只需要直接使用 if 语句。也可以查阅文档，来查看什么会被判定为 False。 Bad 12345if attr == True: print 'True!'if attr == None: print 'attr is None!' Good 1234567891011# Just check the valueif attr: print 'attr is truthy!'# or check for the oppositeif not attr: print 'attr is falsey!'# or, since None is considered false, explicitly check for itif attr is None: print 'attr is None!' 访问字典元素不要使用 dict.has_key() 方法，使用 x in d 语法或者传入一个默认参数到 dict.get()。 Bad 12345d = &#123;'hello': 'world'&#125;if d.has_key('hello'): print d['hello'] # prints 'world'else: print 'default_value' Good 12345678d = &#123;'hello': 'world'&#125;print d.get('hello', 'default_value') # prints 'world'print d.get('thingy', 'default_value') # prints 'default_value'# Or:if 'hello' in d: print d['hello'] 维护列表的捷径列表生成式提供了强大简洁的列表工作方式。而且，map() 和 filter() 函数是用一种不同且更简洁的语法处理列表。 Bad 123456# Filter elements greater than 4a = [3, 4, 5]b = []for i in a: if i &gt; 4: b.append(i) Good 1234a = [3, 4, 5]b = [i for i in a if i &gt; 4]# Or:b = filter(lambda x: x &gt; 4, a) Bad 1234# Add three to all list members.a = [3, 4, 5]for i in range(len(a)): a[i] += 3 Good 12345678910111213a = [3, 4, 5]a = [i + 3 for i in a]# Or:a = map(lambda i: i + 3, a)Use enumerate() keep a count of your place in the list.a = [3, 4, 5]for i, item in enumerate(a): print i, item# prints# 0 3# 1 4# 2 5 使用 enumerate() 函数比手动维护计数有更好的可读性。而且，它对 迭代器 进行了更好的优化。 读取文件推荐使用 with open 语法来读取文件，它会自动关闭读取的文件。 Bad 1234f = open('file.txt')a = f.read()print af.close() Good 123with open('file.txt') as f: for line in f: print line with 语句更好是因为它总是会去确定你的文件是否关闭，即使在 with 区块中引发了一个异常。 行的延续当一个代码逻辑行长度超过可接受的限度时，需要划分为多行，如果一行最后一个字符是反斜杠 \， Python 解释器会连接下一行。这在一些情况下很有帮助。但是它非常脆弱，应该避免使用：比如在行末反斜杠后加一个空格，可能会破坏代码结构并产生意外的结果。 一个更好的解决方案是在元素周围使用括号。左边以一个未闭合的括号开头，Python 解释器会把行的结尾和下一行连接起来直到遇到闭合的括号。同样的行为适用中括号和大括号。 Bad 123456my_very_big_string = """For a long time I used to go to bed early. Sometimes, \ when I had put out my candle, my eyes would close so quickly that I had not even \ time to say “I’m going to sleep.”"""from some.deep.module.inside.a.module import a_nice_function, another_nice_function, \ yet_another_nice_function Good 12345678my_very_big_string = ( "For a long time I used to go to bed early. Sometimes, " "when I had put out my candle, my eyes would close so quickly " "that I had not even time to say “I’m going to sleep.”")from some.deep.module.inside.a.module import ( a_nice_function, another_nice_function, yet_another_nice_function) 尽管如此，更多时候对于很长的逻辑行并没有进行划分，毕竟试图同时做更多的事情，容易影响可读性。 来源 Code Style]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB学习笔记]]></title>
    <url>%2F2018%2F03%2F02%2FMongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[“It’s mongo, not mango.” 什么是 MongoDB？ MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 MongoDB 基础概念 MongoDB 术语 解释 database 数据库 collection 集合 document 文档 field 域 index 索引 primary key 主键，MongoDB 会自动将 _id 字段设置为主键 MongoDB 数据类型几种常用的数据类型： 数据类型 描述 String 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。 Integer 整型数值。用于存储数值。根据所采用的服务器，可分为 32 位或 64 位。 Boolean 布尔值。用于存储布尔值（真/假）。 Double 双精度浮点值。用于存储浮点值。 Min/Max keys 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。 Array 用于将数组或列表或多个值存储为一个键。 Timestamp 时间戳。记录文档修改或添加的具体时间。 Object 用于内嵌文档。 Null 用于创建空值。 Symbol 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。 Date 日期时间。用 UNIX 时间格式来存储当前日期或时间。也可以指定自己的日期时间：创建 Date 对象，传入年月日信息。 Object ID 对象 ID。用于创建文档的 ID。 Binary Data 二进制数据。用于存储二进制数据。 Code 代码类型。用于在文档中存储 JavaScript 代码。 Regular expression 正则表达式类型。用于存储正则表达式。 相关操作启动 MongoDB 服务 启动 MongoDB 服务器 1$ (sudo) mongod 连接 MongoDB 1$ mongo 权限管理 登录 admin 12&gt; use adminswitched to db admin 创建管理员账户 12345678910&gt; db.createUser(&#123; user: "root", pwd: "xxxxxx", roles: [&#123; role: "userAdminAnyDatabase", db: "admin" &#125;] &#125;)Successfully added user: &#123; "user" : "root", "roles" : [ &#123; "role" : "userAdminAnyDatabase", "db" : "admin" &#125; ]&#125; 验证登录 12&gt; db.auth("root", "xxxxxx")1 修改配置文件 1234&gt; cd /usr/local/etc&gt; vim mongod.confsecurity: authorization: enabled 启动带访问控制的 Mongodb 1&gt; sudo mongod --auth --port 27017 登录管理员账户 12use admin&gt; db.auth("root", "xxxxxx") 创建一个数据库并添加所有者账户 123456789101112&gt; use flaskswitched to db flask&gt; db.createUser(&#123; user: "sliver", pwd: "xxxxxx", roles: [&#123; role: "dbOwner", db: "flask" &#125;] &#125;)Successfully added user: &#123; "user" : "sliver", "roles" : [ &#123; "role" : "dbOwner", "db" : "flask" &#125; ]&#125; 添加具有读写权限的用户 123456789101112&gt; use flaskswitched to db flask&gt; db.createUser(&#123; user: "ariel", pwd: "mm721027", roles: [&#123; role: "readWrite", db: "flask" &#125;] &#125;)Successfully added user: &#123; "user" : "ariel", "roles" : [ &#123; "role" : "readWrite", "db" : "flask" &#125; ]&#125; 登录所有者用户 12345&gt; db.auth("sliveryou", "xxxxxx")1&gt; show tablesusersblog 权限字符 权限字符 描述 Read 允许用户读取指定数据库。 readWriter 允许用户读写指定数据库。 dbAdmin 允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问 system.profile。 userAdmin 允许用户向 system.users 集合写入，也可以在指定数据库里创建、删除和管理用户。 clusterAdmin 只在 admin 数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。 readAnyDatabase 只在 admin 数据库中可用，赋予用户所有数据库的读权限。 readWriteAnyDatabase 只在 admin 数据库中可用，赋予用户所有数据库的读写权限。 userAdminAnyDatabase 只在 admin 数据库中可用，赋予用户所有数据库的 userAdmin 权限。 dbAdminAnyDatabase 只在 admin 数据库中可用，赋予用户所有数据库的 dbAdmin 权限。 root 只在 admin 数据库中可用。超级账号，超级权限。 创建和删除数据库 创建数据库：use DATABASE_NAME 12&gt; use runoobswitched to db runoob 显示当前数据库的名称 12&gt; dbrunoob MongoDB 中默认的数据库为 test，如果没有创建新的数据库，集合将存放在 test 数据库中。 显示所有数据库 123456&gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GBrunoob 0.000GBtest 0.000GB 删除数据库 12&gt; db.dropDatabase()&#123; "dropped" : "runoob", "ok" : 1 &#125; 创建集合并插入文档 向集合中插入文档：db.COLLECTION_NAME.insert(document) 12&gt; db.runoob.insert(&#123;"a": 1, "b": 2&#125;)WriteResult(&#123; "nInserted" : 1 &#125;) 往当前数据库 runoob 新建集合 runoob 并插入数据。 显示所有集合 1234&gt; show tablesfoo&gt; show collectionsfoo 向指定集合插入单个文档 12345&gt; db.foo.insertOne(&#123;"c": 3, "d": 4&#125;)&#123; "acknowledged" : true, "insertedId" : ObjectId("5a996150bcb5714f2f2ec2d9")&#125; 默认将创建 foo 集合。 向指定集合插入多个文档 123456789&gt; db.foo.insertMany([&#123;"A": "a"&#125;, &#123;"B": "b"&#125;, &#123;"C": "c"&#125;])&#123; "acknowledged" : true, "insertedIds" : [ ObjectId("5a8ce79553f8f9f2799791ff"), ObjectId("5a8ce79553f8f9f279979200"), ObjectId("5a8ce79553f8f9f279979201") ]&#125; 根据变量插入文档 1234567891011&gt; document = (&#123;"title": "mongo", "description": "NoSQL", "tags": ["Nice", "SQL"]&#125;)&#123; "title" : "mongo", "description" : "NoSQL", "tags" : [ "Nice", "SQL" ]&#125;&gt; db.foo.save(document)WriteResult(&#123; "nInserted" : 1 &#125;) 删除集合 1234567&gt; db.test.insertOne(&#123;'a': 5&#125;)&#123; "acknowledged" : true, "insertedId" : ObjectId("5a996ad17c2937a1639592ff")&#125;&gt; db.test.drop()true 删除文档 删除所有包含 “H”: 8 键值的文档 12&gt; db.foo.remove(&#123;"H": 8&#125;)WriteResult(&#123; "nRemoved" : 3 &#125;) 删除一个包含 “H”: 8 键值的文档 12&gt; db.foo.remove(&#123;"H": 8&#125;, 1)WriteResult(&#123; "nRemoved" : 1 &#125;) 删除一个包含 “H”: 8 键值的文档 12&gt; db.foo.deleteOne(&#123;"H": 8&#125;)&#123; "acknowledged" : true, "deletedCount" : 1 &#125; 删除所有文档 12&gt; db.foo.deleteMany(&#123;&#125;)&#123; "acknowledged" : true, "deletedCount" : 3 &#125; 更新文档&gt; db.collection.updateOne()即使可能有多个文档通过过滤条件匹配到，但是也最多也只更新一个文档。 &gt; db.collection.updateMany()更新所有通过过滤条件匹配到的文档. &gt; db.collection.replaceOne()即使可能有多个文档通过过滤条件匹配到，但是也最多也只替换一个文档。 &gt; db.collection.update()即使可能有多个文档通过过滤条件匹配到，但是也最多也只更新或者替换一个文档。默认情况下, db.collection.update() 只更新 一个 文档。要更新多个文档，请使用 multi 选项。 文档替换1234567891011121314151617181920212223242526272829&gt; var joe = db.foo.findOne(&#123;"name" : "joe"&#125;)&gt; joe.relationships = &#123;"friends": joe.friends, "enemies": joe.enemies&#125;&#123; "friends" : 32, "enemies" : 2 &#125;&gt; joe&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "joe", "friends" : 32, "enemies" : 2, "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125;&#125;&gt; delete joe.friendstrue&gt; delete joe.enemiestrue&gt; db.foo.update(&#123;"name" : "joe"&#125;, joe)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name" : "joe"&#125;)&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "joe", "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125;&#125; 找到所需数据后赋值给变量，对变量进行修改后，将整个变量当成更新结果进行更新。 1234567891011121314151617&gt; var joe = db.foo.findOne(&#123;"name" : "joe"&#125;)&gt; joe.age = 2020&gt; joe.age++20&gt; db.foo.update(&#123;"name" : "joe"&#125;, joe)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name" : "joe"&#125;)&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "joe", "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125;, "age" : 21&#125; 用相同方法增加年龄数据。 使用 $set 修改器增加键值123456789101112131415161718192021&gt; db.foo.update(&#123;"name" : "joe"&#125;, &#123;"$set":&#123;"work": "teacher"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.updateOne(&#123;"name" : "joe"&#125;, &#123;"$set": &#123;"favorite book": ["Learning Python", "C Programing", "Ruby on Rails"]&#125;&#125;)&#123; "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 &#125;&gt; db.foo.findOne(&#123;"name" : "joe"&#125;)&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "joe", "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125;, "age" : 21, "work" : "teacher", "favorite book" : [ "Learning Python", "C Programing", "Ruby on Rails" ]&#125; 使用 $unset 修改器删除键值1234567891011121314151617&gt; db.foo.update(&#123;"name": "jack"&#125;, &#123;"$unset": &#123;"work": 1&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name": "jack"&#125;)&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "jack", "relationships" : &#123; "friends" : 32, "enemies" : 2, &#125;, "age" : 28, "favorite book" : [ "Learning C++", "C Programing", "Ruby on Rails" ]&#125; 使用 $inc 修改器增加和减少数值12345678910111213141516171819&gt; db.foo.update(&#123;"name": "jack"&#125;, &#123;"$inc": &#123;"age": 1&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.update(&#123;"name": "jack"&#125;, &#123;"$inc": &#123;"age": 2&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name": "jack"&#125;)&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "jack", "relationships" : &#123; "friends" : 32, "enemies" : 2, &#125;, "age" : 31, "favorite book" : [ "Learning C++", "C Programing", "Ruby on Rails" ]&#125; 使用 $push 往数组添加单个元素12&gt; db.foo.update(&#123;"name": "joe"&#125;, &#123;$push: &#123;"favorite book": "Effective Python"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;) 使用 $push 和 $each 往数组添加多个元素12&gt; db.foo.update(&#123;"name": "joe"&#125;, &#123;$push: &#123;"favorite book": &#123;$each: ["Effective C++", "Python Programing"]&#125;&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;) 使用 $addToSet 往数组添加不重复的元素123456789101112131415161718192021&gt; db.foo.update(&#123;"name": "joe"&#125;, &#123;$addToSet: &#123;"favorite book": "Effective Python"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 0 &#125;)&gt; db.foo.findOne(&#123;"name": "joe"&#125;)&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "Learning Python", "C Programing", "Ruby on Rails", "Effective C++", "Python Programing", "Effective Python" ]&#125; 使用 $pull 删除数组内所有指定元素1234567891011121314151617181920&gt; db.foo.update(&#123;"name": "joe"&#125;, &#123;$pull: &#123;"favorite book": "Effective Python"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name": "joe"&#125;)&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "Learning Python", "C Programing", "Ruby on Rails", "Effective C++", "Python Programing" ]&#125; 使用 $pop 删除数组内指定位置的元素（1 代表最后一个元素，-1 代表前面第一个元素）1234567891011121314151617181920&gt; db.foo.update(&#123;"name": "joe"&#125;, &#123;$pop: &#123;"favorite book": 1&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.update(&#123;"name": "joe"&#125;, &#123;$pop: &#123;"favorite book": -1&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name": "joe"&#125;)&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++" ]&#125; 基于位置的数组修改器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&gt; db.foo.update(&#123;"name": "joe"&#125;, &#123;$addToSet: &#123;"favorite book": &#123;"book name": "Effective Python", "language": "Python", "tag": "Fine"&#125;&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name": "joe"&#125;)&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++", &#123; "book name" : "Effective Python", "language" : "Python", "tag" : "Fine" &#125; ]&#125;&gt; db.foo.update(&#123;"name": "joe"&#125;, &#123;$set: &#123;"favorite book.3.tag": "Nice"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name": "joe"&#125;)&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++", &#123; "book name" : "Effective Python", "language" : "Python", "tag" : "Nice" &#125; ]&#125;&gt; db.foo.update(&#123;"favorite book.book name": "Effective Python"&#125;, &#123;$set: &#123;"favorite book.$.tag": "Good"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name": "joe"&#125;)&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++", &#123; "book name" : "Effective Python", "language" : "Python", "tag" : "Good" &#125; ]&#125; upsert 更新指定 update 的第三个参数为 true 即可。当没有找到符合更新条件的文档，将会以该条件新建一个文档。 12345678910111213&gt; db.foo.update(&#123;"name": "sliver"&#125;, &#123;$set: &#123;"work": "student"&#125;&#125;, true)WriteResult(&#123; "nMatched" : 0, "nUpserted" : 1, "nModified" : 0, "_id" : ObjectId("5a8d1e3d2c0bd1e7a6eff789")&#125;)&gt; db.foo.findOne(&#123;"name": "sliver"&#125;)&#123; "_id" : ObjectId("5a8d1e3d2c0bd1e7a6eff789"), "name" : "sliver", "work" : "student"&#125; 更新多个文档指定 update 的第四个个参数为 true 即可或者使用 updateMany() 查找文档 找到集合 foo 中的所有文档 1234&gt; db.foo.find()&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "jack", "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125;, "age" : 31, "favorite book" : [ "Learning C++", "C Programing", "Ruby on Rails" ] &#125;&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++", &#123; "book name" : "Effective Python", "language" : "Python", "tag" : "Good" &#125; ] &#125;&#123; "_id" : ObjectId("5a8d1e3d2c0bd1e7a6eff789"), "name" : "sliver", "work" : "student" &#125; 特定条件查询 12&gt; db.foo.find(&#123;"name": "jack"&#125;)&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "jack", "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125;, "age" : 31, "favorite book" : [ "Learning C++", "C Programing", "Ruby on Rails" ] &#125; 指定需要返回的键值 1234&gt; db.foo.find(&#123;&#125;, &#123;"name": 1, "_id": 0, "relationships": 1&#125;)&#123; "name" : "jack", "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125; &#125;&#123; "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125; &#125;&#123; "name" : "sliver" &#125; 包含特定大小关系的查找比较关系操作符 操作符 解释 $lte 小于等于 $lt 小于 $gte 大于等于 $gt 大于 $eq 等于 $ne 不等于 $in 包含 $nin 不包含 查找年龄在 18 ~ 30 直接的用户 123&gt; db.foo.find(&#123;"age": &#123;$gte: 18, $lte:30&#125;&#125;) // greater than or equel to 18, lower than or equel to 30&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++", &#123; "book name" : "Effective Python", "language" : "Python", "tag" : "Good" &#125; ] &#125;&#123; "_id" : ObjectId("5a8d1e3d2c0bd1e7a6eff789"), "name" : "sliver", "work" : "student", "age" : 20, "relationships" : [ &#123; "friends" : 25, "enemies" : 1, "lovers" : 1 &#125; ] &#125; 查找年龄为 22 或者 职业为 student 的用户 123&gt; db.foo.find(&#123;$or: [&#123;"age": 22&#125;, &#123;"work": "student"&#125;]&#125;)&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++", &#123; "book name" : "Effective Python", "language" : "Python", "tag" : "Good" &#125; ] &#125;&#123; "_id" : ObjectId("5a8d1e3d2c0bd1e7a6eff789"), "name" : "sliver", "work" : "student", "age" : 20, "relationships" : [ &#123; "friends" : 25, "enemies" : 1, "lovers" : 1 &#125; ] &#125; 查找年龄在 18 ~ 30 之间 并且 职业为 student 的用户 12&gt; db.foo.find(&#123;"age": &#123;$gte: 18, $lte:30&#125;, "work": "student"&#125;)&#123; "_id" : ObjectId("5a8d1e3d2c0bd1e7a6eff789"), "name" : "sliver", "work" : "student", "age" : 20, "relationships" : [ &#123; "friends" : 25, "enemies" : 1, "lovers" : 1 &#125; ] &#125; 查找 favorite book 中有 Ruby on Rails 和 C Programing 的用户 123&gt; db.foo.find(&#123;"favorite book": &#123;$in: ["Ruby on Rails", "C Programing"]&#125;&#125;)&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "jack", "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125;, "age" : 31, "favorite book" : [ "Learning C++", "C Programing", "Ruby on Rails" ] &#125;&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++", &#123; "book name" : "Effective Python", "language" : "Python", "tag" : "Good" &#125; ] &#125; 查找 favorite book 中没有 Java 的用户 1234&gt; db.foo.find(&#123;"favorite book" : &#123;$nin: ["Java"]&#125;&#125;)&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "jack", "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125;, "age" : 31, "favorite book" : [ "Learning C++", "C Programing", "Ruby on Rails" ] &#125;&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++", &#123; "book name" : "Effective Python", "language" : "Python", "tag" : "Good" &#125; ] &#125;&#123; "_id" : ObjectId("5a8d1e3d2c0bd1e7a6eff789"), "name" : "sliver", "work" : "student", "age" : 20, "relationships" : [ &#123; "friends" : 25, "enemies" : 1, "lovers" : 1 &#125; ] &#125; null 会匹配某个键的值为 null 的文档，而且还会匹配不包含这个键的文档，查询时需要加上 exists 1&gt; db.foo.find(&#123;"z": &#123;$in: [null], $exists: true&#125;&#125;) 查找数组创建 food 集合： 1234567891011&gt; db.food.insert(&#123;"_id": 1, "fruit": ["apple", "banana", "peach"]&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; db.food.insert(&#123;"_id": 2, "fruit": ["apple", "kumguat", "orange"]&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; db.food.insert(&#123;"_id": 3, "fruit": ["cherry", "banana", "apple"]&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; db.food.find()&#123; "_id" : 1, "fruit" : [ "apple", "banana", "peach" ] &#125;&#123; "_id" : 2, "fruit" : [ "apple", "kumguat", "orange" ] &#125;&#123; "_id" : 3, "fruit" : [ "cherry", "banana", "apple" ] &#125; 找到含有 apple 和 banana 数组的文档 123&gt; db.food.find(&#123;"fruit": &#123;$all: ["apple", "banana"]&#125;&#125;)&#123; "_id" : 1, "fruit" : [ "apple", "banana", "peach" ] &#125;&#123; "_id" : 3, "fruit" : [ "cherry", "banana", "apple" ] &#125; 查询数组特定位置的元素 12&gt; db.food.find(&#123;"fruit.2": "peach"&#125;)&#123; "_id" : 1, "fruit" : [ "apple", "banana", "peach" ] &#125; 插入一个元素： 12&gt; db.food.update(&#123;"_id": 1&#125;, &#123;$addToSet: &#123;"fruit": "mango"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;) 找到 fruit 数组大小为4的文档 12&gt; db.food.find(&#123;"fruit": &#123;$size: 4&#125;&#125;)&#123; "_id" : 1, "fruit" : [ "apple", "banana", "peach", "mango" ] &#125; 找到 fruit 数组大小为3的文档 123&gt; db.food.find(&#123;"fruit": &#123;$size: 3&#125;&#125;)&#123; "_id" : 2, "fruit" : [ "apple", "kumguat", "orange" ] &#125;&#123; "_id" : 3, "fruit" : [ "cherry", "banana", "apple" ] &#125; 返回 fruit 数组最后两个元素 12&gt; db.food.find(&#123;"_id": 1&#125;, &#123;"fruit": &#123;$slice: -2&#125;&#125;)&#123; "_id" : 1, "fruit" : [ "peach", "mango" ] &#125; 返回 fruit 数组前面两个元素 12&gt; db.food.find(&#123;"_id": 1&#125;, &#123;"fruit": &#123;$slice: 2&#125;&#125;)&#123; "_id" : 1, "fruit" : [ "apple", "banana" ] &#125; 返回 fruit 数组索引为2~3的元素 12&gt; db.food.find(&#123;"_id": 1&#125;, &#123;"fruit": &#123;$slice: [2, 2]&#125;&#125;)&#123; "_id" : 1, "fruit" : [ "peach", "mango" ] &#125; 返回 fruit 数组索引为1~2的元素 12&gt; db.food.find(&#123;"_id": 1&#125;, &#123;"fruit": &#123;$slice: [1, 2]&#125;&#125;)&#123; "_id" : 1, "fruit" : [ "banana", "peach" ] &#125; 返回所有文档里 fruit 数组的最后两个元素 1234&gt; db.food.find(&#123;&#125;, &#123;"fruit": &#123;$slice: -2&#125;&#125;)&#123; "_id" : 1, "fruit" : [ "peach", "mango" ] &#125;&#123; "_id" : 2, "fruit" : [ "kumguat", "orange" ] &#125;&#123; "_id" : 3, "fruit" : [ "banana", "apple" ] &#125; 创建 grades 集合： 1234567891011&gt; db.grades.insert(&#123;"_id": 1, "grade": [90, 80 ,70]&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; db.grades.insert(&#123;"_id": 2, "grade": [91, 92 ,89]&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; db.grades.insert(&#123;"_id": 3, "grade": [71, 72 ,79]&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; db.grades.find()&#123; "_id" : 1, "grade" : [ 90, 80, 70 ] &#125;&#123; "_id" : 2, "grade" : [ 91, 92, 89 ] &#125;&#123; "_id" : 3, "grade" : [ 71, 72, 79 ] &#125; 查找 grade 数组包含范围为 (80, 95) 数据的文档 123&gt; db.grades.find(&#123;"grade": &#123;$elemMatch: &#123;$gt: 80, $lt: 95&#125;&#125;&#125;)&#123; "_id" : 1, "grade" : [ 90, 80, 70 ] &#125;&#123; "_id" : 2, "grade" : [ 91, 92, 89 ] &#125; 查找 grade 数组包含范围为 (70, 75) 数据的文档 12&gt; db.grades.find(&#123;"grade": &#123;$elemMatch: &#123;$gt: 70, $lt: 75&#125;&#125;&#125;)&#123; "_id" : 3, "grade" : [ 71, 72, 79 ] &#125; 创建 blog 集合： 1&gt; db.blog.insert(&#123;"content": "article", "comments": [&#123;"author": "joe", "score": 3, "comment": "nice post"&#125;, &#123;"author": "mary", "score": 6, "comment": "terrible post"&#125;, &#123;"author": "joe", "score": 5, "comment": "ok..."&#125;]&#125;) 查找 comments 数组中作者为 author 或者分数大于等于3的文章 12&gt; db.blog.find(&#123;"comments": &#123;$elemMatch: &#123;"author": "joe", "score": &#123;$gte: 3&#125;&#125;&#125;&#125;)&#123; "_id" : ObjectId("5a9aaced52f59c4d6924b177"), "content" : "article", "comments" : [ &#123; "author" : "joe", "score" : 3, "comment" : "nice post" &#125;, &#123; "author" : "mary", "score" : 6, "comment" : "terrible post" &#125;, &#123; "author" : "joe", "score" : 5, "comment" : "ok..." &#125; ] &#125; 通过 $where 使用 JavaScript 函数查询文档 12&gt; db.food.find(&#123;$where: function()&#123;return this._id === 1&#125;&#125;)&#123; "_id" : 1, "fruit" : [ "apple", "banana", "peach", "mango" ] &#125; 游标创建 collection 集合： 1234&gt; for(var i = 0; i &lt; 100; i++) &#123;... db.collection.insert(&#123;"x": i&#125;)... &#125;WriteResult(&#123; "nInserted" : 1 &#125;) 创建并使用游标： 12345&gt; var cursor = db.collection.find();&gt; while (cursor.hasNext()) &#123;... obj = cursor.next();... &#125;&#123; "_id" : ObjectId("5a9ab0b652f59c4d6924b1db"), "x" : 99 &#125; 类似于迭代器： 12&gt; cursor.hasNext()false limit、skip 和 sort 按 _id 逆序 1234&gt; db.food.find().sort(&#123;"_id": -1&#125;)&#123; "_id" : 3, "fruit" : [ "cherry", "banana", "apple" ] &#125;&#123; "_id" : 2, "fruit" : [ "apple", "kumguat", "orange" ] &#125;&#123; "_id" : 1, "fruit" : [ "apple", "banana", "peach", "mango" ] &#125; 按 _id 正序 1234&gt; db.food.find().sort(&#123;"_id": 1&#125;)&#123; "_id" : 1, "fruit" : [ "apple", "banana", "peach", "mango" ] &#125;&#123; "_id" : 2, "fruit" : [ "apple", "kumguat", "orange" ] &#125;&#123; "_id" : 3, "fruit" : [ "cherry", "banana", "apple" ] &#125; 跳过前面的数据从80开始到最后 123456789101112131415161718192021&gt; db.collection.find().skip(80)&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b22c"), "x" : 80 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b22d"), "x" : 81 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b22e"), "x" : 82 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b22f"), "x" : 83 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b230"), "x" : 84 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b231"), "x" : 85 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b232"), "x" : 86 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b233"), "x" : 87 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b234"), "x" : 88 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b235"), "x" : 89 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b236"), "x" : 90 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b237"), "x" : 91 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b238"), "x" : 92 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b239"), "x" : 93 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b23a"), "x" : 94 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b23b"), "x" : 95 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b23c"), "x" : 96 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b23d"), "x" : 97 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b23e"), "x" : 98 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b23f"), "x" : 99 &#125; 跳过前面的数据从80开始，但是限制数量为10个 1234567891011&gt; db.collection.find().skip(80).limit(10)&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b22c"), "x" : 80 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b22d"), "x" : 81 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b22e"), "x" : 82 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b22f"), "x" : 83 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b230"), "x" : 84 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b231"), "x" : 85 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b232"), "x" : 86 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b233"), "x" : 87 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b234"), "x" : 88 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b235"), "x" : 89 &#125; 参考资料 MongoDB 中文手册 MongoDB 官方文档 MongoDB 权威指南]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTerm2常用快捷键]]></title>
    <url>%2F2018%2F03%2F02%2FiTerm2%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[你不能不知道的 iTerm2 技巧。 常用功能快捷键 功能 快捷键 新建标签 command + t 关闭标签 command + w 切换标签 command + 数字 / command + 左右方向键 切换全屏 command + enter 查找 command + f 垂直分屏 command + d 水平分屏 command + shift + d 切换屏幕 command + option + 左右方向键 / command + [ / command + ] 查看历史命令 command + ; 查看剪贴板历史 command + shift + h 清除当前行 ctrl + u 光标到行首 ctrl + a 光标到行尾 ctrl + e 光标前进后退 ctrl + f/b (相当于左右方向键) 上一条命令 ctrl + p 搜索命令历史 ctrl + r 删除当前光标的字符 ctrl + d 删除光标之前的字符 ctrl + h 删除光标之前的单词 ctrl + w 删除光标之后的字符 ctrl + k 交换光标处文本 ctrl + t 清屏 command + r / ctrl + l 常用插件简单配置一些插件，往往能显著提高工作效率。只要在 ~/.zshrc 文件的 plugin 下面添加上想要的插件名称就可以了，并且 oh-my-zsh 自带了很多插件，可以通过 ls ~/.oh-my-zsh/plugins 来查看。 1plugins=(git-extras git mvn svn osx brew brew-cask npm colored-man colorize copydir history sublime command-not-found zsh-syntax-highlighting Z) git：当你处于一个 git 受控的目录下时，shell 会明确显示 git 和 branch，另外对 git 很多命令进行了简化，例如 gco=’git checkout’、gd=’git diff’、gst=’git status’、g=’git’ 等等，熟练使用可以大大减少 git 的命令长度，命令内容可以参考 ~/.oh-my-zsh/plugins/git/git.plugin.zsh。 textmate：mr 可以创建 ruby 的框架项目，tm finename 可以用 textmate 打开指定文件。osx：tab 增强，quick-look filename 可以直接预览文件，man-preview grep 可以生成 grep 手册的 pdf 版本等。 git-extras: Git extras 工具与 zsh 的继承，很方便，在 git 仓库目录下试试 git summary 即可看到整个仓库的汇总信息。 sublime : 此插件能够在终端下使用命令 stt 在 SublimeText 中打开当前文件夹，使用 subl 或者 st 来编辑某个特定文件，比如 st 1.txt，当然前提你得安装了 SublimeText。 zsh-syntax-highlighting: 让终端的每一条命令智能显示颜色，就像在 IDE 里面写代码一样，强烈推荐，安装只需要输入 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 命令再添加 zsh-syntax-highlighting 插件即可。 z : Z is awesome ，让你在不同的目录中快速跳转，比如想访问 ~/work/code/project/testApp，只要是之前访问过，直接输入 z testApp 按 tab 键直接显示完整目录，按 enter 键直接进入当前目录，即使只输入了 z testa 也能完成同样的工作，大大提升效率。 ag: 终端里面快速搜索当前目录下所有文件中所匹配的关键字的命令，类似与 awk，但是速度极快，速度极快，速度极快，使用 brew install，其实就是组件 the_silver_searcher ，详细参考地址 GitHub 。 tree : mac 下的 tree 命令，方便排查问题，直接 brew install tree 即可。 参考 http://blog.csdn.net/ws1352864983/article/details/51512904 https://www.jianshu.com/p/5ec4ba334102]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>iTerm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo自定义Markdown渲染]]></title>
    <url>%2F2018%2F02%2F27%2F%E8%87%AA%E5%AE%9A%E4%B9%89markdown%2F</url>
    <content type="text"><![CDATA[看惯俗粉，不如魔改。 首先需要修改 Hexo 默认的 Markdown 插件，是在 node_modules/hexo-renderer-marked/lib/ 目录下的 renderer.js 文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788'use strict';var marked = require('marked');var assign = require('object-assign');var stripIndent = require('strip-indent');var util = require('hexo-util');var highlight = util.highlight;var stripHTML = util.stripHTML;var MarkedRenderer = marked.Renderer;function Renderer() &#123; MarkedRenderer.apply(this, arguments); this._headingId = &#123;&#125;;&#125;require('util').inherits(Renderer, MarkedRenderer);// Add id attribute to headingsRenderer.prototype.heading = function(text, level) &#123; var id = anchorId(stripHTML(text)); var headingId = this._headingId; // Add a number after id if repeated if (headingId[id]) &#123; id += '-' + headingId[id]++; &#125; else &#123; headingId[id] = 1; &#125; // add headerlink return '&lt;h' + level + ' id="' + id + '"&gt;&lt;a href="#' + id + '" class="headerlink" title="' + stripHTML(text) + '"&gt;&lt;/a&gt;' + text + '&lt;/h' + level + '&gt;';&#125;;function anchorId(str) &#123; // Add support for Chinese return escape(str .replace(/\s+/g, '_') .replace(/\./g, '-') .replace(/-&#123;2,&#125;/g, '-')).replace(/%/g, '_').replace(/^[\-_]+|[\-_]+$/g, '');&#125;marked.setOptions(&#123; langPrefix: '', highlight: function(code, lang) &#123; return highlight(stripIndent(code), &#123; lang: lang, gutter: false, wrap: false &#125;); &#125;&#125;);module.exports = function(data, options) &#123; // return marked(data.text, assign(&#123; // renderer: new Renderer() // &#125;, this.config.marked, options)); var curRender = new Renderer(), markedRenderer = this.markedRenderer; // init function if (markedRenderer &amp;&amp; typeof(markedRenderer.init) == 'function') &#123; markedRenderer.init.call(this, data, options); &#125; // override marked.Render if (markedRenderer) &#123; curRender = assign(curRender, markedRenderer); &#125; // get html content var html = marked(data.text, assign(&#123; renderer: curRender &#125;, this.config.marked, options)); // complete function if (markedRenderer &amp;&amp; typeof(markedRenderer.complete) == 'function') &#123; var tmpHtml = markedRenderer.complete.call(this, html); if (!tmpHtml) &#123; html = tmpHtml; &#125; &#125; return html;&#125;; 修改 module.exports = function(data, options) 后的部分即可，这里附上所有代码，如上。 接下来在所用主题目录 yourtheme/scripts/，创建 marked-renderer.js 并写入: 12345678910111213141516171819202122hexo.markedRenderer = &#123; init: function() &#123; // console.log("hexo.markedRenderer init!"); // Called before rendering &#125;, complete: function(html) &#123; // console.log("hexo.markedRenderer complete!"); // Called after rendered // Deal with html here ... return html; &#125;, image: function(href, title, alt) &#123; // Default method can be accessed via: // this._super.heading(text, level) var orimg = '&lt;img data-original="' + href; if (title) orimg += '" title="' + title; if (alt) orimg += '" alt="' + alt; return orimg + '"&gt;'; &#125;&#125;; 大功告成。感谢 Github 大佬们：https://github.com/helinjiang/hexo-renderer-marked-enhanced。]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python小课堂之命名元组、频度统计和排序技巧]]></title>
    <url>%2F2018%2F02%2F25%2FPython%E5%B0%8F%E8%AF%BE%E5%A0%821%2F</url>
    <content type="text"><![CDATA[写给女朋友的小课堂 One🌟 如何为元组中的每个元素命名，提高程序可读性？我们知道，C 语言中存在结构体，如一个链表节点： 12345typedef struct LNode&#123; ElemType data; struct LNode *next;&#125; LNode; 结构体的引入，使程序的可读性有显著的提高，我们可以使用如 L.data 访问元素。在 Python 中，我们可以使用命名元组来提高程序可读性。 现在，我们来创建一个 Student 命名元组： in[0]: 123456789from collections import namedtuple# 第一个变量是元组名称，第二个参数是一个列表，包含了元组里想要包含的元素 Student = namedtuple('Student', ['name', 'age', 'sex', 'grade'])student1 = Student('Sliver', 20, 'male', 99) # 默认赋值student2 = Student(name='Arial', grade=100, age=18, sex='female') # 通过关键字赋值print(student1)print(student2) out[0]: 12Student(name='Sliver', age=20, sex='male', grade=99)Student(name='Arial', age=18, sex='female', grade=100) 现在我们可以直接通过属性来访问数据，其内存占用不高，比普通元组也只是大了一点，在迭代方面与元组等效。 in[1]: 1234for s in student1: print(s)print()print(student1.name, student1.age, student1.sex, student1.grade); print() out[1]: 123456Sliver20male99Sliver 20 male 99 如何统计序列中元素出现的频度？我们先创建一个在[0, 20]之间数量为30个的随机列表，这样肯定会有重复的元素： in[0]: 1234import randoml1 = [random.randint(0, 20) for i in range(30)] print(l1) out[0]: 1[2, 12, 7, 11, 14, 7, 7, 6, 16, 18, 19, 5, 9, 5, 9, 9, 10, 16, 20, 9, 2, 7, 12, 16, 5, 16, 1, 14, 14, 19] 我们想知道每个数据出现的次数，比如2出现了5次，3出现了2次等，这样其实很符合字典的构造，因为字典其实就是一个 key-value 形式，如 {2: 5, 3:2} 可以表示2出现了5次，3出现了2次。现在我们来根据这个思路来统计出现次数，也就是频度： in[1]: 12data = dict.fromkeys(l1, 0) print(data) dict.fromkeys() 是字典对象的一个方法，第一个参数是要取键值的序列，第二个参数是默认让每个键对应的值，这里我们选0进行赋值，因为字典不允许有重复的键，这样我们也就把序列中的唯一元素都取了出来。 PS: 字典的键的定义是不是和集合很像？所以他们都是用{}表示~ out[1]: 1&#123;2: 0, 12: 0, 7: 0, 11: 0, 14: 0, 6: 0, 16: 0, 18: 0, 19: 0, 5: 0, 9: 0, 10: 0, 20: 0, 1: 0&#125; 这个时候我们遍历原来的序列，为之前创建的data字典加1。为什么呢？因为遍历原来的序列，如果碰到相同的就加1，也就相当于计算了这个元素在原来序列中的个数了。 in[2]: 123for x in l1: data[x] += 1 print(data) out[2]: 1&#123;2: 2, 12: 2, 7: 4, 11: 1, 14: 3, 6: 1, 16: 4, 18: 1, 19: 2, 5: 3, 9: 4, 10: 1, 20: 1, 1: 1&#125; 但是如果要找频度最高的元素，就又要重新遍历得到的字典了，数据很大的时候，这样的效率并不高： in[3]: 12for kv in sorted(data.items(), key=lambda x: x[1], reverse=True)[0:3]: print('频度排名前三的键值对：',kv) out[3]: 123频度排名前三的键值对： (7, 4)频度排名前三的键值对： (16, 4)频度排名前三的键值对： (9, 4) 这里介绍一下 sort() 函数： 它的第一个参数是一个可迭代的序列，reverse=True 代表的是从高到低排序，默认是从低到高排。key 参数接受一个函数，有点像 map 和 filter，都需要给它一个函数，key 是给 sorted 一个排序的参考点，也就是告诉sorted，我们要按照哪个值排序。 data.items() 返回的是一个类似元组的结果，也就是我们的键值是这样返回来的：(k, v)我们要对它排序，是按照 k 的大小排呢？还是按照 v 的大小排呢？ 如果让 kv = (k, v), 那么 kv[0] 就代表了 k, kv[1] 代表了 v。 key=lambda x: x[1] 就是代表我们按照 kv[1] 也就是值的大小进行排序。 相比前面这么多的代码量，倒是有更加简洁的代码，运行效率不高，却也不失为 Pythonic。 in[4]: 123temp = &#123;x for x in l1&#125;d1 = &#123;k: l1.count(k) for k in temp&#125; # 可以简洁地得出每个数据的频度print(d1); print() out[4]: 1&#123;1: 1, 2: 2, 5: 3, 6: 1, 7: 4, 9: 4, 10: 1, 11: 1, 12: 2, 14: 3, 16: 4, 18: 1, 19: 2, 20: 1&#125; 不要害怕，还有另一个方法： in[5]: 123456from collections import Counter# Python 内置模块 collections 包含了统计频度的 Counter 对象c = Counter(l1)print(c); print()print(type(c)) # 它是一个Counter对象，但更加直观 out[5]: 123Counter(&#123;7: 4, 16: 4, 9: 4, 14: 3, 5: 3, 2: 2, 12: 2, 19: 2, 11: 1, 6: 1, 18: 1, 10: 1, 20: 1, 1: 1&#125;)&lt;class 'collections.Counter'&gt; Counter 对象的 most_common() 方法可以返回频度排名由高到低的列表，列表里面包含了键值对元组。现在我们来得到频度排名前3的键值对： in[6]: 12print(c.most_common(3)); print()# 得到频度排名前5的键值对print(c.most_common(5)) out[6]: 123[(7, 4), (16, 4), (9, 4)][(7, 4), (16, 4), (9, 4), (14, 3), (5, 3)] 我们可以试着随便统计一下一堆字符串中单词的频度了： in[7]: 1234567891011121314poem = '''Down by the salley gardens my love and I did meet; She passed the salley gardens with little snow-white feet.She bid me take love easy, as the leaves grow on the tree;But I being young and foolish, with her would not agree.In a field by the river my love and I did stand,And on my leaning shoulder she laid her snow-white hand.She bid me take life easy, as the grass grows on the weirs;But I was young and foolish, and now i m full of tears.'''import repoem_list = re.split('\s+', poem) # re.split() 方法按照空字符去拆分字符串print(Counter(poem_list)) out[7]: 1Counter(&#123;'the': 7, 'and': 5, 'I': 4, 'my': 3, 'love': 3, 'She': 3, 'on': 3, '': 2, 'by': 2, 'salley': 2, 'gardens': 2, 'did': 2, 'with': 2, 'snow-white': 2, 'bid': 2, 'me': 2, 'take': 2, 'easy,': 2, 'as': 2, 'But': 2, 'young': 2, 'foolish,': 2, 'her': 2, 'Down': 1,'meet;': 1, 'passed': 1, 'little': 1, 'feet.': 1, 'leaves': 1, 'grow': 1, 'tree;': 1, 'being': 1, 'would': 1, 'not': 1, 'agree.': 1,'In': 1, 'a': 1, 'field': 1, 'river': 1, 'stand,': 1, 'And': 1, 'leaning': 1, 'shoulder': 1, 'she': 1, 'laid': 1, 'hand.': 1, 'life': 1, 'grass': 1, 'grows': 1, 'weirs;': 1, 'was': 1, 'now': 1, 'i': 1, 'm': 1, 'full': 1, 'of': 1, 'tears.': 1&#125;) 如何根据字典中值的大小，对数据项进行排序？我们可以用sorted()函数先对一个列表进行排序: in[0]: 123l1 = [random.randint(0,40) for i in range(20)]print(sorted(l1)) # 从小到大输出print(sorted(l1, reverse=True)) # 从大到小输出 out[0]: 12[4, 5, 6, 8, 10, 10, 13, 17, 20, 22, 22, 22, 26, 28, 30, 31, 33, 35, 35, 35][35, 35, 35, 33, 31, 30, 28, 26, 22, 22, 22, 20, 17, 13, 10, 10, 8, 6, 5, 4] 现在我们创建一个学生成绩字典： in[1]: 12d1 = &#123;name: random.randint(40,100) for name in 'ABCDEFGHIJ'&#125; # 字典生成式print(d1) out[1]: 1&#123;'A': 87, 'B': 67, 'C': 68, 'D': 76, 'E': 91, 'F': 53, 'G': 54, 'H': 61, 'I': 48, 'J': 51&#125; 试试sorted()进行排序： in[2]: 1print(sorted(d1)) out[2]: 1['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'] 默认将键进行了排序，那该怎么让它根据值进行排序呢？ in[3]: 1print(sorted(d1.items(), key=lambda items:items[1])) out[3]: 1[('I', 48), ('J', 51), ('F', 53), ('G', 54), ('H', 61), ('B', 67), ('C', 68), ('D', 76), ('A', 87), ('E', 91)] 给 reverse 参数赋值，进行从大到小排序: in[4]: 1print(sorted(d1.items(), key=lambda items:items[1] ,reverse=True)) out[4]: 1[('E', 91), ('A', 87), ('D', 76), ('C', 68), ('B', 67), ('H', 61), ('G', 54), ('F', 53), ('J', 51), ('I', 48)] 试试zip，思考为什么这样就可以排序了？ in[5]: 1print(sorted(zip(d1.values(), d1.keys()), reverse=True)) out[5]: 1[(91, 'E'), (87, 'A'), (76, 'D'), (68, 'C'), (67, 'B'), (61, 'H'), (54, 'G'), (53, 'F'), (51, 'J'), (48, 'I')]]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Battle Ship]]></title>
    <url>%2F2018%2F02%2F25%2FBattleShip%2F</url>
    <content type="text"><![CDATA[少年，你，想不想成为一个 Captain 呢？ 标题误导向 hhh。 前段时间学习了 JavaScript 这门语言，相比于 Python，它也是有很多优点的。结合之前看的 Head First HTML &amp; CSS 这本书，我写了一个普通的小游戏，仅为娱乐。 游戏规则： 有一个 7 * 7 的航海区域，敌方有三艘潜艇潜伏其中，每艘潜艇占据三格长度，它可能是竖着潜伏，也有可能是横着潜伏。我方有很多炮弹鱼雷，但希望在尽量少的发射次数下，击沉敌方三艘潜艇。 击沉条件： 因为潜艇占据三格长度，所以需要将炮弹击打在潜艇的三个部位才能将其击沉，重复击打是无效的。 温馨提醒： 请多多注意左上角的提示。 游戏有彩蛋，懂前端的一定能到找到。 ⚡️Battle Start⚡️]]></content>
      <categories>
        <category>娱乐</category>
      </categories>
      <tags>
        <tag>Game</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0021 Merge Two Sorted Lists]]></title>
    <url>%2F2018%2F02%2F25%2F0021-Merge-Two-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[21. Merge Two Sorted Lists Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: 12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Analysis: 看到这道题有似曾相识的感觉，其实就是当初上数据结构，老师讲了半天的链表合并题，印象很深刻，所以还原了一下他说的算法，代码虽然很丑很长，但是时间效率还是挺高的 O(m+n)。当然，这道题用递归来解决会更加的简便，因为给我们的两个链表是已经排序好的，如果当前l1的节点的值比l2的节点的值大，就将两个节点交换，要注意的是，这样的交换会将节点指向的后续节点也一起交换了，然后递归判断后续节点直到遍历结束，返回结果。 Answer: 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ output = ListNode(0) temp = output while l1 and l2: if l1.val &gt; l2.val: temp.next = ListNode(0) temp.next.val, l2 = l2.val, l2.next temp = temp.next elif l1.val &lt; l2.val: temp.next = ListNode(0) temp.next.val, l1 = l1.val, l1.next temp = temp.next else: temp.next = ListNode(0) temp.next.next = ListNode(0) temp.next.val, temp.next.next.val= l1.val, l1.val temp, l1, l2 = temp.next.next, l1.next, l2.next if l1: temp.next = ListNode(0) temp.next.next = ListNode(0) temp.next.val = l1.val temp.next.next = l1.next elif l2: temp.next = ListNode(0) temp.next.next = ListNode(0) temp.next.val = l2.val temp.next.next = l2.next return output.next Answer 2: 123456789101112131415161718# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if l1 and l2: if l1.val &gt; l2.val: l1, l2 = l2, l1 l1.next = self.mergeTwoLists(l1.next, l2) return l1 or l2]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0020 Valid Parentheses]]></title>
    <url>%2F2018%2F02%2F25%2F0020-Valid-Parentheses%2F</url>
    <content type="text"><![CDATA[20. Valid Parentheses Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. The brackets must close in the correct order, &quot;()&quot; and &quot;()[]{}&quot; are all valid but &quot;(]&quot; and &quot;([)]&quot; are not. Analysis: 在这里，我们可以把列表当成栈来使用，然后遍历字符串且不断 push 数据到栈中，在插入数据后要判断当前栈顶两个元素能否构成合法的括号表达式，如果可以，就把这两个元素都 pop 出栈，当循环结束后，如果整个字符串是合法的，栈必为空，否则是非法的。Answer 1 我是将数据插入列表后再判断是否合法，合法会 pop 两次数据，有点浪费时间和空间，所以 Answer 2 改成插入前就判断数据是否合法，合法就不插入数据，直接 pop 一次数据。当然也看到高人的答案，具体请看 Answer 3。 Answer 1: 1234567891011121314class Solution: def isValid(self, s): """ :type s: str :rtype: bool """ stack = [] d = ['()', '&#123;&#125;', '[]'] for char in s: stack.append(char) if len(stack) &gt;= 2 and (stack[-2] + stack[-1]) in d: stack.pop() stack.pop() return not stack Answer 2: 12345678910111213141516class Solution: def isValid(self, s): """ :type s: str :rtype: bool """ if len(s) % 2 != 0: return False d = &#123;')':'(', '&#125;':'&#123;', ']':'['&#125; stack = [] for char in s: if stack and (char in d and stack[-1] == d[char]): stack.pop() else: stack.append(char) return not stack Answer 3: 123456789class Solution: def isValid(self, s): """ :type s: str :rtype: bool """ while "()" in s or "&#123;&#125;" in s or "[]" in s: s = s.replace("()","").replace("&#123;&#125;","").replace("[]","") return not s]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0019 Remove Nth Node From End of List]]></title>
    <url>%2F2018%2F02%2F25%2F0019-Remove-Nth-Node-From-End-of-List%2F</url>
    <content type="text"><![CDATA[19. Remove Nth Node From End of List Given a linked list, remove the nth node from the end of list and return its head. For example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid.Try to do this in one pass. Analysis: 思路很简单，直接遍历整个链表得到长度 length，令 flag = length - n，这就是我们需要到达删除的位置的循环次数，如果为0，说明要删除的是头节点，直接返回 head.next即可，不为0时，要循环链表到低要删除的位置的前一个位置，改变指针指向节点即可。 Answer: 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ p, q, length = head, head, 0 while p: p = p.next length += 1 flag = length - n if flag == 0: return head.next while flag &gt; 1 : q = q.next flag -= 1 q.next = q.next.next return head]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0018 4Sum]]></title>
    <url>%2F2018%2F02%2F25%2F0018-4Sum%2F</url>
    <content type="text"><![CDATA[18. 4Sum Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. 12345678For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] Analysis: 本题思路与15题 3Sum 相同，因为多了一个数求和，所以需要多枚举一个数，也就多了一个循环，其余解法同15题，排序后只需要不断移动首尾两个指针，碰到重复的数跳过循环即可。 Answer: 123456789101112131415161718192021222324252627282930class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ nums.sort() output, length = [], len(nums) for i in range(0, length): if i and nums[i] == nums[i - 1]: continue for j in range(i + 1, length): if j != i + 1 and nums[j] == nums[j - 1]: continue sum = target - nums[i] - nums[j] start, end = j + 1, length - 1 while start &lt; end: if nums[start] + nums[end] &gt; sum: end -= 1 elif nums[start] + nums[end] &lt; sum: start += 1 else: output.append([nums[i], nums[j], nums[start], nums[end]]) start, end = start + 1, end - 1 while start &lt; end and nums[start] == nums[start - 1]: start += 1 while start &lt; end and nums[end] == nums[end + 1]: end -= 1 return output]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0017 Letter Combinations of a Phone Number]]></title>
    <url>%2F2018%2F02%2F25%2F0017-Letter-Combinations-of-a-Phone-Number%2F</url>
    <content type="text"><![CDATA[17. Letter Combinations of a Phone Number Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. 12Input:Digit string &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. Analysis: 考察的就是映射和排列组合，通过三层循环再不断更新组合列表即可。需要注意的有效数字只有 2~9，构造这个范围内的数字映射即可。 Answer: 12345678910111213141516class Solution: def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ map = &#123;'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'&#125; combinations = [''] if digits else [] for digit in digits: new_combinations = [] for letter in map[digit]: for combination in combinations: new_combinations.append(combination + letter) combinations = new_combinations return combinations]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0016 3Sum Closest]]></title>
    <url>%2F2018%2F02%2F25%2F0016-3Sum-Closest%2F</url>
    <content type="text"><![CDATA[16. 3Sum Closest Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. 123For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Analysis: 本题类似于15题，所以大部分代码和思路与15题相似，但是因为这次的 target 不是准确值，所以 while 循环内要比较三个数的和与 target 的大小关系，根据大小关系移动 start 和 end 指针，并在循环内根据 abs(sums - target) &lt; abs(output - target) 更新最接近的 target 的和，直到循环结束。 Answer: class Solution: def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ nums.sort() length, output= len(nums), None for i in range(length): if i &gt; 0 and nums[i] == nums[i - 1]: continue start, end = i + 1, length - 1 while start &lt; end: sums = nums[i] + nums[start] + nums[end] if sums &lt;= target: start += 1 else: end -= 1 if output is None or abs(sums - target) &lt; abs(output - target): output = sums return output]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0015 3Sum]]></title>
    <url>%2F2018%2F02%2F25%2F0015-3Sum%2F</url>
    <content type="text"><![CDATA[15. 3Sum Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 1234567For example, given array S = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] Analysis: 本道题一开始的思路是将在列表中取出3个数形成一个组合的结果全部列出来，再得到元素和为0的组合，如 Answer 1，不出所料超时了。换种思路，a + b + c = 0，其实也就是 0 - a = b + c，如果先将这个整数列表升序排序，在 for 循环中，令 target = 0 - nums[i]，我们设两个指针 start， end，根据两个指针对应的值的结果来调整指针的位置，也就可以解决问题了。需要注意的是，列表中相邻的两个元素如果相等，要选择跳过，这样会更加省时间。 Answer 1: 123456789101112# Time Limit Exceededclass Solution: def threeSum(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; from itertools import combinations nums.sort() temp = list(set([x for x in combinations(nums, 3) if sum(x) == 0])) output = [list(x) for x in temp] return(output) Answer 2: 1234567891011121314151617181920212223242526class Solution: def threeSum(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; nums.sort() length, output= len(nums), [] for i in range(length): if i &gt; 0 and nums[i] == nums[i - 1]: continue target = 0 - nums[i] start, end = i + 1, length - 1 while start &lt; end: if nums[start] + nums[end] &gt; target: end -= 1 elif nums[start] + nums[end] &lt; target: start += 1 else: output.append([nums[i], nums[start], nums[end]]) start, end = start + 1, end - 1 while start &lt; end and nums[end] == nums[end + 1]: end -= 1 while start &lt; end and nums[start] == nums[start - 1]: start += 1 return output]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0014 Longest Common Prefix]]></title>
    <url>%2F2018%2F02%2F25%2F0014-Longest-Common-Prefix%2F</url>
    <content type="text"><![CDATA[14. Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. Description: 题目给的描述有点不清晰的感觉，这里给出讨论区好心人的例子和描述。总体来说，是求出一组字符串中每个字符串的前缀公共子串，也就是求公共键问题。 It seems that it is not to check between pair of strings but on all the strings in the array. For example: {“a”,“a”,“b”} should give “” as there is nothing common in all the 3 strings. {“a”, “a”} should give “a” as a is longest common prefix in all the strings. {“abca”, “abc”} as abc {“ac”, “ac”, “a”, “a”} as a. Logic goes something like this: Pick a character at i=0th location and compare it with the character at that location in every string. If anyone doesn’t have that just return “” Else append that character in to the result. Increment i and do steps 1-3 till the length of that string. return result. Analysis: 将 strs 序列解包后再用 zip，我们可以将各个字符串里面的字符一一对应，每个字符串的第一个字符将会构成一个元组，每个字符串的第二个字符也会构成一个元组…因此我们可以根据集合的性质，将每个位置的元组转化为集合，如果集合的长度为1，说明这个位置的字符都是相同的，即可说明这是一个公共字符，不断循环直到遍历完数组或者找到集合长度大于1也就是不存在相同字符的位置，返回结果。 Answer 1: 12345678910111213class Solution: def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ if not strs: return "" for i, group in enumerate(zip(*strs)): if len(set(group)) &gt; 1: return strs[0][:i] else: return min(strs) 在本题中，公共键其实是包含在最短的字符串中的，我们只需要找到最短的字符串，并让其他字符串的字符与其比较即可。 Answer 2: 1234567891011121314class Solution: def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ if not strs: return "" shortstr = min(strs, key=len) for i, char in enumerate(shortstr): for otherstr in strs: if otherstr[i] != char: return shortstr[:i] return shortstr]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0013 Roman to Integer]]></title>
    <url>%2F2018%2F02%2F25%2F0013-Roman-to-Integer%2F</url>
    <content type="text"><![CDATA[13. Roman to Integer Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Analysis: 罗马数字的符号一共只有7个： I - 1 V - 5 X - 10 L - 50 C - 100 D - 500 M - 1000 运算规则（右加左减）：在一个较大的罗马数字的右边记上一个较小的罗马数字，表示大数字加小数字。在一个较大的数字的左边记上1个较小的罗马数字，表示大数字减小数字。并且，1个罗马数字重复几次，就表示这个数的几倍。 但是左减不能跨越一个位数。比如，99 不可以用 IC 表示，而是用 XCIX 表示。此外，左减数字不能超过1位，比如8写成 VIII，而非 IIX。并且左键减数字有限制，只能是 I、X、C。同理，右加数字不能超过3位，比如14写成 XIV，而非 XIIII。 罗马数字规则罗马数字1-100对照表 综上所述，给定一个罗马数字，循环时，如果 s[i] &lt;= s[i - 1]，可直接将 s[i] 加到 output 中，如果 s[i] &gt; s[i - 1]，就需要加上 s[i] 再减去两个 s[i - 1]，因为在上一次循环，已经加上了 s[i - 1]。 Answer: 1234567891011121314class Solution: def romanToInt(self, s): """ :type s: str :rtype: int """ d = &#123;'I': 1,'V': 5,'X': 10,'L': 50,'C': 100,'D': 500,'M': 1000&#125; output = 0 for i in range(len(s)): if i &gt; 0 and d[s[i]] &gt; d[s[i - 1]]: output += d[s[i]] - 2 * d[s[i - 1]] else: output += d[s[i]] return output]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0012 Integer to Roman]]></title>
    <url>%2F2018%2F02%2F25%2F0012-Integer-to-Roman%2F</url>
    <content type="text"><![CDATA[12. Integer to Roman Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Analysis: 罗马数字的符号一共只有7个： I - 1 V - 5 X - 10 L - 50 C - 100 D - 500 M - 1000 运算规则（右加左减）：在一个较大的罗马数字的右边记上一个较小的罗马数字，表示大数字加小数字。在一个较大的数字的左边记上1个较小的罗马数字，表示大数字减小数字。并且，1个罗马数字重复几次，就表示这个数的几倍。 但是左减不能跨越一个位数。比如，99 不可以用 IC 表示，而是用 XCIX 表示。此外，左减数字不能超过1位，比如8写成 VIII，而非 IIX。并且左键减数字有限制，只能是 I、X、C。同理，右加数字不能超过3位，比如14写成 XIV，而非 XIIII。 罗马数字规则罗马数字1-100对照表 想实现算法时，发现只用上面提到的七个字符来当基准数是有点麻烦的，应该要再增加几个基准数。根据罗马数字运算规则，可以知道减法出现的情况是 IV - 4; IX - 9; XL - 40; XC - 90; CD - 400; CM - 900，我们将这些数字添加到基准数中，实现算法时，就只需考虑加法的情况了。 考虑到第一个答案要两层 while 循环，想能提高效率，所以第二个答案改成一个 for 循环。 Answer 1: 12345678910111213141516class Solution(object): def intToRoman(self, num): """ :type num: int :rtype: str """ n = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] d = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'] output, i, count = '', 0, 0 while num &gt; 0: count, num = divmod(num, n[i]) # count = num // n[i]; num = num % n[i] while count &gt; 0: output += d[i] count -= 1 i += 1 return output Answer 2: 12345678910111213class Solution(object): def intToRoman(self, num): """ :type num: int :rtype: str """ nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] dicts = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'] output = "" for n, d in zip(nums, dicts): output += d * (num // n) num %= n return output]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0011 Container With Most Water]]></title>
    <url>%2F2018%2F02%2F25%2F0011-Container-With-Most-Water%2F</url>
    <content type="text"><![CDATA[11. Container With Most Water Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. Analysis: 图片来源：NapoleonY 本题场景可以模拟成两块木板加上任意调节的板底构成装水的容器，容器高度就像短板原理，与最短的板的高度有关，板底长度与两板之间的距离有关，为了得到装最多水的容器，应使两板的高度尽量大，两板的距离尽量长。所以我们可以设置首尾两个指针，不断向中间扫描，每次都更新最大值，等到结束就可以找到最大值了。 Answer: 1234567891011121314151617class Solution: def maxArea(self, height): """ :type height: List[int] :rtype: int """ start, end = 0, len(height) - 1 output = 0 while start &lt; end: if height[start] &lt; height[end]: area = height[start] * (end - start) start += 1 else: area = height[end] * (end - start) end -= 1 output = max(output, area) return output]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0010 Regular Expression Matching]]></title>
    <url>%2F2018%2F02%2F25%2F0010-Regular-Expression-Matching%2F</url>
    <content type="text"><![CDATA[10. Regular Expression Matching Implement regular expression matching with support for ‘.’ and ‘*’. 12345678910111213141516&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;aa&quot;, &quot;.*&quot;) → trueisMatch(&quot;ab&quot;, &quot;.*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true Analysis: 贯彻不重复造轮子的思想，这道题直接运用 re 模块再加上一些 if 语句是可以直接秒杀的。 Answer: 12345678910111213class Solution: def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ import re result = re.match(p, s) if not result: return False else: return True if result.group() == s else False]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0009 Palindrome Number]]></title>
    <url>%2F2018%2F02%2F25%2F0009-Palindrome-Number%2F</url>
    <content type="text"><![CDATA[9. Palindrome Number Determine whether an integer is a palindrome. Do this without extra space. Some hints: Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. Analysis: 秒杀题，其实将数字转化为字符串再判断回文更快，不过题目要求不能额外申请空间，所以可以先计算翻转后的整数，如果翻转后的整数等于原来的数，就可以判断是回文数。AC 后看了一下 LeetCode 的推荐技巧是只将后面的一半数字回文，然后让前面一半与后面一半进行比较。这个方法很巧妙，于是改写得到新的代码。留意的是负数和末尾有多个0的数肯定不是回文数，所以可以直接排除。 Answer 1: 1234567891011class Solution: def isPalindrome(self, x): """ :type x: int :rtype: bool """ num, compare, x = x, 0, abs(x) while x: compare = compare * 10 + x % 10 x //= 10 return compare == num Answer 2: 12345678910111213class Solution: def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0 or (x != 0 and x % 10 == 0): return False half = 0 while x &gt; half: half = half * 10 + x % 10 x //= 10 return x == half or half // 10 == x]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0008 String to Integer (atoi)]]></title>
    <url>%2F2018%2F02%2F25%2F0008-String-to-Integer%2F</url>
    <content type="text"><![CDATA[8. String to Integer (atoi) Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Requirements for atoi: The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. Analysis: 本题虽然简单，但还是有很多坑的…atoi 函数是 C 中标准库的一个函数，题目要求需要防止数据溢出，且经过测试或者查询 API 可知道，无效的转换都要返回 0。 12345678910int atoi（con​​st char * str）;将字符串转换为整数解析 C 字符串 str，将其内容解释为一个整数，该整数作为类型的值返回 int。该函数首先丢弃尽可能多的空白字符，直到找到第一个非空白字符。然后，从这个字符开始，选择一个可选的初始正号或负号，后面跟随尽可能多的基数为 10 的数字，并将它们解释为数字值。该字符串可以在形成整数的那些字符之后包含额外的字符，这些字符被忽略并且对该函数的行为没有影响。如果 str 中的第一个非空白字符序列不是有效整数，或者如果由于 str 为空或仅包含空格字符而不存在此类序列，则不执行转换并返回零。 Answer: 12345678910111213141516171819202122232425class Solution: def myAtoi(self, s): """ :type s: str :rtype: int """ s = s.strip() flag = 1 if not s: return 0 if s[0] in ['+', '-']: flag = -1 if s[0] == '-' else 1 s = s[1:] output = 0 for char in s: if char.isdigit(): output = output * 10 + int(char) else: break output *= flag if output &lt; -2147483648: return -2147483648 elif output &gt; 2147483647: return 2147483647 return output]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0007 Reverse Integer]]></title>
    <url>%2F2018%2F02%2F25%2F0007-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[7. Reverse Integer Given a 32-bit signed integer, reverse digits of an integer. Example: 12345678910Input: 123Output: 321Example 2:Input: -123Output: -321Example 3:Input: 120Output: 21 Note: Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Analysis: 题目要求将数字反转，但是要注意整数类型是 32-bit signed integer，所以返回的数字，范围要在 [-2^31, 2^31-1] 中。一开始想到是把数字转化为字符串，再根据切片的性质反转字符串，然后觉得用常规的除法也不错，所以有两种解法。 Answer 1: 12345678class Solution: def reverse(self, x): """ :type x: int :rtype: int """ x = int(str(x)[::-1]) if x &gt;= 0 else - int(str(-x)[::-1]) return x if - 2147483648 &lt;= x &lt;= 2147483647 else 0 Answer 2: 123456789101112class Solution: def reverse(self, x): """ :type x: int :rtype: int """ flag = 1 if x &gt; 0 else -1 x, output = abs(x), 0 while x: output = output * 10 + x % 10 x = x // 10 return output * flag if - 2147483648 &lt;= output * flag &lt;= 2147483647 else 0]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0006 ZigZag Conversion]]></title>
    <url>%2F2018%2F02%2F25%2F0006-ZigZag-Conversion%2F</url>
    <content type="text"><![CDATA[6. ZigZag Conversion The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 123P A H NA P L S I I GY I R And then read line by line: &quot;PAHNAPLSIIGYIR&quot;Write the code that will take a string and make this conversion given a number of rows: 1string convert(string text, int nRows); convert(&quot;PAYPALISHIRING&quot;, 3) should return &quot;PAHNAPLSIIGYIR&quot;. Analysis: 首先应该知道到底什么是 ZipZag，比如我们有一个字符串 0123456789。 图片来源：ZigZag Conversion 解题报告 根据图可以看出，当 rows = 3 时，我们要输出 0481357926，也就是第0层的字符串加第1层的字符串加第2层的字符串，那我们可以这么解决问题：先创建一个列表，里面存着与 rows 相等的空字符串，如 rows = 3，这个列表也就是 [&#39;&#39;, &#39;&#39;, &#39;&#39;]，这些字符串对应着第0层，第1层，第2层。显而易见，ZipZag 结构是按照字符串遍历，以列为基准填充字符的，要解决的就是何时将字符填入第0层，何时填入第1层等。仔细观察，从第一列开始，遇到最后1层也就是第2层时，填充方向反转，此时的数据将会被填入第1层，当遇到第0层时，填充方向又反转了。讲到这里，上代码！ Answer: 123456789101112131415class Solution: def convert(self, s, numRows): """ :type s: str :type numRows: int :rtype: str """ axis = 0 if numRows == 1 else -1 rows, idx = [''] * numRows, 0 for char in s: rows[idx] += char if idx == 0 or idx == numRows - 1: axis *= -1 idx += axis return ''.join(rows)]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0005 Longest Palindromic Substring]]></title>
    <url>%2F2018%2F02%2F25%2F0005-Longest-Palindromic-Substring%2F</url>
    <content type="text"><![CDATA[5. Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: 12345Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 123Input: &quot;cbbd&quot;Output: &quot;bb&quot; Analysis: 得到最大回文字符子串有很多方法。比如，我们可以为子字符串选择所有可能的开始和结束位置，并逐一验证它是否是回文的。这是一种暴力解决方法，往往会超出时间限制。另一种解法，可以从中间往两边探索，如果一样就继续找，不一样就停止。这种解法需要我们不断探索最重要的中间值，比如 cababade，我们找到的最大回文子串是 ababa，而 a 是中间值，我们从 a 入手，不断向左右扩展 a -&gt; bab -&gt; ababa，最终得到了最大回文子串。 Answer: 123456789101112131415161718class Solution: def longestPalindrome(self, s): """ :type s: str :rtype: str """ sub, longest, length = '', 0, len(s) for i in range(length): for j in range(i, i + 2): left, right = i, j while left &gt;= 0 and right &lt; length and s[left] == s[right]: left -= 1 right += 1 long = right - left - 1 if long &gt; longest: longest = long sub = s[left + 1 : right] return sub]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0004 Median of Two Sorted Arrays]]></title>
    <url>%2F2018%2F02%2F25%2F0004-Median-of-Two-Sorted-Arrays%2F</url>
    <content type="text"><![CDATA[4. Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: 12nums1 = [1, 3]nums2 = [2] The median is 2.0 Example 2: 12nums1 = [1, 2]nums2 = [3, 4] The median is (2 + 3) / 2 = 2.5 Analysis: 一看到中位数就想到 numpy 或者 statistics 模块了，抱着试一试的想法，没想到 AC 了，不重复造轮子嘛 hhh。 Answer: 123456789class Solution: def findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ import statistics return statistics.median(nums1 + nums2)]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0003 Longest Substring Without Repeating Characters]]></title>
    <url>%2F2018%2F02%2F25%2F0003-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[3. Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters. Example: Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3. Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1``. Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. Analysis: 题目很清晰，需要查找不重复的具有最大长度的子串。可以先遍历字符串，设置一个游标 start，并构造一个字典结构，当字符不在字典中时，将字符插入到字典。而字符如果能够插入到字典中，说明此时没有重复的字符，最大子串的长度显而易见是当前的 索引 i - start 与 maxLength 的最大值。当遇到重复的字符时，从重复字符出现的位置之后一位开始扫描，但此时，需要把游标 start 指向重复的元素的前一个位置的索引，相当于之后的 i - start 的前面的重复元素剔除了，这样又让子串里的元素不重复了。 Answer: 12345678910111213class Solution: def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ maxLength, start, charDict = 0, 0, &#123;&#125; for i, char in enumerate(s, 1): if charDict.get(char, -1) &gt;= start: start = charDict[char] charDict[char] = i maxLength = max(maxLength, i - start) return maxLength Simulation: 123456789101112131415161718192021222324252627282930313233s = 'abcabcbb'# 第一次循环：start = 0i = 1charDict['a'] = 1maxLength = 1# 第二次循环：start = 0i = 2charDict['b'] = 2maxLength = 2# 第三次循环：start = 0i = 3charDict['c'] = 3maxLength = 3# 第四次循环：i = 4start = 1charDict['a'] = 4maxLength = 3# 第五次循环：i = 5start = 2charDict['b'] = 5maxLength = 3# ...]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0002 Add Two Numbers]]></title>
    <url>%2F2018%2F02%2F25%2F0002-Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. Analysis: 本题类似于竖式的加法，需要考虑各位相加产生的进位问题：相同位相加时，大于10，就往前进1，可设置一个 flag，产生进位其就为1，否则为0，当运算进行到两个数已经没有最高位且本次运算不产生进位时，说明运算已完成，可退出循环。 Answer: 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ output = ListNode(0) tempNode, tempSum, flag = output, 0, 0 while True: if l1: tempSum += l1.val l1 = l1.next if l2: tempSum += l2.val l2 = l2.next tempNode.val = (tempSum + flag) % 10 flag = 1 if (tempSum + flag) &gt;= 10 else 0 tempSum = 0 if l1 == None and l2 == None and flag == 0: break tempNode.next = ListNode(0) tempNode = tempNode.next return output]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0001 Two Sum]]></title>
    <url>%2F2018%2F02%2F25%2F0001-Two-Sum%2F</url>
    <content type="text"><![CDATA[1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Analysis: 题目很简单，使用哈希表即可，需要注意的是不能使用同一个索引的元素两次，比如 [3, 3] 6 ，应该返回 [0, 1] 而不是 [0, 0]。一开始想先通过构建一个字典结构再循环判断 other_num 是否在字典中，如果在即可直接返回索引，所以有了 Answer 1，但是先构建字典结构效率会降低，可以在循环之中不断加入数据到字典，遂使用 Answer 2 解决。 Answer 1: 123456789101112class Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ d = &#123;num: i for i, num in enumerate(nums)&#125; for i, num in enumerate(nums): other_num = target - num if other_num in d and i != d[other_num]: return [i, d[other_num]] Answer 2: 1234567891011121314class Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ d = dict() for i, num in enumerate(nums): other_num = target - num if other_num in d: return [i, d[other_num]] else: d[num] = i]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多SSH Key解决方法]]></title>
    <url>%2F2018%2F01%2F01%2F%E5%A4%9ASSH-Key%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[有多个 SSH Key，如何在 SSH 连接时不产生冲突呢？ 在进行多个项目的时候，一般都会一个项目对应一个 SSH Key，算是为了避免冲突吧，也或者是碍于不可抗力因素需要多个 SSH Key… 通常都是使用 ssh-keygen 命令，一路回车生成 SSH Key： 1ssh-keygen -t rsa 这样在 ~/.ssh/ 目录下会默认生成 id_rsa.pub 和 id_rsa 文件，也就是公钥和私钥。 为了各自需要，有时候需要创建第二个 SSH Key： 1ssh-keygen -t rsa 在第一个返回结果下输入第二个 SSH Key 的名称，比如： 12Generating public/private rsa key pair.Enter file in which to save the key (/Users/sliver/.ssh/id_rsa): /Users/sliver/.ssh/id_second_rsa 输入密码可以选择回车跳过，然后将在 .ssh 目录下生成名称为 id_second_rsa.pub 和 id_second_rsa 的公钥和私钥。 之后在终端输入以下命令，将私钥添加到 ssh-agent 中： 12ssh-add ~/.ssh/id_rsassh-add ~/.ssh/id_second_rsa 如果有良好的密钥命名习惯的话可以直接输入： 1ssh-add ~/.ssh/*_rsa 一步到位，可以任意穿梭于多个 SSH 连接中了。 可使用 ssh-add -l 查看添加私钥的结果如何： 122048 SHA256:S97ZYNIuP0qqdDSBQLP6LD/2rGBgDlWCDyb2B3La1U0 /Users/sliver/.ssh/id_rsa (RSA)2048 SHA256:JWEstYUqxRK5tK2NVj17imvkaIN4kXTL7DSImImbmbI /Users/sliver/.ssh/id_second_rsa (RSA) 一般出现以上结果就对了。出问题时，可使用 ssh-add -d 删除指定私钥，或者 ssh-add -D 删除所有私钥，重新再来一遍即可。 在重启 PC 后，都要重新手动添加私钥到 ssh-agent，显然这是有些麻烦或是容易遗忘的。可以在 shell 配置文件中，我是在 ~/.zshrc 下，末尾添加： 1ssh-add ~/.ssh/*_rsa 以后终端也就可以自动添加私钥了，大功告成。 最后啰嗦一下 生成 Key 时，可能会需要添加自己的邮箱当做备注，可添加 -C 参数： 1ssh-keygen -t rsa -C &quot;your_email@gmail.com&quot; 在生成的公钥文件中可以看到添加的备注，自己去找找吧 hhh。]]></content>
      <categories>
        <category>方法</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Delicious Cookie]]></title>
    <url>%2F2017%2F12%2F29%2F%E5%A5%BD%E5%90%83%E7%9A%84Cookies%2F</url>
    <content type="text"><![CDATA[Cookie 是什么？好吃么？ 一个 Cookie 就是存储在用户主机浏览器中的一小段文本文件。Cookie 是纯文本形式，它们不包含任何可执行代码。一个 Web 页面或服务器告知浏览器来将这些信息存储并且基于一系列规则在之后的每个请求中都将该信息返回至服务器。Web 服务器之后可以利用这些信息来标识用户。 上面是科普，这里随便说说。其实要说 Cookie ，就要说它所立足的 HTTP 协议。HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。那么就会发生这种情况： 假设要求登录认证的 Web 页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面就要再次登录，或者要在每次请求报文中附加参数来管理登录状态。 是不是很麻烦？不过不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的 CPU 及内存资源的消耗。从另一侧面来说，也正是因为 HTTP 协议本身是非常简单的，所以才会被应用在各种场景里。 所以，为了保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。 概括下来，其实就是服务器为了辨别每个用户，就给客户端们颁发一个通行证，一人一个，无论谁访问都必须携带自己的通行证。这样服务器就能从通行证上确认客户身份了，这也就是 Cookie 的工作原理。 为什么突然说 Cookie 呢？因为之前爬教务系统，都是使用 requests 的 session 一口气保持会话的，很少去管 Cookie 的事，分模块和函数式编程的时候，才发现会话的中断和接下来请求的失败…所以特地补全一下知识漏洞吧 hhh。 什么是 CookieJar？首先，查看 requests 的官方文档： 123456789class requests.cookies.RequestsCookieJar(policy=None)[source]Compatibility class; is a cookielib.CookieJar, but exposes a dict interface.This is the CookieJar we create by default for requests and sessions that don't specify one, since some clients may expect response.cookies and session.cookies to support dict operations.Requests does not use the dict interface internally; it's just for compatibility with external client code. All requests code should work out of the box with externally provided instances of CookieJar, e.g. LWPCookieJar and FileCookieJar.Unlike a regular CookieJar, this class is pickleable. 差不多知道了 cookies 对象是 CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar等。各个 CookieJar 的关系是：CookieJar —-派生—-&gt;FileCookieJar —-派生—–&gt;MozillaCookieJar 和 LWPCookieJar 再查看 http.cookiejar — Cookie handling for HTTP clients 中 MozillaCookieJar 和 LWPCookieJar 的官方介绍： 123456789101112131415The following CookieJar subclasses are provided for reading and writing.class http.cookiejar.MozillaCookieJar(filename, delayload=None, policy=None) A FileCookieJar that can load from and save cookies to disk in the Mozilla cookies.txt file format (which is also used by the Lynx and Netscape browsers). Note This loses information about RFC 2965 cookies, and also about newer or non-standard cookie-attributes such as port. Warning Back up your cookies before saving if you have cookies whose loss / corruption would be inconvenient (there are some subtleties which may lead to slight changes in the file over a load / save round-trip). Also note that cookies saved while Mozilla is running will get clobbered by Mozilla.class http.cookiejar.LWPCookieJar(filename, delayload=None, policy=None) A FileCookieJar that can load from and save cookies to disk in format compatible with the libwww-perl library’s Set-Cookie3 file format. This is convenient if you want to store cookies in a human-readable file. 可见，MozillaCookieJar 和 LWPCookieJar 可对文件进行 Cookie 的存取改动。 动手试试存取 Cookie可以开始练练手了，先利用 LWPCookieJar 对象实现存取 Cookie 到文件的功能： 12345678910111213141516171819import requests, sysfrom http.cookiejar import LWPCookieJar as Cookiefrom requests.exceptions import RequestExceptionheaders = &#123; "User-Agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"&#125;s = requests.Session()# 声明一个 LWPCookieJar 对象s.cookies = Cookie()try: html = s.get("http://cas.hdu.edu.cn/cas/login",headers=headers,timeout=5)except RequestException: print("请求超时！请检查网络后再次尝试！") sys.exit(1)# 将获取到的 Cookie 存入文件中s.cookies.save('cookies.txt',ignore_discard=True,ignore_expires=True) save 方法中的两个参数的官方解释是： gnore_discard: save even cookies set to be discarded. ignore_expires: save even cookies that have expiredThe file is overwritten if it already exists 显然 ignore_discard 的意思是即使 Cookie 将会被丢弃也要将它保存下来，ignore_expires 的意思是如果在该文件中 Cookie 已经存在，则覆盖原文件写入，在这里，如果两个全部设置为True，运行之后，Cookie 将会被保存到 cookies.txt 文件中。 成功后我们可以找到新建立的 cookies.txt 文件，打开可看到获取的 Cookie： 123#LWP-Cookies-2.0Set-Cookie3: key_dcp_cas="vK8zhGgBzT8S1QHcgnypKRpRxTny1B1LM20Cmcn8SfMtw2ch2QxG!-1218671341"; path="/"; domain="cas.hdu.edu.cn"; path_spec; discard; HttpOnly=None; version=0Set-Cookie3: route=c4983b7b52b1d14e475c56063c71cbb3; path="/"; domain="cas.hdu.edu.cn"; path_spec; discard; version=0 从文件读取 Cookie现在可以试试从文件读取 Cookie 了： 12345678910111213141516import requestsfrom http.cookiejar import LWPCookieJar as Cookiedef load_cookies(): s = requests.session() s.cookies = Cookie() # 从文件读取 Cookie s.cookies.load('cookies.txt',ignore_discard=True,ignore_expires=True) return ss = load_cookies()# 直接打印 Cookieprint(s.cookies)dict = requests.utils.dict_from_cookiejar(s.cookies)# 打印字典形式的 Cookieprint(dict) 返回结果如下： 123&lt;LWPCookieJar[&lt;Cookie key_dcp_cas=vK8zhGgBzT8S1QHcgnypKRpRxTny1B1LM20Cmcn8SfMtw2ch2QxG!-1218671341 for cas.hdu.edu.cn/&gt;, &lt;Cookie route=c4983b7b52b1d14e475c56063c71cbb3 for cas.hdu.edu.cn/&gt;]&gt;&#123;'key_dcp_cas': 'vK8zhGgBzT8S1QHcgnypKRpRxTny1B1LM20Cmcn8SfMtw2ch2QxG!-1218671341', 'route': 'c4983b7b52b1d14e475c56063c71cbb3'&#125; 之后只要 Cookie 还在生存期内，就可以进教务网站利用Cookie 爬成绩、爬课表等，还是挺不错的。 Cookie 就讲这么多吧，以后用到更高级的方法再补充。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux服务器基础配置]]></title>
    <url>%2F2017%2F12%2F26%2FLinux%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[最近需要去配置服务器，所以可以先拿虚拟机练练手，并分享一下自己的配置过程。 Linux 简介首先，你一定会问：Linux 有什么作用呢？可以归类为四点： 商业服务器基本都是 Linux 开源软件都先支持 Linux 大数据分析、机器学习首选 Linux 整个互联网地基靠 Linux 撑起来 强大如斯，不得不用。为了去学 Linux，首先需要忘掉 Windows 的东西： Linux 下是没有 exe 形式的程序的 文件名等大小写在 Linux 下是需要区分的 Linux 下，一切皆文件 文件的后缀名并不是必须要的，它只是为了找到正确的打开方式而已 更多资料，参见百度百科：Linux 百度百科 为了使用 Linux，可以先去下载虚拟机。 虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。 简单来说，其实就是通过虚拟机可以在自己的电脑上安装另一个操作系统，而不会影响原系统。比如，做渗透的人，一般就会在虚拟机下用 Kali Linux 去做专业的渗透测试。Mac 平台下，可以使用 Parallels Desktop 虚拟机软件。 Parallels Desktop是一款运行在 Mac 电脑上的极为优秀的虚拟机软件。用户可以在 Mac OS X 下非常方便运行 Windows、Linux 等操作系统及应用。用户不必繁琐重复地重启电脑即可在 Win 与 Mac 之间切换甚至同时使用它们。 各位可以 Google 一下各种资源，涉及版权问题，就不多提了。 虚拟机软件安装并配置 CentOS CentOS下载：装好虚拟机后，就可以开始装 Linux 系统了，这里装的是 CentOS。安装推荐网易镜像(后续可能还有更新版本，以最新版本为准)：http://mirrors.163.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1708.iso下载完毕后，我是使用 Parallels Desktop 进行无脑安装的，新手指导还是挺简单的。安装完毕后，可以开始大干一场了。 配置网络：终端输入： 1vi /etc/sysconfig/network-scripts/ifcfg- 按住 Tab，补充显示的第一个文件名，我的是 ifcfg-eth0即最后的命令是： 1vi /etc/sysconfig/network-scripts/ifcfg-eth0 按 i 插入文字，找到 ONBOOT 一栏将其对应的值改成 yes，按 esc 后输入 :wq 退出编辑。现在回到终端输入： 1service network restart 这个时候再输入 ip addr 可以看到启动网络服务后的 IP 地址了。 安装网络工具包1yum install net-tools 安装成功后在 Parallels 界面将 CentOS 的网络设置为桥接网络，再使用 ifconfig 命令查看 IP。 1234567891011121314151617eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.3.12 netmask 255.255.255.0 broadcast 192.168.3.255 inet6 fe80::21c:42ff:fe50:f6f9 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:1c:42:50:f6:f9 txqueuelen 1000 (Ethernet) RX packets 32807 bytes 44041713 (42.0 MiB) RX errors 0 dropped 3 overruns 0 frame 0 TX packets 13811 bytes 1092135 (1.0 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1 (Local Loopback) RX packets 72 bytes 6248 (6.1 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 72 bytes 6248 (6.1 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 192.168.3.12就是我们需要的 IP 了(当然 IP 肯定各不相同)。 替换默认源网易 CentOS 镜像使用帮助： http://mirrors.163.com/.help/centos.html 首先查看我们当前的 CentOS 版本： 1cat /etc/redhat-release 我的是7.4版本，所以返回结果是： 1CentOS Linux release 7.4.1708 (Core) 知道版本后先去下载 wget，这里分享一下 wget 的资料： wget 是一个从网络上自动下载文件的自由工具，支持通过 HTTP、HTTPS、FTP 三个最常见的 TCP/IP协议 下载，并可以使用 HTTP 代理。”wget” 这个名称来源于 “World Wide Web” 与 “get” 的结合。 现在开始下载： 1sudo yum install wget 按照网易镜像帮助的提示，先 cd 到 yum.repos.d 目录： 1cd /etc/yum.repos.d/ 这个时候复制响应版本的源镜像链接，再用 wget 下载： 1sudo wget http://mirrors.163.com/.help/CentOS7-Base-163.repo 替换完毕后，依次输入以下两个命令，生成缓存： 12yum clean allyum makecache 这样可以快速下载 vim 了： 1sudo yum install vim 使用 oh-my-zsh 获取配置 zshzsh 是一个很强的 shell，拥有很多强劲的功能，它的的命令补全功能非常强大，可以补齐路径、补齐命令、补齐参数等，而且还有强大的别名功能，总之，一定好用。 zsh详细介绍 现在，开始配置 zsh 吧。可以先查看目前 CentOS 的默认 shell： 1echo $SHELL 返回结果如下： 1/bin/bash 果然不是 zsh 哈哈。那不死心再看看 bin 下有没有 zsh： 1cat /etc/shells 返回结果如下： 123456/bin/sh/bin/bash/sbin/nologin/bin/dash/bin/tcsh/bin/csh 好吧，还是没有…那自己去下吧。 1sudo yum -y install zsh 再去看看 bin 目录： 1cat /etc/shells 1234567/bin/sh/bin/bash/sbin/nologin/bin/dash/bin/tcsh/bin/csh/bin/zsh 已经有 zsh 了，将其替换为默认 shell 吧： 1sudo chsh -s /bin/zsh 重启一下： 1reboot 重新打开 CentOS，看看默认 shell： 1echo $SHELL 1/bin/zsh 成功。 获取 oh-my-zsh首先当然是要安装 git了： 1sudo yum -y install git 成功后下载 oh-my-zsh： 1sudo wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 成功后会显示如下界面： 1234567891011 __ __ ____ / /_ ____ ___ __ __ ____ _____/ /_ / __ \/ __ \ / __ `__ \/ / / / /_ / / ___/ __ \ / /_/ / / / / / / / / / / /_/ / / /_(__ ) / / / \____/_/ /_/ /_/ /_/ /_/\__, / /___/____/_/ /_/ /____/ ....is now installed!Please look over the ~/.zshrc file to select plugins, themes, and options.p.s. Follow us at https://twitter.com/ohmyzsh.p.p.s. Get stickers and t-shirts at http://shop.planetargon.com. 还挺 cool 的哈哈。 更改主题先 cd 到 .zshrc 所在目录： 12cd ~vim .zshrc 找到 ZSH_THEME 修改为 agnoster(agnoster是我一直比较喜欢的主题)： 1ZSH_THEME="agnoster" 保存启用修改： 1source ~/.zshrc vim 配色终端还有 vim 还是赏心悦目的好，先下载 Solarized： 1git clone git://github.com/altercation/solarized.git 颜色配置一下： 1234cd solarizedcd vim-colors-solarized/colorsmkdir -p ~/.vim/colorscp solarized.vim ~/.vim/colors/ 再去给 vim 配置一下吧：vim ~/.vimrc这里我加入了一些简单的 vim 自定义配置： 1234567891011121314151617syntax enableset background=darkcolorscheme solarizedset showmatch " 高亮显示对应的括号set number " 显示行号set cindent " C风格的对齐方式set autoindent " 自动对齐set confirm " 在处理未保存或只读文件的时候，弹出确认set tabstop=4 " Tab键的宽度syntax on " 自动语法高亮set softtabstop=4set shiftwidth=4 " 统一缩进为4set hlsearchset incsearch " 搜索逐字符高亮set gdefault " 行内替换set encoding=utf-8set completeopt=preview,menu 这样我们基本的 Linux 配置服务就完成了。 Mac 利用 SSH 连接 CentOS SSH工具 SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。 总而言之，SSH 是为本地的客户端与服务器上的服务端相互之间进行远程登录会话提供安全的的协议。 服务器安装 SSH 服务一般 Linux 的桌面发行版，即有 GUI 界面的发行版是没有安装 SSH 服务端的，可以使用如下命令安装： 1sudo yum install openssh-server 启动 SSH： 1service sshd start 查看是否启动： 1ps -ef |grep ssh 成功就可以看到这个进程了： 1&gt;&gt;&gt;root 1300 1 0 04:29 ? 00:00:00 /usr/sbin/sshd -D 设置开机运行： 1chkconfig sshd on 本地安装SSH服务Linux平台可以使用如下命令： 1sudo yum install openssh-clients Mac 直接使用 iTerm2 就行了，还可以尝试一下 SSH 连接： 1ssh sliver@192.168.3.12 输入服务器账户密码即可成功连接了。 使用 ssh-copy-id-for-OSX 工具将公钥复制至 ssh 服务器每次连接都要输入密码还是挺麻烦的，可以使用公钥登录的方法，免去每次都要输入密码的烦恼。 公钥登录是为了解决每次登录服务器都要输入密码的问题，流行使用 RSA 加密方案，主要流程包含： 1.客户端生成 RSA 公钥和私钥2.客户端将自己的公钥存放到服务器3.客户端请求连接服务器，服务器将一个随机字符串发送给客户端4.客户端根据自己的私钥加密这个随机字符串之后再发送给服务器5.服务器接受到加密后的字符串之后用公钥解密，如果正确就让客户端登录，否则拒绝。 这样也就不用使用密码了。那么，第一步当然是要生成公钥和秘钥了，在用户主目录下输入： 1ssh-keygen 直接一直回车到结束，生成的公钥和秘钥已经就在 ~/.ssh/ 目录下了，id_rsa.pub 即为所要的公钥。现在可以将公钥放到服务器上，这里使用一种比较简单的方法： 1234567brew install ssh-copy-idssh-copy-id username@hostname # 将username和hostname替换为你的ssh服务器用户名和IP# 不加参数默认使用~/.ssh/id_rsa.pub# 添加-i参数可以自定义添加的公钥ssh-copy-id -i ~/.ssh/id_rsa.pub username@hostname 使用 ssh-copy-id，可以将公钥自动保存到服务器用户目录下的 /.ssh/authorized_keys 文件中去，当然自己在服务器手动创建并复制粘贴公钥也是可以的。以后使用 ssh 登录服务器就不用再输入密码了： 1234ssh sliver@192.168.3.12&gt;&gt;&gt;Last login: Mon Dec 25 14:12:03 2017 from 192.168.3.5[sliver@localhost ~]$ 可以输入 exit 退出 ssh 连接。但还是要输入一大串不太好记的字符串，在 zsh 下可以使用别名： 12echo "alias ssh-to-username='ssh username@hostname'" &gt;&gt; ~/.zshrc #将username和hostname替换为你的服务器信息source ~/.zshrc 看看怎么样： 1234ssh-to-centos&gt;&gt;&gt;Last login: Mon Dec 25 14:17:31 2017 from 192.168.3.5[sliver@localhost ~]$ 也可以在 ~/.ssh/ 目录下创建 config 文件，添加如下代码： 1234Host alias_name HostName ip_address Port 22(默认) User user_name 我是这样添加的： 1234Host server HostName 192.168.3.12 Port 22 User sliver 可使用如下命令进行远程连接： 1ssh server 也可以利用 scp 命令传输文件到远程服务器了： 1scp /Users/sliver/test.py sliver@192.168.3.12:/home/sliver/test 传输文件夹： 1scp -r /Users/sliver/test sliver@192.168.3.12:/home/sliver/helloworld 很舒服。 安装 Python 3.6CentOS 默认是有 Python2 的环境的，不过我需要的是 Python3，所有需要下载安装一手。 首先无脑安装所有可能需要的依赖： 1yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel 因为以后肯定会经常需要下载包，可以新建一个 download 文件夹来存储包： 1sudo mkdir /usr/download 进入 download 文件夹，从官网下载 Python 3.6: 1wget https://www.python.org/ftp/python/3.6.4/Python-3.6.4.tgz 下载完成后，开始解压： 1tar -xvf Python-3.6.4.tgz 创建之后用来安装 Python 的路径，一般放在 /usr/local 目录下： 1sudo mkdir /usr/local/python3 如果解压完成了，download 目录下会出现解压好的 python3.6.4 文件夹，我们先进入该文件夹： 1cd /usr/download/python3.6.4 在 /usr/download/python3.6.4 文件夹下，开始将源码编译进我们已经建好的指定安装文件夹： 1./configure --prefix=/usr/local/python3 编译完成后，开始安装： 12makemake install 快要完成了，准备创建新版本的软连接： 先修改旧版本 1mv /usr/bin/python /usr/bin/python_bak 创建新的 python 软连接 1ln -s /usr/local/python3/bin/python3 /usr/bin/python 检验一下是否安装成功 1python -V 如果返回结果如下，说明成功安装了 Python 3.6： 1Python 3.6.4 当然，现在安装的 Python 可能是有缺陷的，我们需要将 /usr/local/python3/bin 添加到环境变量： 用 vim 编辑 .zshrc 文件 1vim ~/.zshrc 加入这两句即可： 12export PATH=/usr/bin:$PATHexport PATH=/usr/local/python3/bin:$PATH 之后，可以尽情使用 pip3 和 Python 3.6.4 啦： 1sudo pip3 install requests 觉得慢可以使用 pip 的国内源： 1sudo pip3 install requests -i https://pypi.tuna.tsinghua.edu.cn/simple PS： 也许在使用 pip3 过程会出现权限不够，但 sudo 加权又失败的现象，这时候需要打开 sudo 的配置文件： 1sudo visudo 在 Defaults secure_path 一栏加入 pip3 所在 bin 目录，比如改成： 1Defaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/python3/bin 大功告成。 安装 Node.js老规矩，还是先进入到 download 目录： 1cd /usr/download/ 下载官网最新的 bin 包： 1wget https://nodejs.org/dist/v9.3.0/node-v9.3.0-linux-x64.tar.xz 完成后，解压下好的包： 12xz -d node-v9.3.0-linux-x64.tar.xztar -xf node-v9.3.0-linux-x64.tar 因为下载的是 bin 包，直接软链接即可： 12ln -s /usr/download/node-v9.3.0-linux-x64/bin/node /usr/bin/nodeln -s /usr/download/node-v9.3.0-linux-x64/bin/npm /usr/bin/npm 为了避免后续出现麻烦，可以安装几个依赖： 1yum install -y gcc gcc-c++ openssl-devel 加入到环境变量： 1export PATH=/usr/download/node-v9.3.0-linux-x64/bin:$PATH 判断安装是否成功： 1node -v Node.js 安装完毕。 安装 MySQL进入 /usr/local/src/ 目录 1cd /usr/local/src/ 下载最新的 repo 源： 1wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm 解包： 1rpm -ivh mysql57-community-release-el7-8.noarch.rpm 下载对应的服务程序： 1yum -y install mysql-server 安装完成后启动 MySQL 服务： 1sudo service mysqld restart 查看在安装过程中随机生成的密码： 1grep "password" /var/log/mysqld.log 通过查看到的随机密码登录 MySQL: 1sudo mysql -u root -p 重置密码（须包含数字、字母和符号）： 1alter user 'root'@'localhost' identified by 'root!2018'; 刷新权限： 1flush privileges 查看数据库占用端口号： 1show global variables like 'port'; 修改端口号，先打开配置文件： 1vim /etc/my.cnf 添加 port 信息后，再重启 MySQL 即可： 1234567891011[mysqld]port=3309datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysql# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0[mysqld_safe]log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid 安装 Nginx首先需要安装一些必备的依赖库，可能之前装过了，没有装过的话就无脑装一下： 12345678910yum install gcc-c++ yum install pcre pcre-devel yum install zlib zlib-devel yum install openssl openssl--devel ``` 装好后先进入 /usr/local 目录：```Bashcd /usr/local 从官网下载最新版的 Nginx： 1wget http://nginx.org/download/nginx-1.7.4.tar.gz 解压 Nginx 压缩包： 1tar -zxvf nginx-1.7.4.tar.gz 这时会产生一个 nginx-1.7.4 目录，进入即可 1cd nginx-1.7.4 接下来安装，使用 –prefix 参数可以指定 Nginx 安装的目录，然后 make、make install 安装： 12345# 默认安装在/usr/local/nginx./configure make make install 如果没有报错，差不多就证明 Nginx 安装成功了，可以找找看： 1whereis nginx 查看版本： 1nginx -V 相关应用可转到：CentOS 下用 Nginx 和 uwsgi 部署 flask 项目]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3爬虫相关库笔记]]></title>
    <url>%2F2017%2F12%2F14%2FPython3%E7%88%AC%E8%99%AB%E7%9B%B8%E5%85%B3%E5%BA%93%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[有时候一个爬虫程序，可能只有几行代码，但是它涉及到的知识面却很广，这里先记下一些相关知识，以此共勉。 JSON什么是 JSON ？JSON 指的是 JavaScript 对象表示法 (JavaScript Object Notation） JSON 是轻量级的文本数据交换格式 JSON 独立于语言 JSON 具有自我描述性，更易理解 JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 JSON 有什么优点？ 方便于传输，较少冗余的字符。当然直接传二进制是最好的，但面临难解析的问题。亦可以是 XML、纯字符串的方式，但 JSON 有其独到的好处。有兴趣可了解一下。 方便转换。有很多的 JSON API 提供了 JSON 字符串转成对象、对象转换成 JSON 串的方法。 易于阅读。JSON 代码的良好结构，可以很直观地了解存的是什么内容。 简而言之，JSON 就是比 XML 的基础上，去掉了标签，这样也就节省了大量的存储空间。 Python 中的 JSON 模块 json 模块提供了一种很简单的方式来编码和解码 JSON 数据。其中两个主要的函数是 json.dumps() 和 json.loads()，要比其他序列化函数库如 pickle 的接口少得多。下面演示如何将一个 Python 数据结构转换为 JSON： 12345678910import jsondata = &#123; 'name' : 'ACME', 'shares' : 100, 'price' : 542.23&#125;json_str = json.dumps(data)print(json_str) 12#返回结果&#123;"name": "ACME", "shares": 100, "price": 542.23&#125; 下面演示如何将一个 JSON 编码的字符串转换回一个 Python 数据结构： 123&gt;&gt;&gt; data = json.loads(json_str)&gt;&gt;&gt; print(data)&#123;'name': 'ACME', 'shares': 100, 'price': 542.23&#125; 如果要处理的是文件而不是字符串，可以使用 json.dump() 和 json.load() 来编码和解码 JSON 数据。例如： 1234567# Writing JSON datawith open('data.json', 'w') as f: json.dump(data, f)# Reading data backwith open('data.json', 'r') as f: data = json.load(f) JSON 编码支持的基本数据类型为 None，bool，int，float 和 str，以及包含这些类型数据的 lists，tuples 和 dictionaries。 对 dictionaries，keys 需要是字符串类型(字典中任何非字符串类型的key在编码时会先转换为字符串)。为了遵循 JSON 规范，你应该只编 Python 的 lists 和 dictionaries。而且，在 Web 应用程序中，顶层对象被编码为一个字典是一个标准做法。 JSON 编码的格式对于 Python 语法而已几乎是完全一样的，除了一些小的差异之外。比如，True 会被映射为 true，False 被映射为 false，而 None 会被映射为 null。下面是一个例子，演示了编码后的字符串效果： 1234567&gt;&gt;&gt; json.dumps(False)'false'&gt;&gt;&gt; d = &#123;'a': True,... 'b': 'Hello',... 'c': None&#125;&gt;&gt;&gt; json.dumps(d)'&#123;"b": "Hello", "c": null, "a": true&#125;' 总结 JSON 字符串转为字典 json.load / json.loads两个方法功能类似，可选参数也相同，最大的区别在于，json.load 方法接受的输入，即第一个参数，是包含 JSON 数据的文件对象，如 open 方法的返回对象。json.loads 接受的输入是 JSON 字符串，而非文件对象。从输入类型的区别也可以看出两者的使用场合。可选参数包括是否需要转换整型、浮点型等数值的参数，还有一些复杂的功能，暂时没有用到，以后有机会再了解。 字典转换为 JSON json.dump / json.dumps对应于 load 和 loads，dump 的第一个参数是对象字典，第二个参数是文件对象，可以直接将转换后的 JSON 数据写入文件，dumps 的第一个参数是对象字典，其余都是可选参数。dump 和 dumps 的可选参数相同，这些参数都相当实用，现将用到的参数记录如下： ensure_ascii 默认为 True，保证转换后的 JSON 字符串中全部是 ascii 字符，非 ascii 字符都会被转义。如果数据中存在中文或其他非 ascii 字符，最好将 ensure_ascii 设置为 False，保证输出结果正常。 indent 缩进，默认为 None ，没有缩进，设置为正整数时，输出的格式将按照 indent 指定的半角空格数缩进，相当实用。 separators 设置分隔符，默认的分隔符是(‘,’, ‘: ‘)，如果需要自定义 JSON 中的分隔符，例如调整冒号前后的空格数，可以按 (item_separator, key_separator) 的形式设置。 sort_keys 默认为 False，设为 True 时，输出结果将按照字典中的 key 排序。 1234567# 举例&gt;&gt;&gt; print(json.dumps(data, indent=4))&#123; "name": "ACME", "shares": 100, "price": 542.23&#125; DemjsonDemjson 是 Python 的第三方模块库，可用于编码和解码 JSON 数据，包含了 JSON 的格式化及校验功能。安装命令很简单，一个命令就可以搞定了： 1pip3 install demjson 现在来使用一下： 123456789101112131415import demjsondata = &#123; 'name' : 'ACME', 'shares' : 100, 'price' : 542.23&#125;json_str = demjson.encode(data) # 转换为JSON字符串print(json_str)text = demjson.decode(json_str) # 转换为字典print(text)&gt;&gt;&gt;&#123;"name":"ACME","price":542.23,"shares":100&#125;&gt;&gt;&gt;&#123;'name': 'ACME', 'price': 542.23, 'shares': 100&#125; Hashlibhashlib 是一个提供了一些流行的 hash 算法的 Python 标准库，其中所包括的算法有 md5，sha1，sha224，sha256，sha384，sha512。另外，模块中所定义的 new(name, string=”) 方法可通过指定系统所支持的hash算法来构造相应的 hash 对象。Python3 中 hashlib 模块代替了 Python2 中的 md5 和 sham 模块，使用这个模块一般分为3步： 创建一个哈希对象，使用哈希算法命名的构造函数或通用构造函数来创建。 使用哈希对象调用 update() 方法填充这个对象。 调用 digest() 或 hexdigest() 方法来获取摘要（加密结果）。 md5 加密： 12345678# md5加密import hashlibhash = hashlib.md5()hash.update('sliver'.encode('utf-8'))print(hash.hexdigest())&gt;&gt;&gt;241f166bdf9887f732ae06ba859da376 也可以这样实现 md5 加密： 123456789101112import hashlibhash1 = hashlib.md5(b'sliver')print(hash1.hexdigest())hash2 = hashlib.md5('sliver'.encode('utf-8'))print(hash2.hexdigest())# 也就是加密前必须先指定编码&gt;&gt;&gt;241f166bdf9887f732ae06ba859da376&gt;&gt;&gt;241f166bdf9887f732ae06ba859da376 sha1 加密： 12345678# sha1加密import hashlibhash = hashlib.sha1()hash.update('sliver'.encode('utf-8'))print(hash.hexdigest())&gt;&gt;&gt;e7896b82b9fcccbba18d905c0e374c4e8d612b08 sha256 加密： 12345678# sha256加密import hashlibhash = hashlib.sha256()hash.update('sliver'.encode('utf-8'))print(hash.hexdigest())&gt;&gt;&gt;66cb86b497f2b457cc6a19fafda4952bfbd831ed9c2d7ba12157ef269ecf3885 sha512 加密： 12345678# sha512加密import hashlibhash = hashlib.sha512()hash.update('sliver'.encode('utf-8'))print(hash.hexdigest())&gt;&gt;&gt;f3e8498d2d0b2a91cc29e085ca22c4ca27345633b023ba8ec83430784ee715a9bb5a27e758ce04eb7b653c079e7264753fc313d7eb5df352e43e34c324d88bf0 “加盐”加密： 以上的算法确实是密码学大佬们的结晶，但比如sha1算法还是可以通过暴力破解被破解出来的，这时候，自己自定义加上key，俗称“加盐”，能让加密算法更加安全。 12345678# “加盐”加密import hashlibhash = hashlib.md5('ariel'.encode('utf-8'))hash.update('sliver'.encode('utf-8'))print(hash.hexdigest())&gt;&gt;&gt;077ee0a6276e80b65a42de44a27b9f08 GetPass众所周知，Linux 系统下，在终端输入密码时，是不显示密码位数的（不回显）。这也告诉我们：为了安全，核心的操作应该要设为不可见的。Python 也为我们提供了类似功能的库，getpass。它的核心代码很短，却很有用。 首先看看模块中主要的两个函数的 API 和介绍: getpass.getpass(prompt=&#39;Password: &#39;, stream=None) 1234567891011Prompt the user for a password without echoing. The user is prompted using the string prompt, which defaults to &apos;Password: &apos;.On Unix, the prompt is written to the file-like object stream using the replace error handler if needed. stream defaults to the controlling terminal (/dev/tty) or if that is unavailable to sys.stderr (this argument is ignored on Windows).If echo free input is unavailable getpass() falls back to printing a warning message to stream and reading from sys.stdin and issuing a GetPassWarning.Note: If you call getpass from within IDLE, the input may be done in the terminal you launched IDLE from rather than the idle window itself.exception getpass.GetPassWarningA UserWarning subclass issued when password input may be echoed. 调用该函数可以在命令行窗口里无回显输入密码。参数 prompt 代表提示字符串，默认是 Password:，有点类似 input。在 Unix 系统中，stream 默认为当前控制的终端。而在 Windows 系统中 stream 参数会被忽略掉，默认使用 stdin，另外在 IDLE 下使用 getpass 的话，一般会转换成终端来运行脚本。如果无法正常使用 getpass，会引发一个 GetPassWarning 错误，然后模块会使用有回显的输入模式读取数据。 getpass.getuser() 12345Return the “login name” of the user.This function checks the environment variables LOGNAME, USER, LNAME and USERNAME, in order, and returns the value of the first one which is set to a non-empty string. If none are set, the login name from the password database is returned on systems which support the pwd module, otherwise, an exception is raised. 通过这个函数可以去 Shell 的环境变量中获取当前用户名。 动手试试吧： 123456import getpassuser = getpass.getuser()print('Hello,',user)password = getpass.getpass('Please enter your password: ')print("Your password is:", password) 返回结果如下： 123Hello, sliverPlease enter your password:Your password is: 123456 PrettyTablePrettyTable 是 Python 的第三方模块，需要手动下载： 1pip install prettytable 这个模块可以将数据输出的如表格一般好看、整齐，很适合强迫症患者 hhh。现在来使用一下吧： 1234567from prettytable import PrettyTable as pttable = pt(["姓名", "性别", "成绩"])table.add_row(["Sliver", "男", 95])table.add_row(["Ariel", "女", 99])table.add_row(["Hollen", "男", 80])print(table) 结果如下： 总结 想要创建一个表，先进行初始化： 123from prettytable import PrettyTable as pttable = pt() 接下来就是添加表中的元素了： 123456# 按行添加table = pt(["姓名", "性别", "成绩"])table.add_row(["Sliver", "男", 95])table.add_row(["Ariel", "女", 99])table.add_row(["Hollen", "男", 80])print(table) 按行添加时，列表要在初始化时就要插入一个列表当做表头，否则 PrettyTable 会使用Field 1 | Field 2 | Field 3依次进行表头填充。 123456# 按列添加table = pt()table.add_column("姓名", ["Sliver", "Ariel", "Hollen"])table.add_column("性别", ["男", "女" ,"男"])table.add_column("成绩", [95, 99, 80])print(table) 按列添加时，不需要对表头进行初始化，但是插入列时，要添加要插入的列的名称。 其他功能 无表格框输出： 1print(pt.get_string()) 可将表按某列数值进行排序： 1print(table.get_string(sortby="成绩", reversesort=True)) 想了解更多功能可转到 Python PrettyTable 模块 FunctoolsFunctools 是一个很厉害的库，看看官方的介绍： 123The functools module is for higher-order functions: functions that act on or return other functions. In general, any callable object can be treated as a function for the purposes of this module. 简单来说，functools 是面向高阶函数的函数：指那些作用于函数或者返回其他函数的函数。通常情况下，只要是可以被当做函数调用的对象就是这个模块的目标。 这里主要介绍该模块的 partial() 函数。 partial() 函数是将所要承载的函数作为 partial() 函数的第一个参数，原函数的各个参数依次作为partial() 函数后续的参数，当然也可以使用关键字参数来赋值。 有时候函数的参数个数可能会很多，但在后续使用时，我们已经知道要一直使用这个参数，就可以使用 partial() 函数来简化函数。partial() 可以创建一个新的函数，这个新函数可以固定住原函数的全部或部分参数，从而在调用函数时更简单。 这里附上用于简化 BeautifulSoup 的例子： 12345678910111213141516import requests, sysfrom requests.exceptions import RequestExceptionfrom functools import partialfrom bs4 import BeautifulSoupheaders = &#123; "User-Agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"&#125;bs = partial(BeautifulSoup, features='html5lib')s = requests.Session()try: html = s.get("http://cas.hdu.edu.cn/cas/login", headers=headers, timeout=5) print(bs(html.text).prettify())except RequestException: print("请求超时!请检查网络后再次尝试!") sys.exit(1) 查看更多函数：Python functools模块学习总结 Python 中的函数eval(str) eval(str) 函数很强大，它是 Python 用于执行字符串内的表达式的一个内置函数，使用 eval，可以很方便的将字符串动态执行。 eval() 函数常见作用有： 1、计算字符串中有效的表达式，并返回结果 123456&gt;&gt;&gt; eval('pow(2,2)')4&gt;&gt;&gt; eval('2 + 2')4&gt;&gt;&gt; eval("4 * 4")16 2、将字符串转成相应的 Python 对象（如 list、tuple、dict 和 string 之间的转换） 123456789101112&gt;&gt;&gt; a = "[[1,2], [3,4], [5,6], [7,8], [9,0]]"&gt;&gt;&gt; b = eval(a)&gt;&gt;&gt; b[[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]]&gt;&gt;&gt; a = "&#123;1:'xx',2:'yy'&#125;"&gt;&gt;&gt; c = eval(a)&gt;&gt;&gt; c&#123;1: 'xx', 2: 'yy'&#125;&gt;&gt;&gt; a = "(1,2,3,4)"&gt;&gt;&gt; d = eval(a)&gt;&gt;&gt; d(1, 2, 3, 4) 3、将利用反引号转换的字符串再反转回对象 12345678910&gt;&gt;&gt; list1 = [1,2,3,4,5]&gt;&gt;&gt; `list1`'[1, 2, 3, 4, 5]'&gt;&gt;&gt; type(`list1`)&lt;type 'str'&gt;&gt;&gt;&gt; type(eval(`list1`))&lt;type 'list'&gt;&gt;&gt;&gt; a = eval(`list1`)&gt;&gt;&gt; a[1, 2, 3, 4, 5] 尾声先写这么多吧，未完待续。]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3爬虫之urllib模块的使用]]></title>
    <url>%2F2017%2F12%2F07%2FPython3%E7%88%AC%E8%99%AB%E4%B9%8Burllib%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[今天来说说 Python3 内置的一个 HTTP 请求库，urllib。 官方文档：urllib — URL handling modules urllib 中包括了四个模块，包括了：urllib.request，urllib.error，urllib.parse，urllib.robotparser urllib.request (请求模块)：可以用来发送 request 和获取 request 的结果 urllib.error (异常处理模块)：包含了 urllib.request 产生的异常 urllib.parse (URL 解析模块)：用来解析和处理URL urllib.robotparse (robots.txt 解析模块)：用来解析页面的 robots.txt 文件 显而易见，urllib.request 库和 urllib.error 库是在一次模拟请求中比较重要的库。 使用 urllib.request 发送请求 简单 urllib.request.urlopen() 使用方法urllib.request 模块提供了最基本的构造 HTTP 请求的方法，利用它可以模拟浏览器的一个请求发起过程，同时它还带有处理 authenticaton(授权验证)，redirections(重定向)，cookies(浏览器 Cookies) 以及其它内容。首先，先试着抓取一下百度的页面： 1234import urllib.request response = urllib.request.urlopen("http://www.baidu.com") print(response.read().decode("utf-8")) 真正的代码其实只有两行，我们便完成了对百度首页的抓取，并输出了它的网页源代码。在爬虫程序中，得到了网页源代码之后，你所需要的链接、图片、视频、文本信息等就可以在网页源代码中查找并提取出来。现在尝试利用 type 函数输出 response 的类型： 1234import urllib.request response = urllib.request.urlopen("http://www.baidu.com") print(type(response)) 输出结果为：&lt;class &#39;http.client.HTTPResponse&#39;&gt;通过输出结果可以发现它是一个 http.client.HTTPResponse 类型的对象，它主要包含的方法有 read()、readinto()、getheader(key)、getheaders()、fileno() 等函数和 msg、version、status、reason、debuglevel、closed 等属性。得到这个对象之后，将其赋值给 response，就可以用 response 调用这些方法和属性，以此得到返回结果和信息。如 response.read().decode(&quot;utf-8&quot;) 可以得到返回后的利用 utf-8 编码的网页内容，response.status 可以得到响应返回结果的状态码。下面再来一个实例感受一下： 123456789&gt;&gt;&gt; import urllib.request&gt;&gt;&gt;&gt;&gt;&gt; response = urllib.request.urlopen("http://www.baidu.com")&gt;&gt;&gt; print(response.status)200&gt;&gt;&gt; print(response.getheaders())[('Date', 'Thu, 07 Dec 2017 14:37:26 GMT'), ('Content-Type', 'text/html; charset=utf-8'), ('Transfer-Encoding', 'chunked'), ('Connection', 'Close'), ('Vary', 'Accept-Encoding'), ('Set-Cookie', 'BAIDUID=3D72FEFAEEE60FAB2F79886A59FAC02D:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com'), ('Set-Cookie', 'BIDUPSID=3D72FEFAEEE60FAB2F79886A59FAC02D; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com'), ('Set-Cookie', 'PSTM=1512657446; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com'), ('Set-Cookie', 'BDSVRTM=0; path=/'), ('Set-Cookie', 'BD_HOME=0; path=/'), ('Set-Cookie', 'H_PS_PSSID=25263_1467_21122_25178_20718; path=/; domain=.baidu.com'), ('P3P', 'CP=" OTI DSP COR IVA OUR IND COM "'), ('Cache-Control', 'private'), ('Cxy_all', 'baidu+90b96fddd3e4cc794d4573d45036518c'), ('Expires', 'Thu, 07 Dec 2017 14:36:39 GMT'), ('X-Powered-By', 'HPHP'), ('Server', 'BWS/1.1'), ('X-UA-Compatible', 'IE=Edge,chrome=1'), ('BDPAGETYPE', '1'), ('BDQID', '0xe4820d9700009820'), ('BDUSERID', '0')]&gt;&gt;&gt; print(response.getheader("Server"))BWS/1.1 可见，三个输出分别输出了响应的状态码，响应的头信息，以及通过传递一个参数来获取对应的头信息。 高级 urllib.request.urlopen() 使用方法利用 urlopen() 方法，我们可以实现对一般网页的 GET 请求。如果我们想给链接传递一些参数该怎么实现呢？我们首先看一下 urlopen() 函数的 API。 urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None) 可以发现除了第一个参数可以传递 URL 之外，我们还可以传递其它的内容，比如 data(附加参数)，timeout(超时时间) 等等。data 参数是可选的，如果要添加 data，它要求是字节流编码格式的内容，即 bytes 类型，通过 bytes() 函数可以进行转化，另外如果你传递了这个 data 参数，它的请求方式就不再是 GET 方式请求，而是 POST。 1234567import urllib.parse import urllib.request data = bytes(urllib.parse.urlencode(&#123;'word': 'hello'&#125;), encoding='utf-8') response = urllib.request.urlopen('http://httpbin.org/post', data=data) print(response.read().decode('utf-8'))# read 获取的是 bytes 型的数据，decode 可按特定编码方式编码(相当于获取响应体)。 在这里我们传递了一个参数 word，值是 hello。它需要被转码成 bytes(字节流) 类型。其中转字节流采用了 bytes() 方法，第一个参数需要是 str(字符串) 类型，需要用 urllib.parse.urlencode() 方法来将参数字典转化为字符串。第二个参数指定编码格式，在这里指定为 utf-8。提交的网址是 httpbin.org，它可以提供 HTTP 请求测试。http://httpbin.org/post 这个地址可以用来测试 POST 请求，它可以输出请求和响应信息，其中就包含我们传递的 data 参数。运行结果如下： 12345678910111213141516171819&#123; "args": &#123;&#125;, "data": "", "files": &#123;&#125;, "form": &#123; "word": "hello" &#125;, "headers": &#123; "Accept-Encoding": "identity", "Connection": "close", "Content-Length": "10", "Content-Type": "application/x-www-form-urlencoded", "Host": "httpbin.org", "User-Agent": "Python-urllib/3.6" &#125;, "json": null, "origin": "112.10.180.190", "url": "http://httpbin.org/post"&#125; 我们传递的参数出现在了 form 中，这表明我们的 Python 语句模拟了表单提交的方法，并以 POST 方式传输数据。 timeout 参数timeout 参数可以设置超时时间，单位为秒，意思就是如果请求超出了设置的这个时间还没有得到响应，就会抛出异常，如果不指定，就会使用全局默认时间。它支持 HTTP、HTTPS、FTP 请求。下面来用一个实例感受一下： 1234import urllib.request response = urllib.request.urlopen("http://httpbin.org/get",timeout=0.1) print(response.read()) 结果如下： 1234567891011121314151617During handling of the above exception, another exception occurred:Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "/Users/sliver/anaconda3/lib/python3.6/urllib/request.py", line 223, in urlopen return opener.open(url, data, timeout) File "/Users/sliver/anaconda3/lib/python3.6/urllib/request.py", line 526, in open response = self._open(req, data) File "/Users/sliver/anaconda3/lib/python3.6/urllib/request.py", line 544, in _open '_open', req) File "/Users/sliver/anaconda3/lib/python3.6/urllib/request.py", line 504, in _call_chain result = func(*args) File "/Users/sliver/anaconda3/lib/python3.6/urllib/request.py", line 1346, in http_open return self.do_open(http.client.HTTPConnection, req) File "/Users/sliver/anaconda3/lib/python3.6/urllib/request.py", line 1320, in do_open raise URLError(err)urllib.error.URLError: &lt;urlopen error timed out&gt; 在这里我们设置了超时时间是0.1秒，在0.1秒过后服务器依然没有响应，于是程序抛出了 urllib.error.URLError 异常，错误原因是 timed out。因此我们可以通过设置这个超时时间来控制一个网页如果长时间未响应就跳过它的抓取，利用 try，except 语句就可以实现这样的操作。 123456789import urllib.request import socket import urllib.error try: response = urllib.request.urlopen('http://httpbin.org/get',timeout=0.1) except urllib.error.URLError as e: if isinstance(e.reason, socket.timeout): print("Time out!") 在这里我们请求了 http://httpbin.org/get 这个测试链接，设置了超时时间是0.1秒，然后捕获了 urllib.error.URLError 这个异常，然后判断异常原因是超时异常，就得出它确实是因为超时而报错，打印输出了 TIME OUT，当然你也可以在这里做其他的处理。运行结果如下： 1Time out! 常理来说，0.1秒内基本不可能得到服务器响应，因此输出了 TIME OUT 的提示。这样，我们可以通过设置 timeout 这个参数来实现超时处理，有时还是很有用的。其他参数还有context参数，它必须是 ssl.SSLContext 类型，用来指定 SSL 设置。cafile 和capath 两个参数是指定 CA证书 和它的路径，这个在请求 HTTPS 链接时会有用。cadefault 参数现在已经弃用了，默认为 False。以上讲解了 url.request.urlopen() 方法的用法，通过这个最基本的函数可以完成简单的请求和网页抓取，如需详细了解，可以查看官方文档：https://docs.python.org/3/library/urllib.request.html urllib.request.Request() 使用方法由上我们知道利用 urlopen() 方法可以实现最基本的请求发起，但这几个简单的参数并不足以构建一个完整的请求，如果请求中需要加入 headers 等信息，我们就可以利用更强大的 Request 类来构建一个请求。首先我们用一个实例来感受一下 Request 的用法: 12345import urllib.request request = urllib.request.Request("https://www.baidu.com") response = urllib.request.urlopen(request) print(response.read().decode("utf-8")) 可以发现，我们依然是用 urlopen() 方法来发送这个请求，只不过这次 urlopen() 方法的参数不再是一个 URL，而是一个 Request，通过构造这个这个数据结构，一方面我们可以将请求独立成一个对象，另一方面一个请求可配置的参数将更加丰富和灵活。下面我们看一下 Request 都可以通过怎样的参数来构造，它的构造方法如下： urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None) 第一个参数是请求链接，这个是必传参数，其他的都是可选参数。data 参数如果要传必须传 bytes(字节流) 类型的，如果是一个字典，可以先用 urllib.parse.urlencode() 编码。headers 参数是一个字典，你可以在构造 Request 时通过 headers 参数传递，也可以通过调用 Request 对象的 add_header() 方法来添加请求头。请求头最常用的用法就是通过修改 User-Agent 来伪装浏览器，默认的 User-Agent 是 Python-urllib，你可以通过修改它来伪装成浏览器。origin_req_host 指的是请求方的 host 名称或是 IP 地址。unverifiable 指的是这个请求是否是无法验证的，默认是 False。意思就是说用户没有足够权限来选择接收这个请求的结果。例如我们请求一个 HTML 文档中的图片，但是我们没有自动抓取图像的权限，这时 unverifiable 的值就是 True。method 是一个字符串，它用来指示请求使用的方法，比如 GET，POST，PUT 等等。下面我们传入多个参数构建一个 Request 来感受一下： 1234567891011121314from urllib import request,parse url = "http://httpbin.org/post" headers = &#123; "User-Agent":'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36', "Host":'httpbin.org' &#125; dict = &#123; "name":"Germey" &#125; data = bytes(parse.urlencode(dict),encoding="utf-8") req = request.Request(url=url,data=data,headers=headers,method="POST") response = request.urlopen(req) print(response.read().decode("utf-8")) 在这里我们通过四个参数构造了一个 Request，url 即请求链接，在 headers 中指定了 User-Agent 和 Host，传递的参数 data 用了 urlencode() 和 bytes() 方法来转成字节流，另外指定了请求方式为 POST。运行结果如下： 12345678910111213141516171819&#123; "args": &#123;&#125;, "data": "", "files": &#123;&#125;, "form": &#123; "name": "Germey" &#125;, "headers": &#123; "Accept-Encoding": "identity", "Connection": "close", "Content-Length": "11", "Content-Type": "application/x-www-form-urlencoded", "Host": "httpbin.org", "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36" &#125;, "json": null, "origin": "112.10.180.190", "url": "http://httpbin.org/post"&#125; 通过观察结果可以发现，我们成功设置了 data，headers 以及 method 参数，并完成了请求。另外 headers 也可以用 add_header() 方法来添加： 12req = request.Request(url=url, data=data, method='POST')req.add_header('User-Agent', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36') 如此一来，我们就可以更加方便地构造一个 Request，实现请求的发送。 urllib.request 高级特性在上面的过程中，我们虽然可以构造 Request，但是一些更高级的操作，比如 Cookies 处理，代理该怎样来设置？接下来就需要更强大的工具 Handler 登场了。简而言之你可以把它理解为各种处理器，有专门处理登录验证的，有处理 Cookies 的，有处理代理设置的，利用它们我们几乎可以做到任何HTTP请求中所有的事情。首先介绍下 urllib.request.BaseHandler，它是所有其他 Handler 的父类，它提供了最基本的 Handler 的方法，例如 efault_open()、protocol_request() 等。接下来就有各种 Handler 类继承这个 BaseHandler，列举如下： HTTPDefaultErrorHandler：用于处理HTTP响应错误，错误都会抛出 HTTPError 类型的异常。 HTTPRedirectHandler：用于处理重定向。 HTTPCookieProcessor：用于处理 Cookie 。 ProxyHandler：用于设置代理，默认代理为空。 HTTPPasswordMgr：用于管理密码，它维护了用户名密码的表。 HTTPBasicAuthHandler：用于管理认证，如果一个链接打开时需要认证，那么可以用它来解决认证问题。 另外还有其他种类的 Handler，可以参考官方文档：https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler 另外一个比较重要的就是 OpenerDirector，我们可以称之为 Opener，我们之前用过 urllib.request.urlopen() 这个方法，实际上它就是一个 Opener。那么为什么要引入 Opener 呢？因为我们需要实现更高级的功能，之前我们使用的 Request、urlopen() 相当于类库为你封装好了极其常用的请求方法，利用它们两个我们就可以完成基本的请求，但是现在不一样了，我们需要实现更高级的功能，所以我们需要深入一层，使用更上层的实例来完成我们的操作。所以，在这里我们就用到了比调用 urlopen() 的对象的更普遍的对象，也就是 Opener。Opener 可以使用 open() 方法，返回的类型和 urlopen() 如出一辙。那么它和 Handler 有什么关系？简而言之，就是可以利用 Handler 来构建 Opener。 认证 我们先用一个实例来感受一下： 1234567import urllib.request auth_handler = urllib.request.HTTPBasicAuthHandler() auth_handler.add_password(realm='PDQ Application', uri='https://mahler:8092/site-updates.py', user='klem', passwd='kadidd!ehopper') opener = urllib.request.build_opener(auth_handler) urllib.request.install_opener(opener) urllib.request.urlopen('http://www.example.com/login.html') 此处代码为实例代码，用于说明 Handler 和 Opener 的使用方法。在这里，首先实例化了一个 HTTPBasicAuthHandler 对象，然后利用 add_password() 添加进去用户名和密码，相当于建立了一个处理认证的处理器。接下来利用 urllib.request.build_opener() 方法来利用这个处理器构建一个 Opener，那么这个 Opener 在发送请求的时候就具备了认证功能了。然后利用 Opener的open() 方法打开链接，就可以完成认证了。 代理 如果添加代理，可以这样做： 123456789import urllib.request proxy_handler = urllib.request.ProxyHandler(&#123; 'http': 'http://218.202.111.10:80', 'https': 'https://180.250.163.34:8888' &#125;) opener = urllib.request.build_opener(proxy_handler) response = opener.open('https://www.baidu.com') print(response.read()) 此处代码为实例代码，用于说明代理的设置方法，代理可能已经失效。 在这里使用了 ProxyHandler，ProxyHandler 的参数是一个字典，key 是协议类型，比如 HTTP 还是 HTTPS 等，value 是代理链接，可以添加多个代理。然后利用 build_opener() 方法利用这个 Handler 构造一个 Opener，然后发送请求即可。 Cookies 设置 我们先用一个实例来感受一下怎样将网站的 Cookie 获取下来。 12345678import http.cookiejar, urllib.request cookie = http.cookiejar.CookieJar() handler = urllib.request.HTTPCookieProcessor(cookie) opener = urllib.request.build_opener(handler) response = opener.open('http://www.baidu.com') for item in cookie: print(item.name+"="+item.value) 首先我们必须声明一个 CookieJar 对象，接下来我们就需要利用 HTTPCookieProcessor 来构建一个 handler，最后利用 build_opener 方法构建出 opener，执行 open() 即可。运行结果如下： 123456BAIDUID=2B835BFCEDF4325F88D0C6C3A4EBD649:FG=1BIDUPSID=2B835BFCEDF4325F88D0C6C3A4EBD649H_PS_PSSID=1427_24569_21091_18559_25178PSTM=1512660072BDSVRTM=0BD_HOME=0 可以看到输出了每一条 Cookie 的名称还有值。不过既然能输出，那可不可以输出成文件格式呢？我们知道很多 Cookie 实际也是以文本形式保存的.答案当然是肯定的，我们用下面的实例来感受一下： 12345678import http.cookiejar, urllib.requestfilename = 'cookie.txt' cookie = http.cookiejar.MozillaCookieJar(filename) handler = urllib.request.HTTPCookieProcessor(cookie) opener = urllib.request.build_opener(handler) response = opener.open('http://www.baidu.com') cookie.save(ignore_discard=True, ignore_expires=True) 这时的 CookieJar 就需要换成 MozillaCookieJar，生成文件时需要用到它，它是 CookieJar 的子类，可以用来处理 Cookie 和文件相关的事件，读取和保存 Cookie，它可以将 Cookie 保存成 Mozilla 型的格式。运行之后可以发现生成了一个 cookie.txt 文件。内容如下： 12345678910# Netscape HTTP Cookie File# http://curl.haxx.se/rfc/cookie_spec.html# This is a generated file! Do not edit..baidu.com TRUE / FALSE 3660143901 BAIDUID 96CAB1FCD2CD9F4D304DE943A7018842:FG=1.baidu.com TRUE / FALSE 3660143901 BIDUPSID 96CAB1FCD2CD9F4D304DE943A7018842.baidu.com TRUE / FALSE H_PS_PSSID 1453_19034_21117_17001_25177.baidu.com TRUE / FALSE 3660143901 PSTM 1512660254www.baidu.com FALSE / FALSE BDSVRTM 0www.baidu.com FALSE / FALSE BD_HOME 0 另外还有一个 LWPCookieJar，同样可以读取和保存 Cookie，但是保存的格式和 MozillaCookieJar 的不一样，它会保存成与 libwww-perl 的 Set-Cookie3 文件格式的 Cookie。那么在声明时就改为 cookie = http.cookiejar.LWPCookieJar(filename)生成的内容如下：由此看来生成的格式还是有比较大的差异的。 1234567#LWP-Cookies-2.0Set-Cookie3: BAIDUID="A84BFF86A8AACB4C3B4CD734F7D11193:FG=1"; path="/"; domain=".baidu.com"; path_spec; domain_dot; expires="2085-12-25 18:40:37Z"; version=0Set-Cookie3: BIDUPSID=A84BFF86A8AACB4C3B4CD734F7D11193; path="/"; domain=".baidu.com"; path_spec; domain_dot; expires="2085-12-25 18:40:37Z"; version=0Set-Cookie3: H_PS_PSSID=25292_1433_24885_21104_18560_17001_25178_20930; path="/"; domain=".baidu.com"; path_spec; domain_dot; discard; version=0Set-Cookie3: PSTM=1512660390; path="/"; domain=".baidu.com"; path_spec; domain_dot; expires="2085-12-25 18:40:37Z"; version=0Set-Cookie3: BDSVRTM=0; path="/"; domain="www.baidu.com"; path_spec; discard; version=0Set-Cookie3: BD_HOME=0; path="/"; domain="www.baidu.com"; path_spec; discard; version=0 那么生成了 Cookie 文件，怎样从文件读取并利用呢？下面我们以 LWPCookieJar 格式为例来感受一下： 12345678import http.cookiejar, urllib.requestcookie = http.cookiejar.LWPCookieJar() cookie.load('cookie.txt', ignore_discard=True, ignore_expires=True) handler = urllib.request.HTTPCookieProcessor(cookie) opener = urllib.request.build_opener(handler) response = opener.open('http://www.baidu.com') print(response.read().decode('utf-8')) 前提是我们首先利用上面的方式生成了 LWPCookieJar 格式的 Cookie，然后利用 load() 方法，传入文件名称，后面同样的方法构建 handler 和 opener 即可。运行结果正常输出百度网页的源代码。 小结 urllib 是 Python3 中写爬虫程序的得力助手，它很好，当然，也有比它更好的。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3爬虫之基本概念]]></title>
    <url>%2F2017%2F12%2F07%2FPython3%E7%88%AC%E8%99%AB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[学了 Python 也有一段时间了，这几天才开始去接触爬虫，再一次感叹 Python 的强大。而爬虫是之前一直接触的名词，但自以为一直没有学好基础，就一直没有去接触，在这次在学习的过程中，终于揭开了它的面纱。 爬虫，顾名思义，就是一只会爬行的虫子，如果把网络比喻成一张网，爬虫就是爬行在这张网上的小蜘蛛，网所及之处，都是它能到达的地方。顺到网页所在之处，获取需要的大量数据，就是爬虫的意义所在。简而言之，它就是一个能请求网站并提取其中的数据的自动化程序。 爬虫基本流程 发起请求：通过 HTTP 库向目标站点发起请求，即发送一个 Request，请求可以包含额外的 headers、data 等信息，等待服务器响应。 获取响应内容：如果服务器能正常响应，会得到一个 Response，Response 的内容便是所要获取的页面内容，类型可能有 HTML，JSON 字符串，二进制数据（如图片视频）等类型。 解析内容：得到的内容可能是HTML，可以用正则表达式，网页解析库进行解析，可能是 JSON，可以直接转为 JSON 对象解析，可能是二进制数据，可以做保存或者进一步的处理。 保存数据：保存形式多样，可以保存为文本，也可以保存至数据库，或者保存至数据库，或者保存特定格式的文件。 那么什么是 Request 和 Response 呢？ 首先要了解一下 HTTP 协议，这里简单说一下。在 HTTP 协议中，请求访问文本或图像资源的一端称为客户端，而提供资源响应的一端称为服务器端。在我们用浏览器访问一个网页时，浏览器和远在云端的服务器其实就分别扮演着客户端和服务端的角色。 当浏览器发送消息给我们请求的网页所在的服务器时，这个过程就是 HTTP Request。 服务器收到浏览器发送的消息后，能够根据浏览器发送消息的内容，采取相应处理，然后把消息传回给浏览器，这个过程叫做 HTTP Response。 浏览器收到服务器的 Response 信息后，会对信息进行相应处理，然后展示。 下面分别来看看 Request 和 Response 的内容 Request 请求方式：主要有 GET、POST 两种请求类型，另外还有不常用的 HEAD、PUT、DELETE、OPTIONS 请求类型等。 请求 URL：URL 全称为统一资源定位符，它就像人们可以通过自己所在的地址来定位自己一样，URL 通过资源所在的位置来唯一确定资源，如一个网页文档、一张图片、一个视频都能用 URL 来唯一确定。 请求头：Headers 包含请求时所包含的头部信息，如 User-Agent、Host、Cookies 等信息。 请求体：请求时额外携带的数据，如在网页提交时需要提交表单信息 data。 Response 响应状态：有多种表示响应状态的状态码，如200表示成功，301表示跳转，404表示找不到页面，502表示服务器发生错误。（2XX成功，3XX重定向，4XX客户端错误，5XX服务器错误） 响应头：如内容类型、内容长度、服务器信息、设置 Cookies 等。 响应体：这是 Response 种最重要的部分，包含了请求资源的内容，如网页的 HTML、二进制信息图片视频等。 12345import requestshtml = requests.get("http://www.baidu.com") #一个普通的GET请求print(html.text) print(html.status_code) #返回结果状态码 如何处理所得数据呢？（网页、图片、视频等其他数据） 话不多少，直接处理二进制数据。 用 JSON 解析。 “只是用来写”的正则表达式。 BeautifulSoup，强大的 Python 第三方解析库。 PyQuery、XPath 等。 当然，有时候我们通过 HTTP 访问库访问网页的结果与浏览器加载后所看到的不一样，这就涉及到了JavaScript 的渲染问题。可以通过分析 Ajax 请求、Selenium/WebDriver、Splash、PyV8 和 Ghost.py 等来解决。 12345from selenium import webdriverdriver = webdriver.Chrome()driver.get('http://www.taobao.com') #可驱使Chrome浏览器去访问网页print(driver.page_source) 怎样保存数据呢？ 文本：纯文本、JSON、XML 等。 关系型数据库：如 MySQL、Oracle、SQL Server 等具有结构化表结构形式存储。 非关系型数据库：如 MongoDB、Redis 等 Key-Value 形式存储。 二进制文件：如图片、视频、音频等直接保存成特点格式即可。 END 基本概念就是这些了，HTTP 协议想了解得更清楚一些的话可以去看看图解 HTTP，另外用 Python 写爬虫需要安装一些第三方库，可使用 pip 方法下载，以后再补充好了。]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown使用教程]]></title>
    <url>%2F2017%2F10%2F30%2FMarkdown%2F</url>
    <content type="text"><![CDATA[Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。总之，Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 以上文字引用自 Markdown 语法说明(简体中文版) 显而易见，Markdown有以下优点： 它是纯文本发布的，所以兼容性很强，可以用所有的文本编辑器打开并编写。 它让你更专注于文字的内容而不是无谓的排版。 它的格式转换方便，你可以轻松的将 Markdown 的文本转换为 HTML、电子书等。 它的标记语法有极好的可读性。 那就来学学吧🤔 标题 一篇文章都是从标题开始的，为了得到如上所示的标题，我们需要在 Markdown 编译器里输入： 1## 标题 # 号之后记住要加上空格，## 两个井号代表这是一个二级标题。 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 现在看看其他标题的大小： 一级标题二级标题三级标题四级标题五级标题六级标题粗体和斜体 有时候我们想对文章的几个字或者一段话进行强调，那强调的一般方法就是加粗了。Markdown 的粗体和斜体的表示非常简单，用一对 ** 包含一段文字就是粗体的表示方法，用一对 * 包含一段文字就是斜体的表示方法。 1**看我是不是变粗啦** *看我是不是变斜啦* 看我是不是变粗啦 看我是不是变斜啦 列表 列表分为无序列表和有序列表。在 Markdown 下，只要在文字前加上 - 或 * 即可变为无序列表，在文字前加上 1. 2. 3. 即可变为有序列表。划重点：要在符号和文字之间加上一个空格。 1234567891011* 一* 二* 三- 一- 二- 三1. 一2. 二3. 三 一 二 三 一 二 三 一 二 三 也可以对列表进行嵌套： 12345* 第一部分 * 第一小节（一般嵌套是缩进是四个空格~） * 第一小小节 * 第二小小节 * 第二小节 第一部分 第一小节（一般嵌套是缩进是四个空格~） 第一小小节 第二小小节 第二小节 * 可用 + - 替代。 引用 文章中引用一段话也是很普遍的，就像本篇教程首段也引用了 Markdown 官方的宗旨。引用时，只需要在文字前加入 &gt; 大于号即可。 1&gt;你是我唯一想要的了解。——《七里香》 你是我唯一想要的了解。——《七里香》 插入链接和图片 美观富有哲思的文章里少不了图片和链接。使用 [链接名称](链接地址) 的格式插入链接，图片与链接大部分相同，只是多在前面加了一个 ! ,也就是使用 ![图片名称](图片地址) 的格式插入图片。 123[百度一下，你就知道](https://www.baidu.com/)![柚子](Markdown/favicon.ico) 百度一下，你就知道 描述图片位置的时候我使用了相对位置描述图片相对于我的这篇文章的位置。 分隔线 为了清晰划分文章的层次，可以使用分隔线。使用连续三个 *** 或 --- 启用分隔线。 123***--- 如上所示👆 代码 身为一个程序员，在描述命令行或者代码块时，都可以使用 Markdown 优雅的引用代码框。 当只是引用少量的只是一行的代码时，可以用一对反引号 ` 包围代码： 1`hexo server` hexo server 当引用数量较大的行数较多的代码时，可以用一对三个反引号 ` 包围代码块： 12def Hello(): print("Hello World!") 还可以直接将代码块缩进四个空格或一个制表符引入代码框（如果是在嵌套列表中进行缩进，是要缩进4×当前属于第几层嵌套，如果是第二层嵌套就应该是缩进八个空格，以此类推）： Hello World! 贴上部分编写源码。 这里在三引号那里写入 Python 是为了表示所插入代码是 Python 语言编写的，这样可以使渲染引擎在此代码块区域对代码进行更好的渲染。另外在使用三引号括起代码块或缩进引用代码框时，最好在代码块上下两行各空一行且三引号最好放在代码上下行，以防不可抗力因素。（单引号括起就不需要空行了，可直接内嵌在文字中。） PS：反引号是在英文模式下的 ~ 键打出来的。 并且在 Hexo Next 主题渲染后发现单引号括起的代码只是简单的灰底，三引号括起的代码是带有序号的黑底代码框，四空格缩进的代码是无序号的黑底代码框，也许 Markdown 最终的显示跟渲染引擎有很大的关系吧… 小贴士 Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\ 反斜线 ` 反引号 * 星号 _ 底线 &#123;&#125; 花括号 [] 方括号 () 括弧 # 井字号 + 加号- 减号. 英文句点! 惊叹号 类似 C 语言的转义字符，满足 \特殊字符 的格式即可引用在文中了。 在写一篇文章时，我们往往想要在首行空两个空格，这时可以在段首加入 &amp;emsp; &amp;emsp; 来输入两个空格。 添加空行是可以结束先前的格式状态的，所以在想要改变格式，如插入列表或者引入代码框时，最好都添加一个空行。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub+Mac安装教程]]></title>
    <url>%2F2017%2F10%2F30%2FHexo%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[其实这个博客用了半天就搭好了。但是在主题和个人偏好设置方面真的是很痛苦，不断钻研最后才弄得算是拿得起台面了一些，现在分享一下我的经验。 首先，什么是 Hexo？什么是静态博客呢？ Hexo出自台湾大学生 tommy351 之手，是一个基于 Node.js 的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到 GitHub Pages，BAE，SAE 等平台上。 而静态博客相较于动态博客，它编译之后是纯 HTML 页面，支持它的环境十分好找，如 GitHub Pages；而选择在 VPS 上面搭建动态博客，这些 VPS 供应商往往是：“免费的不稳定，稳定的不免费”。那么，可以利用免费的资源搭载属于自己的稳定的个人博客，不是很爽吗？ 步骤 安装 Git 其实 mac 上只要安装了 Xcode 也就默认安装了 git，这里就直接推荐各位去 AppStore 下载 Xcode 了，顺便配置一下即可 👉 Xcode:在 Mac App Store 上的内容 另外推荐一下廖大的教程：廖雪峰git教程 安装 Node.js 使用 brew 安装 Node.js，安装 brew 之前要先安装命令行工具，如果安装了 Xcode 也就不需要安装了，所以建议还是先直接安装 Xcode 吧…安装完 Xcode 之后按组合键：command + 空格 打开 Spotlight 搜索，输入终端打开终端。 安装 Homebrew（终端粘贴如下代码即可）。 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装完brew后，终端输入 brew install node 安装 Node.js 即可。 安装 Hexo 同理，在终端一行一行输入如下命令： 123456sudo npm install -g hexo #下载安装Hexo。mkdir blog #在当前位置新建blog文件夹。cd blog #切换到blog目录。hexo init #初始化。hexo generate #生成静态文件。hexo server #启动本地服务，进行文章预览调试。 本地调试 现在打开 http://localhost:4000 就能看到默认的 Hexo 界面了。 但是，这还不够，因为你想展示你的博客给所有人看，所以你还要将你的页面托管起来。 注册 GitHub 账号与配置 SSH 参考教程 利用SSH建立远程链接 配置GitHub 建立 Repository，建立与你用户名对应的仓库，仓库名必须为 [your-name.github.io]，这是固定写法。 Spotlight 搜索我们之前创建的 blog 文件夹，里面有 _config.yml 文件，打开找到 deploy 字段，修改为： 1234deploy: type: git repo: https://github.com/your-name/your-name.github.io.git branch: master 保存以上修改后在终端输入：npm install hexo-deployer-git --save 成功后再执行命令：hexo deploy 然后在浏览器中输入 http://your-name.github.io/ 会发现你的博客可以通过这个网址打开了。 PS：记得把 your-name 改成你的 github 的账户名。 博客 博客部署 以后部署到GitHub Pages的步骤，可在终端按以下三步来进行。 123hexo clean #清除缓存文件 (db.json) 和已生成的静态文件 (public)。 hexo generate #生成静态页面至public目录。hexo deploy #将生成的目录部署到GitHub上。 当想在本地调试时，可以在终端切换到blog文件夹，使用hexo server命令启动服务器。默认情况下，访问网址为： http://localhost:4000/。即可预览产生的博客界面。 常用命令👇： 1234hexo new &quot;postname&quot; #新建文章hexo new page &quot;pagename&quot; #新建页面hexo help #查看帮助hexo version #查看Hexo的版本 博客主题 配置好博客后也许你会觉得你的博客界面并不靓丽，这就需要强大的主题了，可在以下三个链接中了解一下主题。 知乎：Hexo有哪些好看的主题？ 主题 | Hexo 还有我现在用的主题 NexT | Pisces 主题配置 每个主题都是有文档对其进行详细的描述的，这里不细说，发掘配置也是搭建这个博客的乐趣所在哈。 后记 搭好并配置完这个博客的时候还是很开心的，像是将之前学的 git、HTML 和命令行知识进行了融会贯通一般。小宝很可爱，JavaScript 很有趣，Holen 学长很 cool，前路漫漫，继续向前看吧。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS常用命令]]></title>
    <url>%2F2017%2F10%2F30%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[先来讲讲 macO S和 Unix 还有 Linux 的关系 Unix 最早是在贝尔实验室开发的，是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统。为主要的工作站平台和重要的企业操作平台。它主要安装在巨型计算机、大型机上作为网络操作系统使用，也可用于个人计算机和嵌入式系统。曾经是服务器操作系统的首选。 Linux 是一类类 Unix 计算机操作系统的统称。Linux 操作系统的内核的名字也是 “Linux”。Linux 操作系统也是自由软件和开放源代码发展中最著名的例子。严格来讲，Linux 这个词本身只表示 Linux 内核，但在实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统。Linux 得名于计算机业余爱好者 Linus Torvalds。一般可以认为，Linux 是一套自由使用（一般可以免费使用）和自由传播的类 Unix 操作系统。这个系统是由世界各地成千上万的程序员设计和实现的。其目的是建立不受任何商品化软件的版权制约、全世界都能自由使用的 Unix 兼容产品。实际上，Linux 仅仅的 Linux 操作系统中的核心（kernel）。 Mac 系统是苹果机专用系统，是基于 Unix 内核的图形化操作系统，一般情况下在普通 PC 上无法安装的操作系统。 所以说 Linux 是兼容 Unix 的，或者说是 Linus 写的一种开源的类 Unix系统，而 macOS 的内核其实就是 Unix。所以在同一种 shell 环境下，macOS 和 Linux 的许多命令是共通的，这里所说的 macOS 常用命令其实就是兼容大部分 Linux 系统的终端命令。 两种路径：绝对路径和相对路径 再来说说比较重要的路径 绝对路径：完整描述一个文件的位置，总是以斜杠 /（forward slash）开头。例如 /Users/michelle/Public/Drop Box。相对路径：只描述一部分位置信息，它和你在 command line 目前的目录有关。当你打开新的 Terminal 程序时，command line 会话的目录应该是你的 home folder。这时上面例子文件夹的相对路径写作Public/Drop Box。显然它从当前目录开始。和 HTML 类似，你也可以使用两个点.. 来代表父目录，这样你就可以用相对路径表示上级或同级目录了。例如你可以输入 cd .. 甚至 cd ../.. 来返回上级目录。 常用命令💻 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364ls (list directory contents) 列出当前目录的内容ls -l 列出当前目录文件详细信息l(list)ls -a 列出当前目录下所有文件及目录，包括隐藏的文件和目录 (a=all)mkdir 创建目录mkdir -p 创建目录，若无父目录，则创建 p(parent) rmdir 删除目录 (rmdir dir)cd (change directory) 改变当前目录到指定目录 (cd .. 返回上一目录)touch 创建空文件，可 touch test.txt 或者 touch 文件夹名/test.txt (在指定文件夹创建空文件)echo 创建带有内容的文件cat 查看文件内容cp 复制文件或目录 (cp file1 file2)cp -r 复制目录内所有内容mv 改变文件名或移动其所在目录 (mv file1 file2)mv -r 移动目录到另一目录 (mv dir1 dir2) rm 删除文件rm -r 递归删除，可删除子目录及文件rm -f 强制删除rm -rf 删除文件夹 pwd (print working directory) 显示当前目录的绝对路径vim 创建并编辑文件 (先按i插入文字，完成后按esc再按：wq保存并退出) (esc :q! 放弃修改编辑内容直接退出)control+d 退出 Python3vim test.c 编写 C 文件gcc test.c 编译 C 文件./a.out 运行 C 文件control+C 中止一个错误的或者发疯的命令control+L 清屏Mac 下常见 vim 的命令： 1. 在默认的&quot;指令模式&quot;下按 i 进入编辑模式 2. 在非指令模式下按 ESC 返回指令模式 3. 在&quot;指令模式&quot;下输入: :w 保存当前文件 :q 退出编辑,如果文件为保存需要用强制模式 :q! 强制退出不保存修改 :wq 组合指令, 保存并退出 4. 在“指令模式”下移动: h 左 j 下 k 上 l 右 shutdown -r 关机重启 -h 关机不重启 now 立刻关机halt 关机reboot 重启find 在文件系统中搜索某文件wc 统计文本中行数、字数、字符数grep 在文本文件中查找某个字符串tree 树形结构显示目录，需要安装 tree 包ln 创建链接文件more、less 分页显示文本文件内容head、tail 显示文件头、尾内容ctrl+alt+F1 命令行全屏模式 偶然看到这个博客，顺便贴上：Mac OS X Terminal 101：终端使用初级教程 未完待续。]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Disneyland 游玩攻略✨]]></title>
    <url>%2F2017%2F10%2F25%2FDisneyland%2F</url>
    <content type="text"><![CDATA[我想和你去，梦的城堡。 简述🦄 上海迪士尼乐园目前共分六个主题园区，分别是：以米奇和他的欢乐伙伴们为主题设计的迎宾大道 — 米奇大街；展现自然奇妙又充满想象力的花园设计主题区 — 奇想花园；完美呈现迪士尼电影世界之 — 梦幻世界；探寻神秘远古部落的冒险乐园 — 探险岛；惊险热闹的海盗世界 — 宝藏湾；科技打造的未来感满满的酷炫天地 — 明日世界。（在建的第七个主题园区 — 玩具总动园 将于2018年开放)除了遍布商店和餐馆的米奇大道外，每个园区都设置了与其主题相对应的游乐项目，各具特色，充满无穷的想象力和无尽的乐趣。除了亲身体验的游乐项目，各园区还有精心安排的表演秀，为你带来一场场视听盛宴。此外，各园区都有一些迪士尼经典人物形象出没，有专门的“与迪士尼朋友见面”环节，看到自己喜欢的卡通形象一定要记得合影留念哦。 步骤🎃 1 门票：抽奖得到了一张并低价向另一名中奖者买。 2 时间：工作日九点开园，节假日八点开园，最好提前40分钟，所以应该要7.20到。 3 物品：身份证，现金（要有硬币），雨伞（遮阳挡雨），充电宝，数据线，充电器，洗漱用品，舒服的鞋子，帽子，水杯，未开封的零食，雨衣（如果想玩雷鸣山漂流的话）。 4 网页：迪士尼官网 5 APP: 导航软件(百度地图等)，迪士尼度假区 app，乐拍通 app（找准位置，安排行程很重要）。 6 交通：迪士尼乐园在上海地铁11号线的终点站，交通方便。 7 酒店：迪士尼附近的酒店都很贵，其实找个地铁11号线沿线附近的酒店就可以了。 PS：开封后的饮料、牛奶和自拍杆都不能带入院内。 正篇☀️ 入园后，记得拿好门票、乐园指南和时间表。门票用来取 FP 卡（快速通道卡），乐园指南里面有详细的地图和项目介绍，时间表用来查看各个演出的时间。左边右边米奇大道都不要停留，也不要被一进门被光鲜的玩具们拖慢了脚步。立刻飞奔向明日世界附近的游客中心领取创极速光轮的快速通行证才是最重要的！ 🌟一定要领 FP！领 FP！领 FP！重要的事说三遍！ （当然如果人特别多的话就直接跑去排队，因为这时候排队拿卡一般只能排到下午的时间。） FP 卡在各区域的快速卡领取点领取，领取点可以在入园指南的地图里找。若有什么不懂的，可以直接问机器附近的工作人员。 FP 是高效玩转迪士尼的制胜法宝，一些热门景点经常要排队三四个小时，但是领了 FP 后，就可以在它指定的时间范围内直接去玩，不用排队。 由于一张门票一次只能领一张 FP，一张 FP 只能作用于一个景点，所以建议不要浪费，还是用在创极速光轮或者飞跃地平线这种排队排到天荒地老的大项目上。预约过FP后就要再过两个小时后才能预约下一个项目，这个时候如果想要预约第二个项目，就要看看有没有运气了。因为 FP 每天是有数量限制的，派完为止，一般中午后就领不到了。 News：9月7日上海迪士尼度假区发布，将在今年秋季推出电子版快速通行证，只需下载官方 app，走过入园闸机后使用 app 扫描关联门票或季卡，即可领取电子版快速通行证，无需再往来于游客服务中心。两次领取间隔为2小时，或前一张快速通行证已使用后才能领取第二张，先到先得，发完为止。游客将能以更高效、灵活的方式享受迪士尼快速通行证服务，且无需额外付费。届时，游客可以通过上海迪士尼度假区官方手机应用程序（app）获取电子版迪士尼快速通行证，而无需匆忙地来往于指定的游客服务中心领取。游客在入园后，可把已激活的乐园门票与手机应用程序关联，按照提示进行浏览、选择及预约迪士尼快速通行证，并可随时查看快速通行证的使用时间。使用时，游客在选定景点的快速通行证入口扫描他们的手机或乐园门票上的二维码，在快速通行证以及与乐园门票相关联的游客照片验证成功后，游客便可快捷地体验景点。 划重点⚡️ FP 不用再去游客中心排队领取了，也就是说进园后不必再不顾一切地向右跑了！ 迪士尼快速通行证每日限量发行，不可转让。两次领取间隔为2小时，或前一张快速通行证已使用后才能领取第二张，先到先得，发完为止。也就是说使用你的 FP 在验票时一定要用关联本人的门票，其次，虽然不用再往右跑了，但激活门票后也要在 app 上拼手速抢热门项目的 FP 啊！而且要密切关注下一次领 FP 的时间。 FP变成了电子版，也就是说你不会再手持一张纸质版的快速通行证进行验票了，所有的 FP 都与你的门票相关联，走FP通道验票验的也是你的门票。 游客中心领 FP 的传统方法没有被废，如果你想，还是可以去那里领，在自助机器上扫描门票，电子版 FP 就被关联上了。 1234567FP能用的7个项目： 明日世界：创极速光轮⭐️、巴斯光年星际营救 探险岛：飞跃地平线⭐️、雷鸣山漂流 梦幻世界：小飞侠天空奇遇、七个小矮人矿山车、小熊维尼历险记 单人通道（人太多时可选择）： 创极速光轮、雷鸣山漂流、 加勒比海盗-沉落宝藏之战、七个小矮人矿山车 未完待续。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>Disneyland</tag>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
