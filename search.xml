<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python密码学不完全指北]]></title>
    <url>%2F2018%2F03%2F05%2FPython%E5%AF%86%E7%A0%81%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[“这是成为黑客的必经之路。” 什么是密码学？密码学是一门非常古老的学科，是把人们能够读懂的消息变换成不易读懂的信息用来隐藏信息内容，使得窃听者无法理解消息的内容，同时又能够让合法用户把变换的结果还原成能够读懂的消息。 密码学的发展经历了3个阶段：（1）古典密码。这个时期的密码应该被称之为艺术，而不是科学，是古代人民智慧的结晶，典型的密码有阴符、藏头诗、石蜡密信、反切密码（明代戚继光）、凯撒密码和天书等。（2）近代密码。1949年，伟大科学家香农发表了著名的《保密系统的通信理论》和《通信的数学理论》两篇文章，使得密码学从此由艺术走上了科学的道路，成为一门学科。（3）现代密码学。1976年，美国国家标准局公布了数据加密标准（DES），这一对称密码标准在世界上广泛流传和应用；同年，密码学家、图灵奖获得者Diffie和Hellman（2016年图灵奖）发表了《密码学的新方向》，开创了公钥密码学的新纪元。 凯撒加密法 凯撒加密法，或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。 其基本思想是：通过把字母移动一定的位数来实现加密和解密。例如，密钥代表的是把明文字母向后移动的位数。如果密钥为3，那么明文字母 B 就变成了密文的 E，依次类推，X 将变成 A，Y 变成 B，Z 变成 C。 也就是说，当密钥 key = 3 时，明文字母表和密文字母表分别是： 12明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC 使用时，加密者查找明文字母表中需要加密的消息中的每一个字母所在位置，并且写下密文字母表中对应的字母。需要解密的人则根据事先已知的密钥反过来操作，得到原来的明文。 那么，密钥有多少种可能呢？ 有26个。因为当 key = 26 时，它的效果是和 key = 0 的效果是一样的，并且密文和明文的结果是一样的。 所以，通过穷举法，是可以轻松破解凯撒加密的。 根据凯撒加密法的原理，可以得到加解密算法的函数： 12345678910111213141516171819202122232425import stringLETTERS = string.ascii_uppercase # 获得二十六个英文大写字母def CaesarCipher(message, key, mode): ''' message: 明文 key: 密钥（在0~25之间） mode: 设定模式：加密（encrypt）；解密（decrypt） ''' translated = '' # 翻译后字符串 for symbol in message.upper(): if symbol in LETTERS: index = LETTERS.find(symbol) if mode == 'encrypt': # 判断当前是加密模式还是解密模式 index = (index + key) % 26 elif mode == 'decrypt': index = (index - key) % 26 translated = translated + LETTERS[index] # 空字符串一个个加上翻译后得到的字符 else: # 如果需要翻译的字符不在26个大写字母的范围内 translated = translated + symbol return translatedprint(CaesarCipher('I love you.', 13, 'encrypt'))print(CaesarCipher('V YBIR LBH.', 13, 'decrypt')) 输出结果为： 12V YBIR LBH.I LOVE YOU. 因为加密密钥其实是知道的，根据所有的密钥对密文进行解密，得到的结果里肯定是包含正确的明文的： 1234567891011121314151617import stringLETTERS = string.ascii_uppercase # 获得二十六个英文大写字母def CaesarCipherHacker(message): '''根据密文 message 和范围在 0~25 之间的密钥 key 实施暴力破解''' for key in range(len(LETTERS)): translated = '' # 翻译后字符串 for symbol in message.upper(): if symbol in LETTERS: index = (LETTERS.find(symbol) - key) % 26 translated = translated + LETTERS[index] # 空字符串一个个加上翻译后得到的字符 else: # 如果需要翻译的字符不在26个大写字母的范围内 translated = translated + symbol print('&#123;:&gt;2&#125;: &#123;&#125;'.format(key, translated))CaesarCipherHacker('V YBIR LBH.') 输出结果为： 1234567891011121314151617181920212223242526 0: V YBIR LBH. 1: U XAHQ KAG. 2: T WZGP JZF. 3: S VYFO IYE. 4: R UXEN HXD. 5: Q TWDM GWC. 6: P SVCL FVB. 7: O RUBK EUA. 8: N QTAJ DTZ. 9: M PSZI CSY.10: L ORYH BRX.11: K NQXG AQW.12: J MPWF ZPV.13: I LOVE YOU.14: H KNUD XNT.15: G JMTC WMS.16: F ILSB VLR.17: E HKRA UKQ.18: D GJQZ TJP.19: C FIPY SIO.20: B EHOX RHN.21: A DGNW QGM.22: Z CFMV PFL.23: Y BELU OEK.24: X ADKT NDJ.25: W ZCJS MCI. 可以得到，密钥为13的结果是正确的可读的明文。 这里附上一个网页版的凯撒加密轮盘：CipherWheel 维吉尼亚加密法 人们在单一恺撒密码的基础上扩展出多表密码，称为“维吉尼亚”密码。该方法最早记录在吉奥万·巴蒂斯塔·贝拉索（ Giovan Battista Bellaso）于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的密码》（意大利语：La cifra del. Sig. Giovan Battista Bellaso）中。 所以说，虽然维吉尼亚加密法和凯撒加密法类似，但是维吉尼亚加密法拥有更多的密钥，所以也被称为多表替代加密法。而它的安全性，相较于其他古典加密法，是很高的，曾一度被称作 不可破译的加密法。 相比凯撒加密轮盘，维吉尼亚加密法形成的是一个巨大的方阵。 方阵用第一行代表明文字母，第一列代表密钥字母。它们包围的区域就是加密表，每一行都是不重复的26个字母，但下一行相对于上一行，会发生一次位移。 如果明文只用其中某一个进行加密，那么这就只是简单的恺撒加密法了。但如果用方阵中不同的行加密不同的字母，它就是一种强大的加密法了。 例如，加密者可以用第5行来加密第1个字母，再用第20行来加密第2个字母，然后根据第13行来加密第3个字母，不断选择不同的行，加密的程度也就越高。 我们可以根据上面的图对如下明文进行加密：TO BE OR NOT TO BE THAT IS THE QUESTION当选定 RELATIONS 作为密钥时，加密过程是：明文第一个字母为 T，密钥第一个字母为 R，因此可以得到 R 行 T 列的值为 K，将 T 换成 K。依此类推，得出对应关系如下： 123密钥：RELAT IONSR ELATI ONSRE LATIO NSREL明文：TOBEO RNOTT OBETH ATIST HEQUE STION密文：KSMEH ZBBLK SMEMP OGAJX SEJCS FLZSY 现在可以用代码去实现了： 12345678910111213141516171819202122232425262728293031323334353637383940import stringLETTERS = string.ascii_uppercase # 获得二十六个英文大写字母def VigenèreCipher(message, key, mode): ''' message: 明文 key: 密钥（不定长单词串） mode: 设定模式：加密（encrypt）；解密（decrypt） ''' translated = [] # # 翻译后字符串 keyIndex = 0 key = key.upper() for symbol in message: index = LETTERS.find(symbol.upper()) if index != -1: # 如果 index 等于 -1 代表 symbol 不在 LETTERS 中 if mode == 'encrypt': index = (index + LETTERS.find(key[keyIndex])) % len(LETTERS) # 判断当前是加密模式还是解密模式 elif mode == 'decrypt': index = (index - LETTERS.find(key[keyIndex])) % len(LETTERS) # 将翻译后的字符加入到 translated 列表 if symbol.isupper(): translated.append(LETTERS[index]) elif symbol.islower(): translated.append(LETTERS[index].lower()) keyIndex += 1 # 不断移动密钥的索引，如果索引与密钥长度相等，就要重新置0 if keyIndex == len(key): keyIndex = 0 else: translated.append(symbol) return ''.join(translated) # 将翻译后的字符组合成字符串print(VigenèreCipher('Nothing is possible.', 'Ariel', 'encrypt'))print(VigenèreCipher('Nfbltnx qw aojammlv.', 'Ariel', 'decrypt'))print(VigenèreCipher('I have a lot of money.', 'mathematics', 'encrypt'))print(VigenèreCipher('U htci m lhb qx yoglc.', 'mathematics', 'decrypt')) 输出结果为： 1234Nfbltnx qw aojammlv.Nothing is possible.U htci m lhb qx yoglc.I have a lot of money. Playfair 加密法 Playfair密码（英文：Playfair cipher 或 Playfair square）是一种使用一个关键词方格来加密字符对的加密法，1854年由查尔斯·惠斯通（Charles Wheatstone）的英国人发明。 它有一些不太明显的特征： 密文的字母数一定是偶数。 任意两个同组的字母都不会相同，如果出现这种字符必是乱码和虚码。 因为它使用方便而且可以让频度分析法变成瞎子，所以在1854到1855年的克里米亚战争和1899年的布尔战争中有广泛应用。但在1915年的一战中被破译了。 Playfair 加密法编写分三步： 编制密码表 整理明文 编写密文（构成部分：1.密钥 2.明文 3.密文） 加密编制密码表第一步是编制密码表。在这个 5 * 5 的密码表中，共有5行5列字母。第一行（或第一列）是密钥，其余按照字母顺序。密钥是一个单词或词组，若有重复字母，可将后面重复的字母去掉。当然也要把使用频率最少的字母去掉。并且，如果密钥同时包含 i 和 j ，密码表要去掉字母 Z；没有同时出现时就将密钥中的 J 换成 I，密码表保留 Z，I 和 J共占一位。如：密钥是 Live and learn，去掉后则为 liveandr。如果密钥过长可占用第二行或列。如密钥 crazy dog，可编制成： 0 1 2 3 4 0 C R A Z Y 1 D O G B E 2 F H I \ J K L 3 M N P Q S 4 T U V W X 或 0 1 2 3 4 0 C D F M T 1 R O H N U 2 A G I \ J P V 3 Z B K Q W 4 Y E L S X 因为书中讲解的是第一种，所以选择第一种方式。 整理明文第二步是整理明文。将明文每两个字母组成一组。如果出现两个相同的字母，则在第一个字母后添加 X 构成一组，第二个相同的字母与它后面的字母构成一组；如果一个字母与它前一组的最后一个字母相同，则在该字母前加上 X 构成一组；如果只剩下最后一个字母，则在其后添加 X 构成一组。当然，也可以将 X 换成其它字母（比如 Q）。如 communist，应整理成 CO MX MU NI ST；balloon 应整理成 BA LX LO XO NX。 编写密文加密规则： 每两个整理好的明文字符进行加密。 同行不同列：依次取右边一位。 同列不同行：依次取下边一位。 不同行且不同列：依次取对角线横向一位。 如，依照第一个表，明文 Where there is life, there is hope. 12可先整理为：WH ER ET HE RE IS LI FE TH ER EI SH OP EX 然后密文为：UK OY DX LO YO LP FK LD UF OY GL NL GN LY 解密解密规则： 同行不同列：依次取左边一位。 同列不同行：依次取上边一位。 不同行且不同列：依次取对角线竖向一位。 参考资料 百度百科 Python密码学编程 Playfair密码(C语言实现) (密码学)维吉尼亚密码加解密原理及其破解算法Java实现]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tips</tag>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[番茄工作法总结]]></title>
    <url>%2F2018%2F03%2F04%2F%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[“不得不说，这年头，番茄也能让你学会专注。” 什么是番茄工作法？ 番茄工作法是弗朗西斯科•西里洛于1992年创立的。他在大学生活的头几年，曾一度苦于学习效率低下，“于是我和自己打赌，下猛药，狠狠鄙视自己说：‘我能学一会儿习吗？真正学上10分钟？’我得找个计时教练，谁来替我掐表呢？后来我找到了，是一枚厨房定时器，形状像‘西红柿’（Pomodoro ，意大利语的‘番茄’）。就这样，我邂逅了我的番茄钟。” 番茄工作法是一套简单的工具和流程，用以提升你个人和所在团队的生产力，从而做到： 减轻时间焦虑 提升集中力和注意力，减少中断 增强决策意识 唤醒激励和持久激励 巩固达成目标的决心 完善预估流程，精确地保质保量 改进工作学习流程 强化决断力，快刀斩乱麻 什么是番茄钟？它仅仅是一个计时器，用来衡量设定好时间的时间周期。 以 25 分钟为一个番茄钟周期，周期开始时用计时器计时，抛弃脑中的时间焦虑，全身心投入手中的工作中，直到计时器响起，就立刻停止工作。以短时间作为目标，增加工作完成的满足感。每个番茄钟之间用 3~5 分钟的时间进行休息，休息时，要全身心抛开工作任务，让大脑充分吸收过去 25 分钟的脑力震荡。劳逸结合，激发下个番茄钟工作的动力。每 4 个番茄钟结束后应要多休息一会儿，时间设定为 15~30 分钟。 如何制定番茄钟？所需工具：一枚番茄钟，一支铅笔，三张白纸（表格）。 第一张纸（活动清单）：记录近期事务的活动清单，将所有最近需要做的事情（20~30项）都记录在纸上，不分顺序，完成后即可划掉。可几天共用一张 活动清单。 第二张纸（今日待办）：记录今日待办事项。每天的工作开始前，选择活动清单中的事情按照今天的可分配时间放入 今日待办 表格中，并计划好执行这一任务所需的番茄钟数。 第三张纸（记录表格）：在每天工作结束之前需要记录三个方面的信息，以便日后对比改进自己的番茄钟。 1234记录信息：①每日完成的番茄钟数。②早晨未想到后来临时加入的计划外紧急事务。③由于估计的时间不足以完成某一项目标，后来又加上的番茄钟数。 如何执行番茄钟？ 记录近期事务到 活动清单。 每天早晨从 活动清单 中选择待办事项，抄入到 今日待办。 从 今日待办 中选择一项自己觉得最重要的一项活动，开始番茄钟。 番茄钟响铃后，停下工作，休息片刻，并记下一个番茄钟标记。 休息结束，开始下一个番茄钟。 完成后活动后记录，未未完成则放到下个番茄钟去完成或者选择其它时段去完成。 晚上下班前需要总结自己的番茄钟总数、活动完成数和番茄钟进行时的中断数，并添加到 记录表格。 在之后的番茄钟设定和流程执行时，根据 记录表格 进行分析、观察和改进，得到提高。 如何去处理执行中的中断？ 内部中断（自身引起） 可控制中断：如想喝水，需要回复某人电子邮件，突然想到要给谁打电话等。解决方法：接受、记录并继续。把中断记录到今日待办中的 计划外紧急 中，并做标记进行跟踪，然后继续自己的番茄钟。等到后续某个番茄钟完成，才处理这些 计划外紧急 任务。 不可控制中断：如想上厕所，要准时抢票等。解决方法：去完成这些不可控制的中断。但回来时，需要把刚才正在进行的番茄钟作废，而不能继续进行之前的番茄钟。以防养成容易中断的习惯，这将会打乱工作节奏。 外部中断（外界引起） 可延后中断：如电话来访，电子邮件寄来，同事需要与你商讨问题等。解决方法：可以告诉别人现在自己正忙，告诉他想在稍后再与他商量或者打电话，并将这件事记录到今日待办中的 计划外紧急 中，等到之后的某个番茄钟再进行事件处理。 不可延后中断：不可抗力因素事件等。解决方法：处理事件，并报废番茄钟。 小贴士 当一个番茄钟结束后，要立刻停止工作，把对时间的依赖完全交给番茄钟。 在番茄钟内提早完成了任务，应该回顾一下所做的或者重复一下所学的，直到番茄钟结束。 一些琐碎的占用时间少的事情可以放在一个番茄钟内完成。 在休息时间内，就不要想前一个番茄钟或后一个番茄钟的事情。要把握休息时间，劳逸结合。 番茄钟的选择要在休息结束后进行。 每个番茄钟开始后，要选择当前 今日待办 列表中最重要的事，而不一定是上个番茄钟未完成的的事。这样可以确保每次做的事都是有用、高效和重要的。 番茄钟的时间是处理事务时间的最小计量单位，不可拆分。 使用番茄钟时，只要认真专注于要处理的事项即可。而对全局的纵览和思考应该放到早晨的规划中。 晚间和月底，是计量工作效率和得失的好时光。 番茄钟不是一定要设定为 25 分钟，这只是作者在进行大量实践和总结后给的建议时间。使用者可以立足于自身情况对时间进行修改（比如执行番茄钟过程中中断很多，可以适当缩减番茄钟设定时间）。但都要在执行上一次设定的番茄钟周期一段时间（比如两周）后才能确认修改，以便确定它是不是真的适合自己。频繁的更改只会打乱供暖工作节奏，带来不好的影响。毕竟，长期的执行和感受，才能真正判断它是否合适自己。 推荐 番茄工作法图解]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Tomato</tag>
        <tag>Work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python代码风格指南（自译）]]></title>
    <url>%2F2018%2F03%2F03%2FPython%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[“人生苦短，我用 Python。” 英语渣，但就是很想翻译它。 当你询问一个程序员为什么最爱 Python 语言的时候，他们常说它可读性很高。确实，高度的可读性是设计 Python 这门语言的核心。 一个使 Python 代码易读且易理解的原因是 Python 语言相对完善的编码指南和 Pythonic 风格。 并且，当一个经验丰富的 Python 开发者指着一段代码说：“这段代码并不 Pythonic” 的时候，这常常意味着这些代码没有遵循一个普遍的代码准则，没有通过最好的方式表达出它的意图。 虽然在一些极端情况下，关于如何用 Python 代码表达意图的最好方式没有达成共识，但这样的情况是比较少的。 一般概念明确的代码虽然任何类型的魔法方法都可以通过 Python 来实现，但是最明确和最直接的方式往往是最好的。 Bad 123def make_complex(*args): x, y = args return dict(**locals()) Good 12def make_complex(x, y): return &#123;'x': x, 'y': y&#125; 在上面优秀的代码中，函数明确地显式调用 x 和 y, 明确的返回相关字典。开发者通过读第一行和最后一行就可以知道函数的用法。 一行一句尽管在一些复杂语句中，例如 列表生成式 是被允许的，并且这些语句可以展现简洁的表达能力。但将不相关的语句放在同一行是很差的代码风格。 Bad 123456print 'one'; print 'two'if x == 1: print 'one'if &lt;complex comparison&gt; and &lt;other complex comparison&gt;: # do something Good 12345678910print 'one'print 'two'if x == 1: print 'one' cond1 = &lt;complex comparison&gt;cond2 = &lt;other complex comparison&gt;if cond1 and cond2: # do something 函数参数函数的参数可以有四种不同的方式： 1.位置参数位置参数是强制性的，并且它们没有默认值。它们是最简单的参数形式，可以用少量的函数参数，用来表达函数意义的全部部分，而它们的位置顺序是自然的，是被严格要求的。例如，在 send(message, recipient) 或者 point(x, y) 这些函数中，函数的使用者并不会对函数的使用觉得很困难，这些函数仅仅需要两个参数，并按照顺序传入即可。 在这两种情况下，可以在调用函数时使用参数的名称赋值，这样做可以切换参数的顺序，例如调用实例 send(recipient=&#39;World&#39;, message=&#39;Hello&#39;) 和 point(y=2, x=1)，但与直接的调用 send(&#39;Hello&#39;, &#39;World&#39;) 和 point(1, 2) 相比，这会降低可读性并且将会不必要地冗长。 2. 关键字参数关键字参数不是强制性的，并且它们具有默认值。它们通常是用于发送给函数的可选参数。当一个函数有多于两个或者三个位置参数的时候，函数参数样式就很难记忆了。这个时候，使用具有默认值的关键字参数是很有帮助的。例如，一个完整的 send 函数可以定义成 send(message, to, cc=None, bcc=None)，这里的 cc 和 bcc 参数是可选的，当没有传值时默认为 None。 使用关键字参数调用一个函数可以通过 Python 以多种方式完成。例如，可以在定义中遵循参数的顺序，而不必明确命名参数，比如 send(&#39;Hello&#39;, &#39;World&#39;, &#39;Cthulhu&#39;, &#39;God&#39;) 是将密件发送给上帝。我们也可以使用命名参数而无需遵循参数顺序来调用函数，比如 send(&#39;Hello again&#39;, &#39;World&#39;, bcc=&#39;God&#39;, cc=&#39;Cthulhu&#39;)。如果没有任何强有力的理由不去遵循最接近函数定义的语法： send(&#39;Hello&#39;, &#39;World&#39;, cc=&#39;Cthulhu&#39;, bcc=&#39;God&#39;)，那么这两种方式都应该是要极力避免的。 作为一个方面的说明，请遵循 YAGNI 原则。通常，移除一个用作“以防万一”但却看起来从未使用的可选参数（以及它在函数中的逻辑），比添加一个所需的新的可选参数和它的逻辑要来的困难。 3. 任意参数列表任意参数列表是函数传值的第三种方式，如果一个函数意图通过定义可扩展数目的位置参数实现更好的表达，那么可以定义 *args 的结构。在函数体中，args 是包含所有剩余参数的元组。例如，我们可以用任意长度的位置参数作为参数去调用 send(message, *args) 这个函数，比如 send(&#39;Hello&#39;, &#39;God&#39;, &#39;Mom&#39;, &#39;Cthulhu&#39;)。在此函数体中，args 相当于 (&#39;God&#39;,&#39;Mom&#39;, &#39;Cthulhu&#39;)。 尽管如此，这种结构有一些缺点，应谨慎使用。如果一个函数接收到相同性质的参数列表，通常将其定义为一个参数，这样函数为更为清晰，而这个参数可以是一个列表或其他任何序列。在这里，如果 send 参数有多个接受者，将之定义成 send(message, recipients) 会更明确。调用它时就使用 send(&#39;Hello&#39;, [&#39;God&#39;, &#39;Mom&#39;, &#39;Cthulhu&#39;])。这样的话，函数的使用者可以事先将接收者们维护成列表形式，这为传递各种不能被转变成其他序列的序列（包括迭代器）带来了可能。 4. 任意关键字参数字典关键字参数字典是最后一种函数传参的方式，如果函数要求一系列待定的命名参数，我们可以使用 **kwargs 的结构。在函数体中，kwargs 是一个 字典，它包含所有传递给函数但没有被其他关键字参数捕捉的命名参数。 和任意参数列表中所需注意的一样，这些强大的技术是要用在被证明确实需要用到它们的时候，它们不应该被用在能用更简单和更明确的结构就可以充分表达意图的函数中。 编写函数的时候采用何种参数形式，是用位置参数，还是可选关键字参数，是否使用形如任意参数列表等的高级技术，这些都由程序员自己决定的。如果能明智地遵循上面的建议，就可能且非常愉悦地写出这样的 Python 函数： 易读（名字和参数不需要解释） 易改（添加新的关键字参数不会破坏代码的其他部分） 避免魔法方法Python 对黑客来说是一个强有力的工具，它拥有非常丰富的 hooks 和 tools，允许使用者施展几乎任何形式的技巧。比如，它可以做到： 改变对象的创建和初始化的方式 改变 Python 解释器引入模块的方式 在 Python 中嵌入 C 程序代码 然而，这些操作都有着许多缺陷，更好的方式是使用最直接的方式达到目的。这些操作最主要的缺陷在于当使用这些方式时，程序可读性将发生很大改变。许多代码分析工具，例如: pylint 或者 pyflakes 是无法解析这些 &quot;magic&quot; code 的。 Python 开发者应该知道这些近乎无限的可能性，因为它让我们拥有了 没有不可能完成的任务 的自信。但是知道如何，尤其是何时不能使用它们是非常重要的。 一个 Pythonista 就像一位功夫大师，他知道如何用一个手指杀死对方，但他从不会那么去做。 我们都是负责任的用户通过上面知道 Python 有许多的技巧，但其中一些是有潜在危险的。一个好的范例是：任何用户都能够重写对象的属性和方法（Python中没有 “private” 关键字）。这种哲学不同于其他高级语言，如 Java。因为 Java 中有许多防止滥用的机制。而这种哲学其实是在表达： We are all responsible users。 这并不意味着，比如说，Python 中没有属性是私有的，也不意味着没有合适的封装方法。与其依赖在开发者和代码之间树立起的一道道隔墙，Python 社区更愿意依靠一些约定，来表明这些元素不应该被直接访问，而应该是私有的。 私有属性实现细节的主要约定是对所有的 内部变量 前添加一个下划线。如果用户破坏约定去访问前缀带有下划线的变量，当被修改后的代码产生问题时，都是客户端代码的责任。 使用这些约定是被广泛鼓励的：任何不想被客户端代码使用的属性或者方法都应该加上一个前缀下划线。这样可以更好的将代码进行职责划分，也方便对已有的代码进行修改；私有属性公有化总是有可能的，而公有属性私有化可能会是很难的操作。 返回值当一个函数变得复杂时，在函数体中使用有多个返回值的语句并不少见。然而，为了保证明确的意图和可读性，应在函数体中避免使用返回多个值的语句。 在函数中主要有两种返回情况：当函数正常运行时，返回结果；当一个错误的情况产生，返回输入错误的参数，或者其他导致函数不能正常运行的原因。 如果在第二种情况不想抛出异常，应该返回一个值（比如 None 或者 False），指明函数没有正常执行。在这种情况下，最好尽早返回检测到的错误信息。这将有利于后续改善函数的结构。 在正常情况下，当一个函数中有多个返回出口点时，会变得很难去调试和返回结果。所以最好保持单个出口点，这会有助于提取某些代码路径，并且，多个出口点往往意味着代码需要重构了。 1234567891011def complex_function(a, b, c): if not a: return None # Raising an exception might be better if not b: return None # Raising an exception might be better # Some complex code trying to compute x from a, b and c # Resist temptation to return x if succeeded if not x: # Some Plan-B computation of x return x # One single exit point for the returned value x will help # when maintaining the code. 惯用方法编程惯用方法是一种代码编写的方式，Python 的惯用方法通常被称为 Pythonic。 尽管通常有一种（而且最好只有一种）明显的方式去将代码写得 Pythonic；但对 Python 初学者来说，写出惯用法式的 Python 代码的方式是不太明显的。所以，好的惯用法必须有意识地获取。 下面是一些 Python 惯用法： 解包如果你知道一个列表或者元组的长度，你可以将其解包并为它的元素取名。比如，enumerate() 会对列表中的每个项提供包含索引和列表数据两个元素的元组： 12for index, item in enumerate(some_list): # 使用index和item做一些工作 也可以通过这种方式交换两个变量： 1a, b = b, a 嵌套解包任务： 1a, (b, c) = 1, (2, 3) 在 Python3 中，扩展解包的新方法在 PEP 3132 有介绍: 1234a, *rest = [1, 2, 3]# a = 1, rest = [2, 3]a, *middle, c = [1, 2, 3, 4]# a = 1, middle = [2, 3], c = 4 创建一个可忽略的变量如果需要赋值但不需要变量（比如，使用解包方法），可以使用 __： 12filename = 'foobar.txt'basename, __, ext = filename.rpartition('.') 注意： 123许多 Python 风格指南建议使用单下划线而不是双下划线。然而，单下划线普遍在 gettext() 函数中用作别名，也常被用在交互式命令行中保存最后一次操作的值。所以，使用双下划线更清晰方便，并能够消除一些使用情况的干扰。 创建一个长度为 N 且所有元素相同的列表1four_nones = [None] * 4 创建一个长度为 N 的列表因为列表是可变的，* 操作对于同样的列表会创建创建 N 个原列表的引用，这可能不是你想要的结果。正确的写法应该是使用列表生成式： 1four_lists = [[] for __ in xrange(4)] 注意： 1在 Python3 中应该使用 range() 而不是 xrange()。 根据列表来创建字符串根据列表来创建字符串的一个常见用法是在空的字符串上使用 str.join(list)。 12letters = ['s', 'p', 'a', 'm']word = ''.join(letters) 这会将 word 变量赋值为 spam。这个惯用法可以用在列表和元组中。 在序列中查找一个元素有时我们需要在序列中查找元素。让我们来看看这两个选择：列表和集合。 举个例子： 12345678s = set(['s', 'p', 'a', 'm'])l = ['s', 'p', 'a', 'm']def lookup_set(s): return 's' in sdef lookup_list(l): return 's' in l 即使这两个函数看起来完全一样，但因为 lookup_set(s) 是利用了 Python 中的集合类型是 可哈希 的特性，两者的查询性能是完全不同的。为了判断一个项是否在列表中，Python 将会查看每个元素直到它找到匹配的项。这是非常耗时的，尤其是对长列表来说。另一方面，在集合中，项的哈希值将会告诉 Python 应在集合的哪里去查找匹配的元素。结果是，即使集合很大，但因为哈希表的原理，查询的速度也会很快。在字典中，查询也是同样的原理。 因为这些性能上的差异，在下列场合中使用集合或者字典而不是列表，通常会是个好主意： 序列中包含大量的元素 需要在序列中重复地查找元素 序列中没有重复的项 对于小的序列，或者你不会频繁查找的序列，建立哈希所消耗的额外时间和内存开销经常会大过改进搜索速度所节省的时间和内存开销。 Python之禅也被称为 PEP 20，它是 Python 设计的指导准则。 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those!Python之禅 by Tim Peters优美胜于丑陋（Python以编写优美的代码为目标）明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）可读性很重要（优美的代码是可读的）即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）不要包容所有错误，除非您确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）当存在多种可能，不要尝试去猜测而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）虽然这并不容易，因为您不是 Python 之父（这里的 Dutch 是指 Guido ）做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）如果您无法向人描述您的方案，那肯定不是一个好方案；反之亦然（方案测评标准）命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召） 如果想要了解一些具有 Python 风格的例子，可以访问 these slides from a Python user group。 PEP8PEP 8 是 Python 事实上的代码风格指南，我们可以在 pep8.org 上获得高质量的 PEP 8 版本详细介绍。 强烈推荐阅读这部分。整个 Python 社区都尽力遵循本文档中规定的准则。一些项目可能受其影响，而其他项目可以参考修改建议。 也就是说，让你的 Python 代码遵循 PEP 8 通常是个好主意，这也有助于在与其他开发人员一起工作时使代码更加具有可持续性和维护性。命令行程序 pycodestyle（以前叫做 pep8），可以检查代码一致性。可在终端上运行以下命令来安装它： 1$ pip install pycodestyle 然后在文件或者很多文件中运行，如果检测到问题，会得到违反 PEP8 准则的报告 123456789$ pycodestyle optparse.pyoptparse.py:69:11: E401 multiple imports on one lineoptparse.py:77:1: E302 expected 2 blank lines, found 1optparse.py:88:5: E301 expected 1 blank line, found 0optparse.py:222:34: W602 deprecated form of raising exceptionoptparse.py:347:31: E211 whitespace before '('optparse.py:357:17: E201 whitespace after '&#123;'optparse.py:472:29: E221 multiple spaces before operatoroptparse.py:544:21: W601 .has_key() is deprecated, use 'in' 程序 autopep8 能自动将代码格式化成 PEP 8 风格。可用以下指令安装此程序： 1$ pip install autopep8 使用以下命令来格式化一个文件： 1$ autopep8 --in-place optparse.py 不包含 --in-place 标志将会使得程序直接将更改的代码输出到控制台，以供审查。--aggressive 标志则会执行更多实质性的变化，而且可以多次使用以达到更佳的效果。 约定遵循以下的一些约定可以以让您的代码更加易读。 检查变量是否等于常量你不需要明确的与 None、True 或者 0比较，只需要直接使用 if 语句。也可以查阅文档，来查看什么会被判定为 False。 Bad 12345if attr == True: print 'True!'if attr == None: print 'attr is None!' Good 1234567891011# Just check the valueif attr: print 'attr is truthy!'# or check for the oppositeif not attr: print 'attr is falsey!'# or, since None is considered false, explicitly check for itif attr is None: print 'attr is None!' 访问字典元素不要使用 dict.has_key() 方法，使用 x in d 语法或者传入一个默认参数到 dict.get()。 Bad 12345d = &#123;'hello': 'world'&#125;if d.has_key('hello'): print d['hello'] # prints 'world'else: print 'default_value' Good 12345678d = &#123;'hello': 'world'&#125;print d.get('hello', 'default_value') # prints 'world'print d.get('thingy', 'default_value') # prints 'default_value'# Or:if 'hello' in d: print d['hello'] 维护列表的捷径列表生成式提供了强大简洁的列表工作方式。而且，map() 和 filter() 函数是用一种不同且更简洁的语法处理列表。 Bad 123456# Filter elements greater than 4a = [3, 4, 5]b = []for i in a: if i &gt; 4: b.append(i) Good 1234a = [3, 4, 5]b = [i for i in a if i &gt; 4]# Or:b = filter(lambda x: x &gt; 4, a) Bad 1234# Add three to all list members.a = [3, 4, 5]for i in range(len(a)): a[i] += 3 Good 12345678910111213a = [3, 4, 5]a = [i + 3 for i in a]# Or:a = map(lambda i: i + 3, a)Use enumerate() keep a count of your place in the list.a = [3, 4, 5]for i, item in enumerate(a): print i, item# prints# 0 3# 1 4# 2 5 使用 enumerate() 函数比手动维护计数有更好的可读性。而且，它对 迭代器 进行了更好的优化。 读取文件推荐使用 with open 语法来读取文件，它会自动关闭读取的文件。 Bad 1234f = open('file.txt')a = f.read()print af.close() Good 123with open('file.txt') as f: for line in f: print line with 语句更好是因为它总是会去确定你的文件是否关闭，即使在 with 区块中引发了一个异常。 行的延续当一个代码逻辑行长度超过可接受的限度时，需要划分为多行，如果一行最后一个字符是反斜杠 \， Python 解释器会连接下一行。这在一些情况下很有帮助。但是它非常脆弱，应该避免使用：比如在行末反斜杠后加一个空格，可能会破坏代码结构并产生意外的结果。 一个更好的解决方案是在元素周围使用括号。左边以一个未闭合的括号开头，Python 解释器会把行的结尾和下一行连接起来直到遇到闭合的括号。同样的行为适用中括号和大括号。 Bad 123456my_very_big_string = """For a long time I used to go to bed early. Sometimes, \ when I had put out my candle, my eyes would close so quickly that I had not even \ time to say “I’m going to sleep.”"""from some.deep.module.inside.a.module import a_nice_function, another_nice_function, \ yet_another_nice_function Good 12345678my_very_big_string = ( "For a long time I used to go to bed early. Sometimes, " "when I had put out my candle, my eyes would close so quickly " "that I had not even time to say “I’m going to sleep.”")from some.deep.module.inside.a.module import ( a_nice_function, another_nice_function, yet_another_nice_function) 尽管如此，更多时候对于很长的逻辑行并没有进行划分，毕竟试图同时做更多的事情，容易影响可读性。 来源 Code Style]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB学习笔记]]></title>
    <url>%2F2018%2F03%2F02%2FMongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[“It’s mongo, not mango.” 什么是 MongoDB？ MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 MongoDB 基础概念 MongoDB 术语 解释 database 数据库 collection 集合 document 文档 field 域 index 索引 primary key 主键，MongoDB 会自动将 _id 字段设置为主键 MongoDB 数据类型几种常用的数据类型： 数据类型 描述 String 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。 Integer 整型数值。用于存储数值。根据所采用的服务器，可分为 32 位或 64 位。 Boolean 布尔值。用于存储布尔值（真/假）。 Double 双精度浮点值。用于存储浮点值。 Min/Max keys 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。 Array 用于将数组或列表或多个值存储为一个键。 Timestamp 时间戳。记录文档修改或添加的具体时间。 Object 用于内嵌文档。 Null 用于创建空值。 Symbol 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。 Date 日期时间。用 UNIX 时间格式来存储当前日期或时间。也可以指定自己的日期时间：创建 Date 对象，传入年月日信息。 Object ID 对象 ID。用于创建文档的 ID。 Binary Data 二进制数据。用于存储二进制数据。 Code 代码类型。用于在文档中存储 JavaScript 代码。 Regular expression 正则表达式类型。用于存储正则表达式。 相关操作启动 MongoDB 服务 启动 MongoDB 服务器 1$ (sudo) mongod 连接 MongoDB 1$ mongo 创建和删除数据库 创建数据库：use DATABASE_NAME 12&gt; use runoobswitched to db runoob 显示当前数据库的名称 12&gt; dbrunoob MongoDB 中默认的数据库为 test，如果没有创建新的数据库，集合将存放在 test 数据库中。 显示所有数据库 123456&gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GBrunoob 0.000GBtest 0.000GB 删除数据库 12&gt; db.dropDatabase()&#123; "dropped" : "runoob", "ok" : 1 &#125; 创建集合并插入文档 向集合中插入文档：db.COLLECTION_NAME.insert(document) 12&gt; db.runoob.insert(&#123;"a": 1, "b": 2&#125;)WriteResult(&#123; "nInserted" : 1 &#125;) 往当前数据库 runoob 新建集合 runoob 并插入数据。 显示所有集合 1234&gt; show tablesfoo&gt; show collectionsfoo 向指定集合插入单个文档 12345&gt; db.foo.insertOne(&#123;"c": 3, "d": 4&#125;)&#123; "acknowledged" : true, "insertedId" : ObjectId("5a996150bcb5714f2f2ec2d9")&#125; 默认将创建 foo 集合。 向指定集合插入多个文档 123456789&gt; db.foo.insertMany([&#123;"A": "a"&#125;, &#123;"B": "b"&#125;, &#123;"C": "c"&#125;])&#123; "acknowledged" : true, "insertedIds" : [ ObjectId("5a8ce79553f8f9f2799791ff"), ObjectId("5a8ce79553f8f9f279979200"), ObjectId("5a8ce79553f8f9f279979201") ]&#125; 根据变量插入文档 1234567891011&gt; document = (&#123;"title": "mongo", "description": "NoSQL", "tags": ["Nice", "SQL"]&#125;)&#123; "title" : "mongo", "description" : "NoSQL", "tags" : [ "Nice", "SQL" ]&#125;&gt; db.foo.save(document)WriteResult(&#123; "nInserted" : 1 &#125;) 删除集合 1234567&gt; db.test.insertOne(&#123;'a': 5&#125;)&#123; "acknowledged" : true, "insertedId" : ObjectId("5a996ad17c2937a1639592ff")&#125;&gt; db.test.drop()true 删除文档 删除所有包含 “H”: 8 键值的文档 12&gt; db.foo.remove(&#123;"H": 8&#125;)WriteResult(&#123; "nRemoved" : 3 &#125;) 删除一个包含 “H”: 8 键值的文档 12&gt; db.foo.remove(&#123;"H": 8&#125;, 1)WriteResult(&#123; "nRemoved" : 1 &#125;) 删除一个包含 “H”: 8 键值的文档 12&gt; db.foo.deleteOne(&#123;"H": 8&#125;)&#123; "acknowledged" : true, "deletedCount" : 1 &#125; 删除所有文档 12&gt; db.foo.deleteMany(&#123;&#125;)&#123; "acknowledged" : true, "deletedCount" : 3 &#125; 更新文档&gt; db.collection.updateOne()即使可能有多个文档通过过滤条件匹配到，但是也最多也只更新一个文档。 &gt; db.collection.updateMany()更新所有通过过滤条件匹配到的文档. &gt; db.collection.replaceOne()即使可能有多个文档通过过滤条件匹配到，但是也最多也只替换一个文档。 &gt; db.collection.update()即使可能有多个文档通过过滤条件匹配到，但是也最多也只更新或者替换一个文档。默认情况下, db.collection.update() 只更新 一个 文档。要更新多个文档，请使用 multi 选项。 文档替换1234567891011121314151617181920212223242526272829&gt; var joe = db.foo.findOne(&#123;"name" : "joe"&#125;)&gt; joe.relationships = &#123;"friends": joe.friends, "enemies": joe.enemies&#125;&#123; "friends" : 32, "enemies" : 2 &#125;&gt; joe&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "joe", "friends" : 32, "enemies" : 2, "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125;&#125;&gt; delete joe.friendstrue&gt; delete joe.enemiestrue&gt; db.foo.update(&#123;"name" : "joe"&#125;, joe)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name" : "joe"&#125;)&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "joe", "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125;&#125; 找到所需数据后赋值给变量，对变量进行修改后，将整个变量当成更新结果进行更新。 1234567891011121314151617&gt; var joe = db.foo.findOne(&#123;"name" : "joe"&#125;)&gt; joe.age = 2020&gt; joe.age++20&gt; db.foo.update(&#123;"name" : "joe"&#125;, joe)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name" : "joe"&#125;)&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "joe", "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125;, "age" : 21&#125; 用相同方法增加年龄数据。 使用 $set 修改器增加键值123456789101112131415161718192021&gt; db.foo.update(&#123;"name" : "joe"&#125;, &#123;"$set":&#123;"work": "teacher"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.updateOne(&#123;"name" : "joe"&#125;, &#123;"$set": &#123;"favorite book": ["Learning Python", "C Programing", "Ruby on Rails"]&#125;&#125;)&#123; "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 &#125;&gt; db.foo.findOne(&#123;"name" : "joe"&#125;)&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "joe", "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125;, "age" : 21, "work" : "teacher", "favorite book" : [ "Learning Python", "C Programing", "Ruby on Rails" ]&#125; 使用 $unset 修改器删除键值1234567891011121314151617&gt; db.foo.update(&#123;"name": "jack"&#125;, &#123;"$unset": &#123;"work": 1&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name": "jack"&#125;)&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "jack", "relationships" : &#123; "friends" : 32, "enemies" : 2, &#125;, "age" : 28, "favorite book" : [ "Learning C++", "C Programing", "Ruby on Rails" ]&#125; 使用 $inc 修改器增加和减少数值12345678910111213141516171819&gt; db.foo.update(&#123;"name": "jack"&#125;, &#123;"$inc": &#123;"age": 1&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.update(&#123;"name": "jack"&#125;, &#123;"$inc": &#123;"age": 2&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name": "jack"&#125;)&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "jack", "relationships" : &#123; "friends" : 32, "enemies" : 2, &#125;, "age" : 31, "favorite book" : [ "Learning C++", "C Programing", "Ruby on Rails" ]&#125; 使用 $push 往数组添加单个元素12&gt; db.foo.update(&#123;"name": "joe"&#125;, &#123;$push: &#123;"favorite book": "Effective Python"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;) 使用 $push 和 $each 往数组添加多个元素12&gt; db.foo.update(&#123;"name": "joe"&#125;, &#123;$push: &#123;"favorite book": &#123;$each: ["Effective C++", "Python Programing"]&#125;&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;) 使用 $addToSet 往数组添加不重复的元素123456789101112131415161718192021&gt; db.foo.update(&#123;"name": "joe"&#125;, &#123;$addToSet: &#123;"favorite book": "Effective Python"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 0 &#125;)&gt; db.foo.findOne(&#123;"name": "joe"&#125;)&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "Learning Python", "C Programing", "Ruby on Rails", "Effective C++", "Python Programing", "Effective Python" ]&#125; 使用 $pull 删除数组内所有指定元素1234567891011121314151617181920&gt; db.foo.update(&#123;"name": "joe"&#125;, &#123;$pull: &#123;"favorite book": "Effective Python"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name": "joe"&#125;)&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "Learning Python", "C Programing", "Ruby on Rails", "Effective C++", "Python Programing" ]&#125; 使用 $pop 删除数组内指定位置的元素（1 代表最后一个元素，-1 代表前面第一个元素）1234567891011121314151617181920&gt; db.foo.update(&#123;"name": "joe"&#125;, &#123;$pop: &#123;"favorite book": 1&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.update(&#123;"name": "joe"&#125;, &#123;$pop: &#123;"favorite book": -1&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name": "joe"&#125;)&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++" ]&#125; 基于位置的数组修改器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&gt; db.foo.update(&#123;"name": "joe"&#125;, &#123;$addToSet: &#123;"favorite book": &#123;"book name": "Effective Python", "language": "Python", "tag": "Fine"&#125;&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name": "joe"&#125;)&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++", &#123; "book name" : "Effective Python", "language" : "Python", "tag" : "Fine" &#125; ]&#125;&gt; db.foo.update(&#123;"name": "joe"&#125;, &#123;$set: &#123;"favorite book.3.tag": "Nice"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name": "joe"&#125;)&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++", &#123; "book name" : "Effective Python", "language" : "Python", "tag" : "Nice" &#125; ]&#125;&gt; db.foo.update(&#123;"favorite book.book name": "Effective Python"&#125;, &#123;$set: &#123;"favorite book.$.tag": "Good"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.foo.findOne(&#123;"name": "joe"&#125;)&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++", &#123; "book name" : "Effective Python", "language" : "Python", "tag" : "Good" &#125; ]&#125; upsert 更新指定 update 的第三个参数为 true 即可。当没有找到符合更新条件的文档，将会以该条件新建一个文档。 12345678910111213&gt; db.foo.update(&#123;"name": "sliver"&#125;, &#123;$set: &#123;"work": "student"&#125;&#125;, true)WriteResult(&#123; "nMatched" : 0, "nUpserted" : 1, "nModified" : 0, "_id" : ObjectId("5a8d1e3d2c0bd1e7a6eff789")&#125;)&gt; db.foo.findOne(&#123;"name": "sliver"&#125;)&#123; "_id" : ObjectId("5a8d1e3d2c0bd1e7a6eff789"), "name" : "sliver", "work" : "student"&#125; 更新多个文档指定 update 的第四个个参数为 true 即可或者使用 updateMany() 查找文档 找到集合 foo 中的所有文档 1234&gt; db.foo.find()&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "jack", "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125;, "age" : 31, "favorite book" : [ "Learning C++", "C Programing", "Ruby on Rails" ] &#125;&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++", &#123; "book name" : "Effective Python", "language" : "Python", "tag" : "Good" &#125; ] &#125;&#123; "_id" : ObjectId("5a8d1e3d2c0bd1e7a6eff789"), "name" : "sliver", "work" : "student" &#125; 特定条件查询 12&gt; db.foo.find(&#123;"name": "jack"&#125;)&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "jack", "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125;, "age" : 31, "favorite book" : [ "Learning C++", "C Programing", "Ruby on Rails" ] &#125; 指定需要返回的键值 1234&gt; db.foo.find(&#123;&#125;, &#123;"name": 1, "_id": 0, "relationships": 1&#125;)&#123; "name" : "jack", "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125; &#125;&#123; "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125; &#125;&#123; "name" : "sliver" &#125; 包含特定大小关系的查找比较关系操作符 操作符 解释 $lte 小于等于 $lt 小于 $gte 大于等于 $gt 大于 $eq 等于 $ne 不等于 $in 包含 $nin 不包含 查找年龄在 18 ~ 30 直接的用户 123&gt; db.foo.find(&#123;"age": &#123;$gte: 18, $lte:30&#125;&#125;) // greater than or equel to 18, lower than or equel to 30&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++", &#123; "book name" : "Effective Python", "language" : "Python", "tag" : "Good" &#125; ] &#125;&#123; "_id" : ObjectId("5a8d1e3d2c0bd1e7a6eff789"), "name" : "sliver", "work" : "student", "age" : 20, "relationships" : [ &#123; "friends" : 25, "enemies" : 1, "lovers" : 1 &#125; ] &#125; 查找年龄为 22 或者 职业为 student 的用户 123&gt; db.foo.find(&#123;$or: [&#123;"age": 22&#125;, &#123;"work": "student"&#125;]&#125;)&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++", &#123; "book name" : "Effective Python", "language" : "Python", "tag" : "Good" &#125; ] &#125;&#123; "_id" : ObjectId("5a8d1e3d2c0bd1e7a6eff789"), "name" : "sliver", "work" : "student", "age" : 20, "relationships" : [ &#123; "friends" : 25, "enemies" : 1, "lovers" : 1 &#125; ] &#125; 查找年龄在 18 ~ 30 之间 并且 职业为 student 的用户 12&gt; db.foo.find(&#123;"age": &#123;$gte: 18, $lte:30&#125;, "work": "student"&#125;)&#123; "_id" : ObjectId("5a8d1e3d2c0bd1e7a6eff789"), "name" : "sliver", "work" : "student", "age" : 20, "relationships" : [ &#123; "friends" : 25, "enemies" : 1, "lovers" : 1 &#125; ] &#125; 查找 favorite book 中有 Ruby on Rails 和 C Programing 的用户 123&gt; db.foo.find(&#123;"favorite book": &#123;$in: ["Ruby on Rails", "C Programing"]&#125;&#125;)&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "jack", "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125;, "age" : 31, "favorite book" : [ "Learning C++", "C Programing", "Ruby on Rails" ] &#125;&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++", &#123; "book name" : "Effective Python", "language" : "Python", "tag" : "Good" &#125; ] &#125; 查找 favorite book 中没有 Java 的用户 1234&gt; db.foo.find(&#123;"favorite book" : &#123;$nin: ["Java"]&#125;&#125;)&#123; "_id" : ObjectId("5a8cf74053f8f9f279979205"), "name" : "jack", "relationships" : &#123; "friends" : 32, "enemies" : 2 &#125;, "age" : 31, "favorite book" : [ "Learning C++", "C Programing", "Ruby on Rails" ] &#125;&#123; "_id" : ObjectId("5a8d02d053f8f9f279979206"), "name" : "joe", "relationships" : &#123; "friends" : 25, "enemies" : 5 &#125;, "age" : 22, "work" : "teacher", "favorite book" : [ "C Programing", "Ruby on Rails", "Effective C++", &#123; "book name" : "Effective Python", "language" : "Python", "tag" : "Good" &#125; ] &#125;&#123; "_id" : ObjectId("5a8d1e3d2c0bd1e7a6eff789"), "name" : "sliver", "work" : "student", "age" : 20, "relationships" : [ &#123; "friends" : 25, "enemies" : 1, "lovers" : 1 &#125; ] &#125; null 会匹配某个键的值为 null 的文档，而且还会匹配不包含这个键的文档，查询时需要加上 exists 1&gt; db.foo.find(&#123;"z": &#123;$in: [null], $exists: true&#125;&#125;) 查找数组创建 food 集合： 1234567891011&gt; db.food.insert(&#123;"_id": 1, "fruit": ["apple", "banana", "peach"]&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; db.food.insert(&#123;"_id": 2, "fruit": ["apple", "kumguat", "orange"]&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; db.food.insert(&#123;"_id": 3, "fruit": ["cherry", "banana", "apple"]&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; db.food.find()&#123; "_id" : 1, "fruit" : [ "apple", "banana", "peach" ] &#125;&#123; "_id" : 2, "fruit" : [ "apple", "kumguat", "orange" ] &#125;&#123; "_id" : 3, "fruit" : [ "cherry", "banana", "apple" ] &#125; 找到含有 apple 和 banana 数组的文档 123&gt; db.food.find(&#123;"fruit": &#123;$all: ["apple", "banana"]&#125;&#125;)&#123; "_id" : 1, "fruit" : [ "apple", "banana", "peach" ] &#125;&#123; "_id" : 3, "fruit" : [ "cherry", "banana", "apple" ] &#125; 查询数组特定位置的元素 12&gt; db.food.find(&#123;"fruit.2": "peach"&#125;)&#123; "_id" : 1, "fruit" : [ "apple", "banana", "peach" ] &#125; 插入一个元素： 12&gt; db.food.update(&#123;"_id": 1&#125;, &#123;$addToSet: &#123;"fruit": "mango"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;) 找到 fruit 数组大小为4的文档 12&gt; db.food.find(&#123;"fruit": &#123;$size: 4&#125;&#125;)&#123; "_id" : 1, "fruit" : [ "apple", "banana", "peach", "mango" ] &#125; 找到 fruit 数组大小为3的文档 123&gt; db.food.find(&#123;"fruit": &#123;$size: 3&#125;&#125;)&#123; "_id" : 2, "fruit" : [ "apple", "kumguat", "orange" ] &#125;&#123; "_id" : 3, "fruit" : [ "cherry", "banana", "apple" ] &#125; 返回 fruit 数组最后两个元素 12&gt; db.food.find(&#123;"_id": 1&#125;, &#123;"fruit": &#123;$slice: -2&#125;&#125;)&#123; "_id" : 1, "fruit" : [ "peach", "mango" ] &#125; 返回 fruit 数组前面两个元素 12&gt; db.food.find(&#123;"_id": 1&#125;, &#123;"fruit": &#123;$slice: 2&#125;&#125;)&#123; "_id" : 1, "fruit" : [ "apple", "banana" ] &#125; 返回 fruit 数组索引为2~3的元素 12&gt; db.food.find(&#123;"_id": 1&#125;, &#123;"fruit": &#123;$slice: [2, 2]&#125;&#125;)&#123; "_id" : 1, "fruit" : [ "peach", "mango" ] &#125; 返回 fruit 数组索引为1~2的元素 12&gt; db.food.find(&#123;"_id": 1&#125;, &#123;"fruit": &#123;$slice: [1, 2]&#125;&#125;)&#123; "_id" : 1, "fruit" : [ "banana", "peach" ] &#125; 返回所有文档里 fruit 数组的最后两个元素 1234&gt; db.food.find(&#123;&#125;, &#123;"fruit": &#123;$slice: -2&#125;&#125;)&#123; "_id" : 1, "fruit" : [ "peach", "mango" ] &#125;&#123; "_id" : 2, "fruit" : [ "kumguat", "orange" ] &#125;&#123; "_id" : 3, "fruit" : [ "banana", "apple" ] &#125; 创建 grades 集合： 1234567891011&gt; db.grades.insert(&#123;"_id": 1, "grade": [90, 80 ,70]&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; db.grades.insert(&#123;"_id": 2, "grade": [91, 92 ,89]&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; db.grades.insert(&#123;"_id": 3, "grade": [71, 72 ,79]&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; db.grades.find()&#123; "_id" : 1, "grade" : [ 90, 80, 70 ] &#125;&#123; "_id" : 2, "grade" : [ 91, 92, 89 ] &#125;&#123; "_id" : 3, "grade" : [ 71, 72, 79 ] &#125; 查找 grade 数组包含范围为 (80, 95) 数据的文档 123&gt; db.grades.find(&#123;"grade": &#123;$elemMatch: &#123;$gt: 80, $lt: 95&#125;&#125;&#125;)&#123; "_id" : 1, "grade" : [ 90, 80, 70 ] &#125;&#123; "_id" : 2, "grade" : [ 91, 92, 89 ] &#125; 查找 grade 数组包含范围为 (70, 75) 数据的文档 12&gt; db.grades.find(&#123;"grade": &#123;$elemMatch: &#123;$gt: 70, $lt: 75&#125;&#125;&#125;)&#123; "_id" : 3, "grade" : [ 71, 72, 79 ] &#125; 创建 blog 集合： 1&gt; db.blog.insert(&#123;"content": "article", "comments": [&#123;"author": "joe", "score": 3, "comment": "nice post"&#125;, &#123;"author": "mary", "score": 6, "comment": "terrible post"&#125;, &#123;"author": "joe", "score": 5, "comment": "ok..."&#125;]&#125;) 查找 comments 数组中作者为 author 或者分数大于等于3的文章 12&gt; db.blog.find(&#123;"comments": &#123;$elemMatch: &#123;"author": "joe", "score": &#123;$gte: 3&#125;&#125;&#125;&#125;)&#123; "_id" : ObjectId("5a9aaced52f59c4d6924b177"), "content" : "article", "comments" : [ &#123; "author" : "joe", "score" : 3, "comment" : "nice post" &#125;, &#123; "author" : "mary", "score" : 6, "comment" : "terrible post" &#125;, &#123; "author" : "joe", "score" : 5, "comment" : "ok..." &#125; ] &#125; 通过 $where 使用 JavaScript 函数查询文档 12&gt; db.food.find(&#123;$where: function()&#123;return this._id === 1&#125;&#125;)&#123; "_id" : 1, "fruit" : [ "apple", "banana", "peach", "mango" ] &#125; 游标创建 collection 集合： 1234&gt; for(var i = 0; i &lt; 100; i++) &#123;... db.collection.insert(&#123;"x": i&#125;)... &#125;WriteResult(&#123; "nInserted" : 1 &#125;) 创建并使用游标： 12345&gt; var cursor = db.collection.find();&gt; while (cursor.hasNext()) &#123;... obj = cursor.next();... &#125;&#123; "_id" : ObjectId("5a9ab0b652f59c4d6924b1db"), "x" : 99 &#125; 类似于迭代器： 12&gt; cursor.hasNext()false limit、skip 和 sort 按 _id 逆序 1234&gt; db.food.find().sort(&#123;"_id": -1&#125;)&#123; "_id" : 3, "fruit" : [ "cherry", "banana", "apple" ] &#125;&#123; "_id" : 2, "fruit" : [ "apple", "kumguat", "orange" ] &#125;&#123; "_id" : 1, "fruit" : [ "apple", "banana", "peach", "mango" ] &#125; 按 _id 正序 1234&gt; db.food.find().sort(&#123;"_id": 1&#125;)&#123; "_id" : 1, "fruit" : [ "apple", "banana", "peach", "mango" ] &#125;&#123; "_id" : 2, "fruit" : [ "apple", "kumguat", "orange" ] &#125;&#123; "_id" : 3, "fruit" : [ "cherry", "banana", "apple" ] &#125; 跳过前面的数据从80开始到最后 123456789101112131415161718192021&gt; db.collection.find().skip(80)&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b22c"), "x" : 80 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b22d"), "x" : 81 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b22e"), "x" : 82 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b22f"), "x" : 83 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b230"), "x" : 84 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b231"), "x" : 85 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b232"), "x" : 86 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b233"), "x" : 87 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b234"), "x" : 88 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b235"), "x" : 89 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b236"), "x" : 90 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b237"), "x" : 91 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b238"), "x" : 92 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b239"), "x" : 93 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b23a"), "x" : 94 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b23b"), "x" : 95 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b23c"), "x" : 96 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b23d"), "x" : 97 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b23e"), "x" : 98 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b23f"), "x" : 99 &#125; 跳过前面的数据从80开始，但是限制数量为10个 1234567891011&gt; db.collection.find().skip(80).limit(10)&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b22c"), "x" : 80 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b22d"), "x" : 81 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b22e"), "x" : 82 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b22f"), "x" : 83 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b230"), "x" : 84 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b231"), "x" : 85 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b232"), "x" : 86 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b233"), "x" : 87 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b234"), "x" : 88 &#125;&#123; "_id" : ObjectId("5a9ab37352f59c4d6924b235"), "x" : 89 &#125; 参考资料 MongoDB 中文手册 MongoDB 官方文档 MongoDB 权威指南]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTerm2常用快捷键]]></title>
    <url>%2F2018%2F03%2F02%2FiTerm2%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[你不能不知道的 iTerm2 技巧。 常用功能快捷键 功能 快捷键 新建标签 command + t 关闭标签 command + w 切换标签 command + 数字 / command + 左右方向键 切换全屏 command + enter 查找 command + f 垂直分屏 command + d 水平分屏 command + shift + d 切换屏幕 command + option + 左右方向键 / command + [ / command + ] 查看历史命令 command + ; 查看剪贴板历史 command + shift + h 清除当前行 ctrl + u 光标到行首 ctrl + a 光标到行尾 ctrl + e 光标前进后退 ctrl + f/b (相当于左右方向键) 上一条命令 ctrl + p 搜索命令历史 ctrl + r 删除当前光标的字符 ctrl + d 删除光标之前的字符 ctrl + h 删除光标之前的单词 ctrl + w 删除光标之后的字符 ctrl + k 交换光标处文本 ctrl + t 清屏 command + r / ctrl + l 常用插件简单配置一些插件，往往能显著提高工作效率。只要在 ~/.zshrc 文件的 plugin 下面添加上想要的插件名称就可以了，并且 oh-my-zsh 自带了很多插件，可以通过 ls ~/.oh-my-zsh/plugins 来查看。 1plugins=(git-extras git mvn svn osx brew brew-cask npm colored-man colorize copydir history sublime command-not-found zsh-syntax-highlighting Z) git：当你处于一个 git 受控的目录下时，shell 会明确显示 git 和 branch，另外对 git 很多命令进行了简化，例如 gco=’git checkout’、gd=’git diff’、gst=’git status’、g=’git’ 等等，熟练使用可以大大减少 git 的命令长度，命令内容可以参考 ~/.oh-my-zsh/plugins/git/git.plugin.zsh。 textmate：mr 可以创建 ruby 的框架项目，tm finename 可以用 textmate 打开指定文件。osx：tab 增强，quick-look filename 可以直接预览文件，man-preview grep 可以生成 grep 手册的 pdf 版本等。 git-extras: Git extras 工具与 zsh 的继承，很方便，在 git 仓库目录下试试 git summary 即可看到整个仓库的汇总信息。 sublime : 此插件能够在终端下使用命令 stt 在 SublimeText 中打开当前文件夹，使用 subl 或者 st 来编辑某个特定文件，比如 st 1.txt，当然前提你得安装了 SublimeText。 zsh-syntax-highlighting: 让终端的每一条命令智能显示颜色，就像在 IDE 里面写代码一样，强烈推荐，安装只需要输入 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 命令再添加 zsh-syntax-highlighting 插件即可。 z : Z is awesome ，让你在不同的目录中快速跳转，比如想访问 ~/work/code/project/testApp，只要是之前访问过，直接输入 z testApp 按 tab 键直接显示完整目录，按 enter 键直接进入当前目录，即使只输入了 z testa 也能完成同样的工作，大大提升效率。 ag: 终端里面快速搜索当前目录下所有文件中所匹配的关键字的命令，类似与 awk，但是速度极快，速度极快，速度极快，使用 brew install，其实就是组件 the_silver_searcher ，详细参考地址 GitHub 。 tree : mac 下的 tree 命令，方便排查问题，直接 brew install tree 即可。 参考 http://blog.csdn.net/ws1352864983/article/details/51512904 https://www.jianshu.com/p/5ec4ba334102]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>iTerm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo自定义Markdown渲染]]></title>
    <url>%2F2018%2F02%2F27%2F%E8%87%AA%E5%AE%9A%E4%B9%89markdown%2F</url>
    <content type="text"><![CDATA[看惯俗粉，不如魔改。 首先需要修改 Hexo 默认的 Markdown 插件，是在 node_modules/hexo-renderer-marked/lib/ 目录下的 renderer.js 文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788'use strict';var marked = require('marked');var assign = require('object-assign');var stripIndent = require('strip-indent');var util = require('hexo-util');var highlight = util.highlight;var stripHTML = util.stripHTML;var MarkedRenderer = marked.Renderer;function Renderer() &#123; MarkedRenderer.apply(this, arguments); this._headingId = &#123;&#125;;&#125;require('util').inherits(Renderer, MarkedRenderer);// Add id attribute to headingsRenderer.prototype.heading = function(text, level) &#123; var id = anchorId(stripHTML(text)); var headingId = this._headingId; // Add a number after id if repeated if (headingId[id]) &#123; id += '-' + headingId[id]++; &#125; else &#123; headingId[id] = 1; &#125; // add headerlink return '&lt;h' + level + ' id="' + id + '"&gt;&lt;a href="#' + id + '" class="headerlink" title="' + stripHTML(text) + '"&gt;&lt;/a&gt;' + text + '&lt;/h' + level + '&gt;';&#125;;function anchorId(str) &#123; // Add support for Chinese return escape(str .replace(/\s+/g, '_') .replace(/\./g, '-') .replace(/-&#123;2,&#125;/g, '-')).replace(/%/g, '_').replace(/^[\-_]+|[\-_]+$/g, '');&#125;marked.setOptions(&#123; langPrefix: '', highlight: function(code, lang) &#123; return highlight(stripIndent(code), &#123; lang: lang, gutter: false, wrap: false &#125;); &#125;&#125;);module.exports = function(data, options) &#123; // return marked(data.text, assign(&#123; // renderer: new Renderer() // &#125;, this.config.marked, options)); var curRender = new Renderer(), markedRenderer = this.markedRenderer; // init function if (markedRenderer &amp;&amp; typeof(markedRenderer.init) == 'function') &#123; markedRenderer.init.call(this, data, options); &#125; // override marked.Render if (markedRenderer) &#123; curRender = assign(curRender, markedRenderer); &#125; // get html content var html = marked(data.text, assign(&#123; renderer: curRender &#125;, this.config.marked, options)); // complete function if (markedRenderer &amp;&amp; typeof(markedRenderer.complete) == 'function') &#123; var tmpHtml = markedRenderer.complete.call(this, html); if (!tmpHtml) &#123; html = tmpHtml; &#125; &#125; return html;&#125;; 修改 module.exports = function(data, options) 后的部分即可，这里附上所有代码，如上。 接下来在所用主题目录 yourtheme/scripts/，创建 marked-renderer.js 并写入: 12345678910111213141516171819202122hexo.markedRenderer = &#123; init: function() &#123; // console.log("hexo.markedRenderer init!"); // Called before rendering &#125;, complete: function(html) &#123; // console.log("hexo.markedRenderer complete!"); // Called after rendered // Deal with html here ... return html; &#125;, image: function(href, title, alt) &#123; // Default method can be accessed via: // this._super.heading(text, level) var orimg = '&lt;img data-original="' + href; if (title) orimg += '" title="' + title; if (alt) orimg += '" alt="' + alt; return orimg + '"&gt;'; &#125;&#125;; 大功告成。感谢 Github 大佬们：https://github.com/helinjiang/hexo-renderer-marked-enhanced。]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python小课堂之命名元组、频度统计和排序技巧]]></title>
    <url>%2F2018%2F02%2F25%2FPython%E5%B0%8F%E8%AF%BE%E5%A0%821%2F</url>
    <content type="text"><![CDATA[写给女朋友的小课堂 One🌟 如何为元组中的每个元素命名，提高程序可读性？我们知道，C 语言中存在结构体，如一个链表节点： 12345typedef struct LNode&#123; ElemType data; struct LNode *next;&#125; LNode; 结构体的引入，使程序的可读性有显著的提高，我们可以使用如 L.data 访问元素。在 Python 中，我们可以使用命名元组来提高程序可读性。 现在，我们来创建一个 Student 命名元组： in[0]: 123456789from collections import namedtuple# 第一个变量是元组名称，第二个参数是一个列表，包含了元组里想要包含的元素 Student = namedtuple('Student', ['name', 'age', 'sex', 'grade'])student1 = Student('Sliver', 20, 'male', 99) # 默认赋值student2 = Student(name='Arial', grade=100, age=18, sex='female') # 通过关键字赋值print(student1)print(student2) out[0]: 12Student(name='Sliver', age=20, sex='male', grade=99)Student(name='Arial', age=18, sex='female', grade=100) 现在我们可以直接通过属性来访问数据，其内存占用不高，比普通元组也只是大了一点，在迭代方面与元组等效。 in[1]: 1234for s in student1: print(s)print()print(student1.name, student1.age, student1.sex, student1.grade); print() out[1]: 123456Sliver20male99Sliver 20 male 99 如何统计序列中元素出现的频度？我们先创建一个在[0, 20]之间数量为30个的随机列表，这样肯定会有重复的元素： in[0]: 1234import randoml1 = [random.randint(0, 20) for i in range(30)] print(l1) out[0]: 1[2, 12, 7, 11, 14, 7, 7, 6, 16, 18, 19, 5, 9, 5, 9, 9, 10, 16, 20, 9, 2, 7, 12, 16, 5, 16, 1, 14, 14, 19] 我们想知道每个数据出现的次数，比如2出现了5次，3出现了2次等，这样其实很符合字典的构造，因为字典其实就是一个 key-value 形式，如 {2: 5, 3:2} 可以表示2出现了5次，3出现了2次。现在我们来根据这个思路来统计出现次数，也就是频度： in[1]: 12data = dict.fromkeys(l1, 0) print(data) dict.fromkeys() 是字典对象的一个方法，第一个参数是要取键值的序列，第二个参数是默认让每个键对应的值，这里我们选0进行赋值，因为字典不允许有重复的键，这样我们也就把序列中的唯一元素都取了出来。 PS: 字典的键的定义是不是和集合很像？所以他们都是用{}表示~ out[1]: 1&#123;2: 0, 12: 0, 7: 0, 11: 0, 14: 0, 6: 0, 16: 0, 18: 0, 19: 0, 5: 0, 9: 0, 10: 0, 20: 0, 1: 0&#125; 这个时候我们遍历原来的序列，为之前创建的data字典加1。为什么呢？因为遍历原来的序列，如果碰到相同的就加1，也就相当于计算了这个元素在原来序列中的个数了。 in[2]: 123for x in l1: data[x] += 1 print(data) out[2]: 1&#123;2: 2, 12: 2, 7: 4, 11: 1, 14: 3, 6: 1, 16: 4, 18: 1, 19: 2, 5: 3, 9: 4, 10: 1, 20: 1, 1: 1&#125; 但是如果要找频度最高的元素，就又要重新遍历得到的字典了，数据很大的时候，这样的效率并不高： in[3]: 12for kv in sorted(data.items(), key=lambda x: x[1], reverse=True)[0:3]: print('频度排名前三的键值对：',kv) out[3]: 123频度排名前三的键值对： (7, 4)频度排名前三的键值对： (16, 4)频度排名前三的键值对： (9, 4) 这里介绍一下 sort() 函数： 它的第一个参数是一个可迭代的序列，reverse=True 代表的是从高到低排序，默认是从低到高排。key 参数接受一个函数，有点像 map 和 filter，都需要给它一个函数，key 是给 sorted 一个排序的参考点，也就是告诉sorted，我们要按照哪个值排序。 data.items() 返回的是一个类似元组的结果，也就是我们的键值是这样返回来的：(k, v)我们要对它排序，是按照 k 的大小排呢？还是按照 v 的大小排呢？ 如果让 kv = (k, v), 那么 kv[0] 就代表了 k, kv[1] 代表了 v。 key=lambda x: x[1] 就是代表我们按照 kv[1] 也就是值的大小进行排序。 相比前面这么多的代码量，倒是有更加简洁的代码，运行效率不高，却也不失为 Pythonic。 in[4]: 123temp = &#123;x for x in l1&#125;d1 = &#123;k: l1.count(k) for k in temp&#125; # 可以简洁地得出每个数据的频度print(d1); print() out[4]: 1&#123;1: 1, 2: 2, 5: 3, 6: 1, 7: 4, 9: 4, 10: 1, 11: 1, 12: 2, 14: 3, 16: 4, 18: 1, 19: 2, 20: 1&#125; 不要害怕，还有另一个方法： in[5]: 123456from collections import Counter# Python 内置模块 collections 包含了统计频度的 Counter 对象c = Counter(l1)print(c); print()print(type(c)) # 它是一个Counter对象，但更加直观 out[5]: 123Counter(&#123;7: 4, 16: 4, 9: 4, 14: 3, 5: 3, 2: 2, 12: 2, 19: 2, 11: 1, 6: 1, 18: 1, 10: 1, 20: 1, 1: 1&#125;)&lt;class 'collections.Counter'&gt; Counter 对象的 most_common() 方法可以返回频度排名由高到低的列表，列表里面包含了键值对元组。现在我们来得到频度排名前3的键值对： in[6]: 12print(c.most_common(3)); print()# 得到频度排名前5的键值对print(c.most_common(5)) out[6]: 123[(7, 4), (16, 4), (9, 4)][(7, 4), (16, 4), (9, 4), (14, 3), (5, 3)] 我们可以试着随便统计一下一堆字符串中单词的频度了： in[7]: 1234567891011121314poem = '''Down by the salley gardens my love and I did meet; She passed the salley gardens with little snow-white feet.She bid me take love easy, as the leaves grow on the tree;But I being young and foolish, with her would not agree.In a field by the river my love and I did stand,And on my leaning shoulder she laid her snow-white hand.She bid me take life easy, as the grass grows on the weirs;But I was young and foolish, and now i m full of tears.'''import repoem_list = re.split('\s+', poem) # re.split() 方法按照空字符去拆分字符串print(Counter(poem_list)) out[7]: 1Counter(&#123;'the': 7, 'and': 5, 'I': 4, 'my': 3, 'love': 3, 'She': 3, 'on': 3, '': 2, 'by': 2, 'salley': 2, 'gardens': 2, 'did': 2, 'with': 2, 'snow-white': 2, 'bid': 2, 'me': 2, 'take': 2, 'easy,': 2, 'as': 2, 'But': 2, 'young': 2, 'foolish,': 2, 'her': 2, 'Down': 1,'meet;': 1, 'passed': 1, 'little': 1, 'feet.': 1, 'leaves': 1, 'grow': 1, 'tree;': 1, 'being': 1, 'would': 1, 'not': 1, 'agree.': 1,'In': 1, 'a': 1, 'field': 1, 'river': 1, 'stand,': 1, 'And': 1, 'leaning': 1, 'shoulder': 1, 'she': 1, 'laid': 1, 'hand.': 1, 'life': 1, 'grass': 1, 'grows': 1, 'weirs;': 1, 'was': 1, 'now': 1, 'i': 1, 'm': 1, 'full': 1, 'of': 1, 'tears.': 1&#125;) 如何根据字典中值的大小，对数据项进行排序？我们可以用sorted()函数先对一个列表进行排序: in[0]: 123l1 = [random.randint(0,40) for i in range(20)]print(sorted(l1)) # 从小到大输出print(sorted(l1, reverse=True)) # 从大到小输出 out[0]: 12[4, 5, 6, 8, 10, 10, 13, 17, 20, 22, 22, 22, 26, 28, 30, 31, 33, 35, 35, 35][35, 35, 35, 33, 31, 30, 28, 26, 22, 22, 22, 20, 17, 13, 10, 10, 8, 6, 5, 4] 现在我们创建一个学生成绩字典： in[1]: 12d1 = &#123;name: random.randint(40,100) for name in 'ABCDEFGHIJ'&#125; # 字典生成式print(d1) out[1]: 1&#123;'A': 87, 'B': 67, 'C': 68, 'D': 76, 'E': 91, 'F': 53, 'G': 54, 'H': 61, 'I': 48, 'J': 51&#125; 试试sorted()进行排序： in[2]: 1print(sorted(d1)) out[2]: 1['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'] 默认将键进行了排序，那该怎么让它根据值进行排序呢？ in[3]: 1print(sorted(d1.items(), key=lambda items:items[1])) out[3]: 1[('I', 48), ('J', 51), ('F', 53), ('G', 54), ('H', 61), ('B', 67), ('C', 68), ('D', 76), ('A', 87), ('E', 91)] 给 reverse 参数赋值，进行从大到小排序: in[4]: 1print(sorted(d1.items(), key=lambda items:items[1] ,reverse=True)) out[4]: 1[('E', 91), ('A', 87), ('D', 76), ('C', 68), ('B', 67), ('H', 61), ('G', 54), ('F', 53), ('J', 51), ('I', 48)] 试试zip，思考为什么这样就可以排序了？ in[5]: 1print(sorted(zip(d1.values(), d1.keys()), reverse=True)) out[5]: 1[(91, 'E'), (87, 'A'), (76, 'D'), (68, 'C'), (67, 'B'), (61, 'H'), (54, 'G'), (53, 'F'), (51, 'J'), (48, 'I')]]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Battle Ship]]></title>
    <url>%2F2018%2F02%2F25%2FBattleShip%2F</url>
    <content type="text"><![CDATA[少年，你，想不想成为一个 Captain 呢？ 标题误导向 hhh。 前段时间学习了 JavaScript 这门语言，相比于 Python，它也是有很多优点的。结合之前看的 Head First HTML &amp; CSS 这本书，我写了一个普通的小游戏，仅为娱乐。 游戏规则： 有一个 7 * 7 的航海区域，敌方有三艘潜艇潜伏其中，每艘潜艇占据三格长度，它可能是竖着潜伏，也有可能是横着潜伏。我方有很多炮弹鱼雷，但希望在尽量少的发射次数下，击沉敌方三艘潜艇。 击沉条件： 因为潜艇占据三格长度，所以需要将炮弹击打在潜艇的三个部位才能将其击沉，重复击打是无效的。 温馨提醒： 请多多注意左上角的提示。 游戏有彩蛋，懂前端的一定能到找到。 ⚡️Battle Start⚡️]]></content>
      <categories>
        <category>娱乐</category>
      </categories>
      <tags>
        <tag>Game</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0021 Merge Two Sorted Lists]]></title>
    <url>%2F2018%2F02%2F25%2F0021-Merge-Two-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[21. Merge Two Sorted Lists Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: 12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Analysis: 看到这道题有似曾相识的感觉，其实就是当初上数据结构，老师讲了半天的链表合并题，印象很深刻，所以还原了一下他说的算法，代码虽然很丑很长，但是时间效率还是挺高的 O(m+n)。当然，这道题用递归来解决会更加的简便，因为给我们的两个链表是已经排序好的，如果当前l1的节点的值比l2的节点的值大，就将两个节点交换，要注意的是，这样的交换会将节点指向的后续节点也一起交换了，然后递归判断后续节点直到遍历结束，返回结果。 Answer: 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ output = ListNode(0) temp = output while l1 and l2: if l1.val &gt; l2.val: temp.next = ListNode(0) temp.next.val, l2 = l2.val, l2.next temp = temp.next elif l1.val &lt; l2.val: temp.next = ListNode(0) temp.next.val, l1 = l1.val, l1.next temp = temp.next else: temp.next = ListNode(0) temp.next.next = ListNode(0) temp.next.val, temp.next.next.val= l1.val, l1.val temp, l1, l2 = temp.next.next, l1.next, l2.next if l1: temp.next = ListNode(0) temp.next.next = ListNode(0) temp.next.val = l1.val temp.next.next = l1.next elif l2: temp.next = ListNode(0) temp.next.next = ListNode(0) temp.next.val = l2.val temp.next.next = l2.next return output.next Answer 2: 123456789101112131415161718# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if l1 and l2: if l1.val &gt; l2.val: l1, l2 = l2, l1 l1.next = self.mergeTwoLists(l1.next, l2) return l1 or l2]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0020 Valid Parentheses]]></title>
    <url>%2F2018%2F02%2F25%2F0020-Valid-Parentheses%2F</url>
    <content type="text"><![CDATA[20. Valid Parentheses Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. The brackets must close in the correct order, &quot;()&quot; and &quot;()[]{}&quot; are all valid but &quot;(]&quot; and &quot;([)]&quot; are not. Analysis: 在这里，我们可以把列表当成栈来使用，然后遍历字符串且不断 push 数据到栈中，在插入数据后要判断当前栈顶两个元素能否构成合法的括号表达式，如果可以，就把这两个元素都 pop 出栈，当循环结束后，如果整个字符串是合法的，栈必为空，否则是非法的。Answer 1 我是将数据插入列表后再判断是否合法，合法会 pop 两次数据，有点浪费时间和空间，所以 Answer 2 改成插入前就判断数据是否合法，合法就不插入数据，直接 pop 一次数据。当然也看到高人的答案，具体请看 Answer 3。 Answer 1: 1234567891011121314class Solution: def isValid(self, s): """ :type s: str :rtype: bool """ stack = [] d = ['()', '&#123;&#125;', '[]'] for char in s: stack.append(char) if len(stack) &gt;= 2 and (stack[-2] + stack[-1]) in d: stack.pop() stack.pop() return not stack Answer 2: 12345678910111213141516class Solution: def isValid(self, s): """ :type s: str :rtype: bool """ if len(s) % 2 != 0: return False d = &#123;')':'(', '&#125;':'&#123;', ']':'['&#125; stack = [] for char in s: if stack and (char in d and stack[-1] == d[char]): stack.pop() else: stack.append(char) return not stack Answer 3: 123456789class Solution: def isValid(self, s): """ :type s: str :rtype: bool """ while "()" in s or "&#123;&#125;" in s or "[]" in s: s = s.replace("()","").replace("&#123;&#125;","").replace("[]","") return not s]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0019 Remove Nth Node From End of List]]></title>
    <url>%2F2018%2F02%2F25%2F0019-Remove-Nth-Node-From-End-of-List%2F</url>
    <content type="text"><![CDATA[19. Remove Nth Node From End of List Given a linked list, remove the nth node from the end of list and return its head. For example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid.Try to do this in one pass. Analysis: 思路很简单，直接遍历整个链表得到长度 length，令 flag = length - n，这就是我们需要到达删除的位置的循环次数，如果为0，说明要删除的是头节点，直接返回 head.next即可，不为0时，要循环链表到低要删除的位置的前一个位置，改变指针指向节点即可。 Answer: 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ p, q, length = head, head, 0 while p: p = p.next length += 1 flag = length - n if flag == 0: return head.next while flag &gt; 1 : q = q.next flag -= 1 q.next = q.next.next return head]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0018 4Sum]]></title>
    <url>%2F2018%2F02%2F25%2F0018-4Sum%2F</url>
    <content type="text"><![CDATA[18. 4Sum Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. 12345678For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] Analysis: 本题思路与15题 3Sum 相同，因为多了一个数求和，所以需要多枚举一个数，也就多了一个循环，其余解法同15题，排序后只需要不断移动首尾两个指针，碰到重复的数跳过循环即可。 Answer: 123456789101112131415161718192021222324252627282930class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ nums.sort() output, length = [], len(nums) for i in range(0, length): if i and nums[i] == nums[i - 1]: continue for j in range(i + 1, length): if j != i + 1 and nums[j] == nums[j - 1]: continue sum = target - nums[i] - nums[j] start, end = j + 1, length - 1 while start &lt; end: if nums[start] + nums[end] &gt; sum: end -= 1 elif nums[start] + nums[end] &lt; sum: start += 1 else: output.append([nums[i], nums[j], nums[start], nums[end]]) start, end = start + 1, end - 1 while start &lt; end and nums[start] == nums[start - 1]: start += 1 while start &lt; end and nums[end] == nums[end + 1]: end -= 1 return output]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0017 Letter Combinations of a Phone Number]]></title>
    <url>%2F2018%2F02%2F25%2F0017-Letter-Combinations-of-a-Phone-Number%2F</url>
    <content type="text"><![CDATA[17. Letter Combinations of a Phone Number Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. 12Input:Digit string &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. Analysis: 考察的就是映射和排列组合，通过三层循环再不断更新组合列表即可。需要注意的有效数字只有 2~9，构造这个范围内的数字映射即可。 Answer: 12345678910111213141516class Solution: def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ map = &#123;'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'&#125; combinations = [''] if digits else [] for digit in digits: new_combinations = [] for letter in map[digit]: for combination in combinations: new_combinations.append(combination + letter) combinations = new_combinations return combinations]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0016 3Sum Closest]]></title>
    <url>%2F2018%2F02%2F25%2F0016-3Sum-Closest%2F</url>
    <content type="text"><![CDATA[16. 3Sum Closest Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. 123For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Analysis: 本题类似于15题，所以大部分代码和思路与15题相似，但是因为这次的 target 不是准确值，所以 while 循环内要比较三个数的和与 target 的大小关系，根据大小关系移动 start 和 end 指针，并在循环内根据 abs(sums - target) &lt; abs(output - target) 更新最接近的 target 的和，直到循环结束。 Answer: class Solution: def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ nums.sort() length, output= len(nums), None for i in range(length): if i &gt; 0 and nums[i] == nums[i - 1]: continue start, end = i + 1, length - 1 while start &lt; end: sums = nums[i] + nums[start] + nums[end] if sums &lt;= target: start += 1 else: end -= 1 if output is None or abs(sums - target) &lt; abs(output - target): output = sums return output]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0015 3Sum]]></title>
    <url>%2F2018%2F02%2F25%2F0015-3Sum%2F</url>
    <content type="text"><![CDATA[15. 3Sum Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 1234567For example, given array S = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] Analysis: 本道题一开始的思路是将在列表中取出3个数形成一个组合的结果全部列出来，再得到元素和为0的组合，如 Answer 1，不出所料超时了。换种思路，a + b + c = 0，其实也就是 0 - a = b + c，如果先将这个整数列表升序排序，在 for 循环中，令 target = 0 - nums[i]，我们设两个指针 start， end，根据两个指针对应的值的结果来调整指针的位置，也就可以解决问题了。需要注意的是，列表中相邻的两个元素如果相等，要选择跳过，这样会更加省时间。 Answer 1: 123456789101112# Time Limit Exceededclass Solution: def threeSum(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; from itertools import combinations nums.sort() temp = list(set([x for x in combinations(nums, 3) if sum(x) == 0])) output = [list(x) for x in temp] return(output) Answer 2: 1234567891011121314151617181920212223242526class Solution: def threeSum(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; nums.sort() length, output= len(nums), [] for i in range(length): if i &gt; 0 and nums[i] == nums[i - 1]: continue target = 0 - nums[i] start, end = i + 1, length - 1 while start &lt; end: if nums[start] + nums[end] &gt; target: end -= 1 elif nums[start] + nums[end] &lt; target: start += 1 else: output.append([nums[i], nums[start], nums[end]]) start, end = start + 1, end - 1 while start &lt; end and nums[end] == nums[end + 1]: end -= 1 while start &lt; end and nums[start] == nums[start - 1]: start += 1 return output]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0014 Longest Common Prefix]]></title>
    <url>%2F2018%2F02%2F25%2F0014-Longest-Common-Prefix%2F</url>
    <content type="text"><![CDATA[14. Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. Description: 题目给的描述有点不清晰的感觉，这里给出讨论区好心人的例子和描述。总体来说，是求出一组字符串中每个字符串的前缀公共子串，也就是求公共键问题。 It seems that it is not to check between pair of strings but on all the strings in the array. For example: {“a”,“a”,“b”} should give “” as there is nothing common in all the 3 strings. {“a”, “a”} should give “a” as a is longest common prefix in all the strings. {“abca”, “abc”} as abc {“ac”, “ac”, “a”, “a”} as a. Logic goes something like this: Pick a character at i=0th location and compare it with the character at that location in every string. If anyone doesn’t have that just return “” Else append that character in to the result. Increment i and do steps 1-3 till the length of that string. return result. Analysis: 将 strs 序列解包后再用 zip，我们可以将各个字符串里面的字符一一对应，每个字符串的第一个字符将会构成一个元组，每个字符串的第二个字符也会构成一个元组…因此我们可以根据集合的性质，将每个位置的元组转化为集合，如果集合的长度为1，说明这个位置的字符都是相同的，即可说明这是一个公共字符，不断循环直到遍历完数组或者找到集合长度大于1也就是不存在相同字符的位置，返回结果。 Answer 1: 12345678910111213class Solution: def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ if not strs: return "" for i, group in enumerate(zip(*strs)): if len(set(group)) &gt; 1: return strs[0][:i] else: return min(strs) 在本题中，公共键其实是包含在最短的字符串中的，我们只需要找到最短的字符串，并让其他字符串的字符与其比较即可。 Answer 2: 1234567891011121314class Solution: def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ if not strs: return "" shortstr = min(strs, key=len) for i, char in enumerate(shortstr): for otherstr in strs: if otherstr[i] != char: return shortstr[:i] return shortstr]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0013 Roman to Integer]]></title>
    <url>%2F2018%2F02%2F25%2F0013-Roman-to-Integer%2F</url>
    <content type="text"><![CDATA[13. Roman to Integer Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Analysis: 罗马数字的符号一共只有7个： I - 1 V - 5 X - 10 L - 50 C - 100 D - 500 M - 1000 运算规则（右加左减）：在一个较大的罗马数字的右边记上一个较小的罗马数字，表示大数字加小数字。在一个较大的数字的左边记上1个较小的罗马数字，表示大数字减小数字。并且，1个罗马数字重复几次，就表示这个数的几倍。 但是左减不能跨越一个位数。比如，99 不可以用 IC 表示，而是用 XCIX 表示。此外，左减数字不能超过1位，比如8写成 VIII，而非 IIX。并且左键减数字有限制，只能是 I、X、C。同理，右加数字不能超过3位，比如14写成 XIV，而非 XIIII。 罗马数字规则罗马数字1-100对照表 综上所述，给定一个罗马数字，循环时，如果 s[i] &lt;= s[i - 1]，可直接将 s[i] 加到 output 中，如果 s[i] &gt; s[i - 1]，就需要加上 s[i] 再减去两个 s[i - 1]，因为在上一次循环，已经加上了 s[i - 1]。 Answer: 1234567891011121314class Solution: def romanToInt(self, s): """ :type s: str :rtype: int """ d = &#123;'I': 1,'V': 5,'X': 10,'L': 50,'C': 100,'D': 500,'M': 1000&#125; output = 0 for i in range(len(s)): if i &gt; 0 and d[s[i]] &gt; d[s[i - 1]]: output += d[s[i]] - 2 * d[s[i - 1]] else: output += d[s[i]] return output]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0012 Integer to Roman]]></title>
    <url>%2F2018%2F02%2F25%2F0012-Integer-to-Roman%2F</url>
    <content type="text"><![CDATA[12. Integer to Roman Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Analysis: 罗马数字的符号一共只有7个： I - 1 V - 5 X - 10 L - 50 C - 100 D - 500 M - 1000 运算规则（右加左减）：在一个较大的罗马数字的右边记上一个较小的罗马数字，表示大数字加小数字。在一个较大的数字的左边记上1个较小的罗马数字，表示大数字减小数字。并且，1个罗马数字重复几次，就表示这个数的几倍。 但是左减不能跨越一个位数。比如，99 不可以用 IC 表示，而是用 XCIX 表示。此外，左减数字不能超过1位，比如8写成 VIII，而非 IIX。并且左键减数字有限制，只能是 I、X、C。同理，右加数字不能超过3位，比如14写成 XIV，而非 XIIII。 罗马数字规则罗马数字1-100对照表 想实现算法时，发现只用上面提到的七个字符来当基准数是有点麻烦的，应该要再增加几个基准数。根据罗马数字运算规则，可以知道减法出现的情况是 IV - 4; IX - 9; XL - 40; XC - 90; CD - 400; CM - 900，我们将这些数字添加到基准数中，实现算法时，就只需考虑加法的情况了。 考虑到第一个答案要两层 while 循环，想能提高效率，所以第二个答案改成一个 for 循环。 Answer 1: 12345678910111213141516class Solution(object): def intToRoman(self, num): """ :type num: int :rtype: str """ n = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] d = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'] output, i, count = '', 0, 0 while num &gt; 0: count, num = divmod(num, n[i]) # count = num // n[i]; num = num % n[i] while count &gt; 0: output += d[i] count -= 1 i += 1 return output Answer 2: 12345678910111213class Solution(object): def intToRoman(self, num): """ :type num: int :rtype: str """ nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] dicts = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'] output = "" for n, d in zip(nums, dicts): output += d * (num // n) num %= n return output]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0011 Container With Most Water]]></title>
    <url>%2F2018%2F02%2F25%2F0011-Container-With-Most-Water%2F</url>
    <content type="text"><![CDATA[11. Container With Most Water Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. Analysis: 图片来源：NapoleonY 本题场景可以模拟成两块木板加上任意调节的板底构成装水的容器，容器高度就像短板原理，与最短的板的高度有关，板底长度与两板之间的距离有关，为了得到装最多水的容器，应使两板的高度尽量大，两板的距离尽量长。所以我们可以设置首尾两个指针，不断向中间扫描，每次都更新最大值，等到结束就可以找到最大值了。 Answer: 1234567891011121314151617class Solution: def maxArea(self, height): """ :type height: List[int] :rtype: int """ start, end = 0, len(height) - 1 output = 0 while start &lt; end: if height[start] &lt; height[end]: area = height[start] * (end - start) start += 1 else: area = height[end] * (end - start) end -= 1 output = max(output, area) return output]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0010 Regular Expression Matching]]></title>
    <url>%2F2018%2F02%2F25%2F0010-Regular-Expression-Matching%2F</url>
    <content type="text"><![CDATA[10. Regular Expression Matching Implement regular expression matching with support for ‘.’ and ‘*’. 12345678910111213141516&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;aa&quot;, &quot;.*&quot;) → trueisMatch(&quot;ab&quot;, &quot;.*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true Analysis: 贯彻不重复造轮子的思想，这道题直接运用 re 模块再加上一些 if 语句是可以直接秒杀的。 Answer: 12345678910111213class Solution: def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ import re result = re.match(p, s) if not result: return False else: return True if result.group() == s else False]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0009 Palindrome Number]]></title>
    <url>%2F2018%2F02%2F25%2F0009-Palindrome-Number%2F</url>
    <content type="text"><![CDATA[9. Palindrome Number Determine whether an integer is a palindrome. Do this without extra space. Some hints: Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. Analysis: 秒杀题，其实将数字转化为字符串再判断回文更快，不过题目要求不能额外申请空间，所以可以先计算翻转后的整数，如果翻转后的整数等于原来的数，就可以判断是回文数。AC 后看了一下 LeetCode 的推荐技巧是只将后面的一半数字回文，然后让前面一半与后面一半进行比较。这个方法很巧妙，于是改写得到新的代码。留意的是负数和末尾有多个0的数肯定不是回文数，所以可以直接排除。 Answer 1: 1234567891011class Solution: def isPalindrome(self, x): """ :type x: int :rtype: bool """ num, compare, x = x, 0, abs(x) while x: compare = compare * 10 + x % 10 x //= 10 return compare == num Answer 2: 12345678910111213class Solution: def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0 or (x != 0 and x % 10 == 0): return False half = 0 while x &gt; half: half = half * 10 + x % 10 x //= 10 return x == half or half // 10 == x]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0008 String to Integer (atoi)]]></title>
    <url>%2F2018%2F02%2F25%2F0008-String-to-Integer%2F</url>
    <content type="text"><![CDATA[8. String to Integer (atoi) Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Requirements for atoi: The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. Analysis: 本题虽然简单，但还是有很多坑的…atoi 函数是 C 中标准库的一个函数，题目要求需要防止数据溢出，且经过测试或者查询 API 可知道，无效的转换都要返回 0。 12345678910int atoi（con​​st char * str）;将字符串转换为整数解析 C 字符串 str，将其内容解释为一个整数，该整数作为类型的值返回 int。该函数首先丢弃尽可能多的空白字符，直到找到第一个非空白字符。然后，从这个字符开始，选择一个可选的初始正号或负号，后面跟随尽可能多的基数为 10 的数字，并将它们解释为数字值。该字符串可以在形成整数的那些字符之后包含额外的字符，这些字符被忽略并且对该函数的行为没有影响。如果 str 中的第一个非空白字符序列不是有效整数，或者如果由于 str 为空或仅包含空格字符而不存在此类序列，则不执行转换并返回零。 Answer: 12345678910111213141516171819202122232425class Solution: def myAtoi(self, s): """ :type s: str :rtype: int """ s = s.strip() flag = 1 if not s: return 0 if s[0] in ['+', '-']: flag = -1 if s[0] == '-' else 1 s = s[1:] output = 0 for char in s: if char.isdigit(): output = output * 10 + int(char) else: break output *= flag if output &lt; -2147483648: return -2147483648 elif output &gt; 2147483647: return 2147483647 return output]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0007 Reverse Integer]]></title>
    <url>%2F2018%2F02%2F25%2F0007-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[7. Reverse Integer Given a 32-bit signed integer, reverse digits of an integer. Example: 12345678910Input: 123Output: 321Example 2:Input: -123Output: -321Example 3:Input: 120Output: 21 Note: Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Analysis: 题目要求将数字反转，但是要注意整数类型是 32-bit signed integer，所以返回的数字，范围要在 [-2^31, 2^31-1] 中。一开始想到是把数字转化为字符串，再根据切片的性质反转字符串，然后觉得用常规的除法也不错，所以有两种解法。 Answer 1: 12345678class Solution: def reverse(self, x): """ :type x: int :rtype: int """ x = int(str(x)[::-1]) if x &gt;= 0 else - int(str(-x)[::-1]) return x if - 2147483648 &lt;= x &lt;= 2147483647 else 0 Answer 2: 123456789101112class Solution: def reverse(self, x): """ :type x: int :rtype: int """ flag = 1 if x &gt; 0 else -1 x, output = abs(x), 0 while x: output = output * 10 + x % 10 x = x // 10 return output * flag if - 2147483648 &lt;= output * flag &lt;= 2147483647 else 0]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0006 ZigZag Conversion]]></title>
    <url>%2F2018%2F02%2F25%2F0006-ZigZag-Conversion%2F</url>
    <content type="text"><![CDATA[6. ZigZag Conversion The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 123P A H NA P L S I I GY I R And then read line by line: &quot;PAHNAPLSIIGYIR&quot;Write the code that will take a string and make this conversion given a number of rows: 1string convert(string text, int nRows); convert(&quot;PAYPALISHIRING&quot;, 3) should return &quot;PAHNAPLSIIGYIR&quot;. Analysis: 首先应该知道到底什么是 ZipZag，比如我们有一个字符串 0123456789。 图片来源：ZigZag Conversion 解题报告 根据图可以看出，当 rows = 3 时，我们要输出 0481357926，也就是第0层的字符串加第1层的字符串加第2层的字符串，那我们可以这么解决问题：先创建一个列表，里面存着与 rows 相等的空字符串，如 rows = 3，这个列表也就是 [&#39;&#39;, &#39;&#39;, &#39;&#39;]，这些字符串对应着第0层，第1层，第2层。显而易见，ZipZag 结构是按照字符串遍历，以列为基准填充字符的，要解决的就是何时将字符填入第0层，何时填入第1层等。仔细观察，从第一列开始，遇到最后1层也就是第2层时，填充方向反转，此时的数据将会被填入第1层，当遇到第0层时，填充方向又反转了。讲到这里，上代码！ Answer: 123456789101112131415class Solution: def convert(self, s, numRows): """ :type s: str :type numRows: int :rtype: str """ axis = 0 if numRows == 1 else -1 rows, idx = [''] * numRows, 0 for char in s: rows[idx] += char if idx == 0 or idx == numRows - 1: axis *= -1 idx += axis return ''.join(rows)]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0005 Longest Palindromic Substring]]></title>
    <url>%2F2018%2F02%2F25%2F0005-Longest-Palindromic-Substring%2F</url>
    <content type="text"><![CDATA[5. Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: 12345Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 123Input: &quot;cbbd&quot;Output: &quot;bb&quot; Analysis: 得到最大回文字符子串有很多方法。比如，我们可以为子字符串选择所有可能的开始和结束位置，并逐一验证它是否是回文的。这是一种暴力解决方法，往往会超出时间限制。另一种解法，可以从中间往两边探索，如果一样就继续找，不一样就停止。这种解法需要我们不断探索最重要的中间值，比如 cababade，我们找到的最大回文子串是 ababa，而 a 是中间值，我们从 a 入手，不断向左右扩展 a -&gt; bab -&gt; ababa，最终得到了最大回文子串。 Answer: 123456789101112131415161718class Solution: def longestPalindrome(self, s): """ :type s: str :rtype: str """ sub, longest, length = '', 0, len(s) for i in range(length): for j in range(i, i + 2): left, right = i, j while left &gt;= 0 and right &lt; length and s[left] == s[right]: left -= 1 right += 1 long = right - left - 1 if long &gt; longest: longest = long sub = s[left + 1 : right] return sub]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0004 Median of Two Sorted Arrays]]></title>
    <url>%2F2018%2F02%2F25%2F0004-Median-of-Two-Sorted-Arrays%2F</url>
    <content type="text"><![CDATA[4. Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: 12nums1 = [1, 3]nums2 = [2] The median is 2.0 Example 2: 12nums1 = [1, 2]nums2 = [3, 4] The median is (2 + 3) / 2 = 2.5 Analysis: 一看到中位数就想到 numpy 或者 statistics 模块了，抱着试一试的想法，没想到 AC 了，不重复造轮子嘛 hhh。 Answer: 123456789class Solution: def findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ import statistics return statistics.median(nums1 + nums2)]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0003 Longest Substring Without Repeating Characters]]></title>
    <url>%2F2018%2F02%2F25%2F0003-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[3. Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters. Example: Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3. Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1``. Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. Analysis: 题目很清晰，需要查找不重复的具有最大长度的子串。可以先遍历字符串，设置一个游标 start，并构造一个字典结构，当字符不在字典中时，将字符插入到字典。而字符如果能够插入到字典中，说明此时没有重复的字符，最大子串的长度显而易见是当前的 索引 i - start 与 maxLength 的最大值。当遇到重复的字符时，从重复字符出现的位置之后一位开始扫描，但此时，需要把游标 start 指向重复的元素的前一个位置的索引，相当于之后的 i - start 的前面的重复元素剔除了，这样又让子串里的元素不重复了。 Answer: 12345678910111213class Solution: def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ maxLength, start, charDict = 0, 0, &#123;&#125; for i, char in enumerate(s, 1): if charDict.get(char, -1) &gt;= start: start = charDict[char] charDict[char] = i maxLength = max(maxLength, i - start) return maxLength Simulation: 123456789101112131415161718192021222324252627282930313233s = 'abcabcbb'# 第一次循环：start = 0i = 1charDict['a'] = 1maxLength = 1# 第二次循环：start = 0i = 2charDict['b'] = 2maxLength = 2# 第三次循环：start = 0i = 3charDict['c'] = 3maxLength = 3# 第四次循环：i = 4start = 1charDict['a'] = 4maxLength = 3# 第五次循环：i = 5start = 2charDict['b'] = 5maxLength = 3# ...]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0002 Add Two Numbers]]></title>
    <url>%2F2018%2F02%2F25%2F0002-Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. Analysis: 本题类似于竖式的加法，需要考虑各位相加产生的进位问题：相同位相加时，大于10，就往前进1，可设置一个 flag，产生进位其就为1，否则为0，当运算进行到两个数已经没有最高位且本次运算不产生进位时，说明运算已完成，可退出循环。 Answer: 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ output = ListNode(0) tempNode, tempSum, flag = output, 0, 0 while True: if l1: tempSum += l1.val l1 = l1.next if l2: tempSum += l2.val l2 = l2.next tempNode.val = (tempSum + flag) % 10 flag = 1 if (tempSum + flag) &gt;= 10 else 0 tempSum = 0 if l1 == None and l2 == None and flag == 0: break tempNode.next = ListNode(0) tempNode = tempNode.next return output]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0001 Two Sum]]></title>
    <url>%2F2018%2F02%2F25%2F0001-Two-Sum%2F</url>
    <content type="text"><![CDATA[1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Analysis: 题目很简单，使用哈希表即可，需要注意的是不能使用同一个索引的元素两次，比如 [3, 3] 6 ，应该返回 [0, 1] 而不是 [0, 0]。一开始想先通过构建一个字典结构再循环判断 other_num 是否在字典中，如果在即可直接返回索引，所以有了 Answer 1，但是先构建字典结构效率会降低，可以在循环之中不断加入数据到字典，遂使用 Answer 2 解决。 Answer 1: 123456789101112class Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ d = &#123;num: i for i, num in enumerate(nums)&#125; for i, num in enumerate(nums): other_num = target - num if other_num in d and i != d[other_num]: return [i, d[other_num]] Answer 2: 1234567891011121314class Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ d = dict() for i, num in enumerate(nums): other_num = target - num if other_num in d: return [i, d[other_num]] else: d[num] = i]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Study</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多SSH Key解决方法]]></title>
    <url>%2F2018%2F01%2F01%2F%E5%A4%9ASSH-Key%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[有多个 SSH Key，如何在 SSH 连接时不产生冲突呢？ 在进行多个项目的时候，一般都会一个项目对应一个 SSH Key，算是为了避免冲突吧，也或者是碍于不可抗力因素需要多个 SSH Key… 通常都是使用 ssh-keygen 命令，一路回车生成 SSH Key： 1ssh-keygen -t rsa 这样在 ~/.ssh/ 目录下会默认生成 id_rsa.pub 和 id_rsa 文件，也就是公钥和私钥。 为了各自需要，有时候需要创建第二个 SSH Key： 1ssh-keygen -t rsa 在第一个返回结果下输入第二个 SSH Key 的名称，比如： 12Generating public/private rsa key pair.Enter file in which to save the key (/Users/sliver/.ssh/id_rsa): /Users/sliver/.ssh/id_second_rsa 输入密码可以选择回车跳过，然后将在 .ssh 目录下生成名称为 id_second_rsa.pub 和 id_second_rsa 的公钥和私钥。 之后在终端输入以下命令，将私钥添加到 ssh-agent 中： 12ssh-add ~/.ssh/id_rsassh-add ~/.ssh/id_second_rsa 如果有良好的密钥命名习惯的话可以直接输入： 1ssh-add ~/.ssh/*_rsa 一步到位，可以任意穿梭于多个 SSH 连接中了。 可使用 ssh-add -l 查看添加私钥的结果如何： 122048 SHA256:S97ZYNIuP0qqdDSBQLP6LD/2rGBgDlWCDyb2B3La1U0 /Users/sliver/.ssh/id_rsa (RSA)2048 SHA256:JWEstYUqxRK5tK2NVj17imvkaIN4kXTL7DSImImbmbI /Users/sliver/.ssh/id_second_rsa (RSA) 一般出现以上结果就对了。出问题时，可使用 ssh-add -d 删除指定私钥，或者 ssh-add -D 删除所有私钥，重新再来一遍即可。 在重启 PC 后，都要重新手动添加私钥到 ssh-agent，显然这是有些麻烦或是容易遗忘的。可以在 shell 配置文件中，我是在 ~/.zshrc 下，末尾添加： 1ssh-add ~/.ssh/*_rsa 以后终端也就可以自动添加私钥了，大功告成。 最后啰嗦一下 生成 Key 时，可能会需要添加自己的邮箱当做备注，可添加 -C 参数： 1ssh-keygen -t rsa -C &quot;your_email@gmail.com&quot; 在生成的公钥文件中可以看到添加的备注，自己去找找吧 hhh。]]></content>
      <categories>
        <category>方法</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Delicious Cookie]]></title>
    <url>%2F2017%2F12%2F29%2F%E5%A5%BD%E5%90%83%E7%9A%84Cookies%2F</url>
    <content type="text"><![CDATA[Cookie 是什么？好吃么？ 一个 Cookie 就是存储在用户主机浏览器中的一小段文本文件。Cookie 是纯文本形式，它们不包含任何可执行代码。一个 Web 页面或服务器告知浏览器来将这些信息存储并且基于一系列规则在之后的每个请求中都将该信息返回至服务器。Web 服务器之后可以利用这些信息来标识用户。 上面是科普，这里随便说说。其实要说 Cookie ，就要说它所立足的 HTTP 协议。HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。那么就会发生这种情况： 假设要求登录认证的 Web 页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面就要再次登录，或者要在每次请求报文中附加参数来管理登录状态。 是不是很麻烦？不过不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的 CPU 及内存资源的消耗。从另一侧面来说，也正是因为 HTTP 协议本身是非常简单的，所以才会被应用在各种场景里。 所以，为了保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。 概括下来，其实就是服务器为了辨别每个用户，就给客户端们颁发一个通行证，一人一个，无论谁访问都必须携带自己的通行证。这样服务器就能从通行证上确认客户身份了，这也就是 Cookie 的工作原理。 为什么突然说 Cookie 呢？因为之前爬教务系统，都是使用 requests 的 session 一口气保持会话的，很少去管 Cookie 的事，分模块和函数式编程的时候，才发现会话的中断和接下来请求的失败…所以特地补全一下知识漏洞吧 hhh。 什么是 CookieJar？首先，查看 requests 的官方文档： 123456789class requests.cookies.RequestsCookieJar(policy=None)[source]Compatibility class; is a cookielib.CookieJar, but exposes a dict interface.This is the CookieJar we create by default for requests and sessions that don't specify one, since some clients may expect response.cookies and session.cookies to support dict operations.Requests does not use the dict interface internally; it's just for compatibility with external client code. All requests code should work out of the box with externally provided instances of CookieJar, e.g. LWPCookieJar and FileCookieJar.Unlike a regular CookieJar, this class is pickleable. 差不多知道了 cookies 对象是 CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar等。各个 CookieJar 的关系是：CookieJar —-派生—-&gt;FileCookieJar —-派生—–&gt;MozillaCookieJar 和 LWPCookieJar 再查看 http.cookiejar — Cookie handling for HTTP clients 中 MozillaCookieJar 和 LWPCookieJar 的官方介绍： 123456789101112131415The following CookieJar subclasses are provided for reading and writing.class http.cookiejar.MozillaCookieJar(filename, delayload=None, policy=None) A FileCookieJar that can load from and save cookies to disk in the Mozilla cookies.txt file format (which is also used by the Lynx and Netscape browsers). Note This loses information about RFC 2965 cookies, and also about newer or non-standard cookie-attributes such as port. Warning Back up your cookies before saving if you have cookies whose loss / corruption would be inconvenient (there are some subtleties which may lead to slight changes in the file over a load / save round-trip). Also note that cookies saved while Mozilla is running will get clobbered by Mozilla.class http.cookiejar.LWPCookieJar(filename, delayload=None, policy=None) A FileCookieJar that can load from and save cookies to disk in format compatible with the libwww-perl library’s Set-Cookie3 file format. This is convenient if you want to store cookies in a human-readable file. 可见，MozillaCookieJar 和 LWPCookieJar 可对文件进行 Cookie 的存取改动。 动手试试存取 Cookie可以开始练练手了，先利用 LWPCookieJar 对象实现存取 Cookie 到文件的功能： 12345678910111213141516171819import requests, sysfrom http.cookiejar import LWPCookieJar as Cookiefrom requests.exceptions import RequestExceptionheaders = &#123; "User-Agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"&#125;s = requests.Session()# 声明一个 LWPCookieJar 对象s.cookies = Cookie()try: html = s.get("http://cas.hdu.edu.cn/cas/login",headers=headers,timeout=5)except RequestException: print("请求超时！请检查网络后再次尝试！") sys.exit(1)# 将获取到的 Cookie 存入文件中s.cookies.save('cookies.txt',ignore_discard=True,ignore_expires=True) save 方法中的两个参数的官方解释是： gnore_discard: save even cookies set to be discarded. ignore_expires: save even cookies that have expiredThe file is overwritten if it already exists 显然 ignore_discard 的意思是即使 Cookie 将会被丢弃也要将它保存下来，ignore_expires 的意思是如果在该文件中 Cookie 已经存在，则覆盖原文件写入，在这里，如果两个全部设置为True，运行之后，Cookie 将会被保存到 cookies.txt 文件中。 成功后我们可以找到新建立的 cookies.txt 文件，打开可看到获取的 Cookie： 123#LWP-Cookies-2.0Set-Cookie3: key_dcp_cas="vK8zhGgBzT8S1QHcgnypKRpRxTny1B1LM20Cmcn8SfMtw2ch2QxG!-1218671341"; path="/"; domain="cas.hdu.edu.cn"; path_spec; discard; HttpOnly=None; version=0Set-Cookie3: route=c4983b7b52b1d14e475c56063c71cbb3; path="/"; domain="cas.hdu.edu.cn"; path_spec; discard; version=0 从文件读取 Cookie现在可以试试从文件读取 Cookie 了： 12345678910111213141516import requestsfrom http.cookiejar import LWPCookieJar as Cookiedef load_cookies(): s = requests.session() s.cookies = Cookie() # 从文件读取 Cookie s.cookies.load('cookies.txt',ignore_discard=True,ignore_expires=True) return ss = load_cookies()# 直接打印 Cookieprint(s.cookies)dict = requests.utils.dict_from_cookiejar(s.cookies)# 打印字典形式的 Cookieprint(dict) 返回结果如下： 123&lt;LWPCookieJar[&lt;Cookie key_dcp_cas=vK8zhGgBzT8S1QHcgnypKRpRxTny1B1LM20Cmcn8SfMtw2ch2QxG!-1218671341 for cas.hdu.edu.cn/&gt;, &lt;Cookie route=c4983b7b52b1d14e475c56063c71cbb3 for cas.hdu.edu.cn/&gt;]&gt;&#123;'key_dcp_cas': 'vK8zhGgBzT8S1QHcgnypKRpRxTny1B1LM20Cmcn8SfMtw2ch2QxG!-1218671341', 'route': 'c4983b7b52b1d14e475c56063c71cbb3'&#125; 之后只要 Cookie 还在生存期内，就可以进教务网站利用Cookie 爬成绩、爬课表等，还是挺不错的。 Cookie 就讲这么多吧，以后用到更高级的方法再补充。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux服务器基础配置]]></title>
    <url>%2F2017%2F12%2F26%2FLinux%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[最近需要去配置服务器，所以可以先拿虚拟机练练手，并分享一下自己的配置过程。 Linux 简介首先，你一定会问：Linux 有什么作用呢？可以归类为四点： 商业服务器基本都是 Linux 开源软件都先支持 Linux 大数据分析、机器学习首选 Linux 整个互联网地基靠 Linux 撑起来 强大如斯，不得不用。为了去学 Linux，首先需要忘掉 Windows 的东西： Linux 下是没有 exe 形式的程序的 文件名等大小写在 Linux 下是需要区分的 Linux 下，一切皆文件 文件的后缀名并不是必须要的，它只是为了找到正确的打开方式而已 更多资料，参见百度百科：Linux 百度百科 为了使用 Linux，可以先去下载虚拟机。 虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。 简单来说，其实就是通过虚拟机可以在自己的电脑上安装另一个操作系统，而不会影响原系统。比如，做渗透的人，一般就会在虚拟机下用 Kali Linux 去做专业的渗透测试。Mac 平台下，可以使用 Parallels Desktop 虚拟机软件。 Parallels Desktop是一款运行在 Mac 电脑上的极为优秀的虚拟机软件。用户可以在 Mac OS X 下非常方便运行 Windows、Linux 等操作系统及应用。用户不必繁琐重复地重启电脑即可在 Win 与 Mac 之间切换甚至同时使用它们。 各位可以 Google 一下各种资源，涉及版权问题，就不多提了。 虚拟机软件安装并配置 CentOS CentOS下载：装好虚拟机后，就可以开始装 Linux 系统了，这里装的是 CentOS。安装推荐网易镜像(后续可能还有更新版本，以最新版本为准)：http://mirrors.163.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1708.iso下载完毕后，我是使用 Parallels Desktop 进行无脑安装的，新手指导还是挺简单的。安装完毕后，可以开始大干一场了。 配置网络：终端输入： 1vi /etc/sysconfig/network-scripts/ifcfg- 按住 Tab，补充显示的第一个文件名，我的是 ifcfg-eth0即最后的命令是： 1vi /etc/sysconfig/network-scripts/ifcfg-eth0 按 i 插入文字，找到 ONBOOT 一栏将其对应的值改成 yes，按 esc 后输入 :wq 退出编辑。现在回到终端输入： 1service network restart 这个时候再输入 ip addr 可以看到启动网络服务后的 IP 地址了。 安装网络工具包1yum install net-tools 安装成功后在 Parallels 界面将 CentOS 的网络设置为桥接网络，再使用 ifconfig 命令查看 IP。 1234567891011121314151617eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.3.12 netmask 255.255.255.0 broadcast 192.168.3.255 inet6 fe80::21c:42ff:fe50:f6f9 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:1c:42:50:f6:f9 txqueuelen 1000 (Ethernet) RX packets 32807 bytes 44041713 (42.0 MiB) RX errors 0 dropped 3 overruns 0 frame 0 TX packets 13811 bytes 1092135 (1.0 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1 (Local Loopback) RX packets 72 bytes 6248 (6.1 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 72 bytes 6248 (6.1 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 192.168.3.12就是我们需要的 IP 了(当然 IP 肯定各不相同)。 替换默认源网易 CentOS 镜像使用帮助： http://mirrors.163.com/.help/centos.html 首先查看我们当前的 CentOS 版本： 1cat /etc/redhat-release 我的是7.4版本，所以返回结果是： 1CentOS Linux release 7.4.1708 (Core) 知道版本后先去下载 wget，这里分享一下 wget 的资料： wget 是一个从网络上自动下载文件的自由工具，支持通过 HTTP、HTTPS、FTP 三个最常见的 TCP/IP协议 下载，并可以使用 HTTP 代理。”wget” 这个名称来源于 “World Wide Web” 与 “get” 的结合。 现在开始下载： 1sudo yum install wget 按照网易镜像帮助的提示，先 cd 到 yum.repos.d 目录： 1cd /etc/yum.repos.d/ 这个时候复制响应版本的源镜像链接，再用 wget 下载： 1sudo wget http://mirrors.163.com/.help/CentOS7-Base-163.repo 替换完毕后，依次输入以下两个命令，生成缓存： 12yum clean allyum makecache 这样可以快速下载 vim 了： 1sudo yum install vim 使用 oh-my-zsh 获取配置 zshzsh 是一个很强的 shell，拥有很多强劲的功能，它的的命令补全功能非常强大，可以补齐路径、补齐命令、补齐参数等，而且还有强大的别名功能，总之，一定好用。 zsh详细介绍 现在，开始配置 zsh 吧。可以先查看目前 CentOS 的默认 shell： 1echo $SHELL 返回结果如下： 1/bin/bash 果然不是 zsh 哈哈。那不死心再看看 bin 下有没有 zsh： 1cat /etc/shells 返回结果如下： 123456/bin/sh/bin/bash/sbin/nologin/bin/dash/bin/tcsh/bin/csh 好吧，还是没有…那自己去下吧。 1sudo yum -y install zsh 再去看看 bin 目录： 1cat /etc/shells 1234567/bin/sh/bin/bash/sbin/nologin/bin/dash/bin/tcsh/bin/csh/bin/zsh 已经有 zsh 了，将其替换为默认 shell 吧： 1sudo chsh -s /bin/zsh 重启一下： 1reboot 重新打开 CentOS，看看默认 shell： 1echo $SHELL 1/bin/zsh 成功。 获取 oh-my-zsh首先当然是要安装 git了： 1sudo yum -y install git 成功后下载 oh-my-zsh： 1sudo wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 成功后会显示如下界面： 1234567891011 __ __ ____ / /_ ____ ___ __ __ ____ _____/ /_ / __ \/ __ \ / __ `__ \/ / / / /_ / / ___/ __ \ / /_/ / / / / / / / / / / /_/ / / /_(__ ) / / / \____/_/ /_/ /_/ /_/ /_/\__, / /___/____/_/ /_/ /____/ ....is now installed!Please look over the ~/.zshrc file to select plugins, themes, and options.p.s. Follow us at https://twitter.com/ohmyzsh.p.p.s. Get stickers and t-shirts at http://shop.planetargon.com. 还挺 cool 的哈哈。 更改主题先 cd 到 .zshrc 所在目录： 12cd ~vim .zshrc 找到 ZSH_THEME 修改为 agnoster(agnoster是我一直比较喜欢的主题)： 1ZSH_THEME="agnoster" 保存启用修改： 1source ~/.zshrc vim 配色终端还有 vim 还是赏心悦目的好，先下载 Solarized： 1git clone git://github.com/altercation/solarized.git 颜色配置一下： 1234cd solarizedcd vim-colors-solarized/colorsmkdir -p ~/.vim/colorscp solarized.vim ~/.vim/colors/ 再去给 vim 配置一下吧：vim ~/.vimrc这里我加入了一些简单的 vim 自定义配置： 1234567891011121314151617syntax enableset background=darkcolorscheme solarizedset showmatch " 高亮显示对应的括号set number " 显示行号set cindent " C风格的对齐方式set autoindent " 自动对齐set confirm " 在处理未保存或只读文件的时候，弹出确认set tabstop=4 " Tab键的宽度syntax on " 自动语法高亮set softtabstop=4set shiftwidth=4 " 统一缩进为4set hlsearchset incsearch " 搜索逐字符高亮set gdefault " 行内替换set encoding=utf-8set completeopt=preview,menu 这样我们基本的 Linux 配置服务就完成了。 Mac 利用 SSH 连接 CentOS SSH工具 SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。 总而言之，SSH 是为本地的客户端与服务器上的服务端相互之间进行远程登录会话提供安全的的协议。 服务器安装 SSH 服务一般 Linux 的桌面发行版，即有 GUI 界面的发行版是没有安装 SSH 服务端的，可以使用如下命令安装： 1sudo yum install openssh-server 启动 SSH： 1service sshd start 查看是否启动： 1ps -ef |grep ssh 成功就可以看到这个进程了： 1&gt;&gt;&gt;root 1300 1 0 04:29 ? 00:00:00 /usr/sbin/sshd -D 设置开机运行： 1chkconfig sshd on 本地安装SSH服务Linux平台可以使用如下命令： 1sudo yum install openssh-clients Mac 直接使用 iTerm2 就行了，还可以尝试一下 SSH 连接： 1ssh sliver@192.168.3.12 输入服务器账户密码即可成功连接了。 使用 ssh-copy-id-for-OSX 工具将公钥复制至 ssh 服务器每次连接都要输入密码还是挺麻烦的，可以使用公钥登录的方法，免去每次都要输入密码的烦恼。 公钥登录是为了解决每次登录服务器都要输入密码的问题，流行使用 RSA 加密方案，主要流程包含： 1.客户端生成 RSA 公钥和私钥2.客户端将自己的公钥存放到服务器3.客户端请求连接服务器，服务器将一个随机字符串发送给客户端4.客户端根据自己的私钥加密这个随机字符串之后再发送给服务器5.服务器接受到加密后的字符串之后用公钥解密，如果正确就让客户端登录，否则拒绝。 这样也就不用使用密码了。那么，第一步当然是要生成公钥和秘钥了，在用户主目录下输入： 1ssh-keygen 直接一直回车到结束，生成的公钥和秘钥已经就在 ~/.ssh/ 目录下了，id_rsa.pub 即为所要的公钥。现在可以将公钥放到服务器上，这里使用一种比较简单的方法： 1234567brew install ssh-copy-idssh-copy-id username@hostname # 将username和hostname替换为你的ssh服务器用户名和IP# 不加参数默认使用~/.ssh/id_rsa.pub# 添加-i参数可以自定义添加的公钥ssh-copy-id -i ~/.ssh/id_rsa.pub username@hostname 使用 ssh-copy-id，可以将公钥自动保存到服务器用户目录下的 /.ssh/authorized_keys 文件中去，当然自己在服务器手动创建并复制粘贴公钥也是可以的。以后使用 ssh 登录服务器就不用再输入密码了： 1234ssh sliver@192.168.3.12&gt;&gt;&gt;Last login: Mon Dec 25 14:12:03 2017 from 192.168.3.5[sliver@localhost ~]$ 可以输入 exit 退出 ssh 连接。但还是要输入一大串不太好记的字符串，在 zsh 下可以使用别名： 12echo "alias ssh-to-username='ssh username@hostname'" &gt;&gt; ~/.zshrc #将username和hostname替换为你的服务器信息source ~/.zshrc 看看怎么样： 1234ssh-to-centos&gt;&gt;&gt;Last login: Mon Dec 25 14:17:31 2017 from 192.168.3.5[sliver@localhost ~]$ 也可以在 ~/.ssh/ 目录下创建 config 文件，添加如下代码： 1234Host alias_name HostName ip_address Port 22(默认) User user_name 我是这样添加的： 1234Host centos HostName 192.168.3.12 Port 22 User sliver 使用如下命令进行远程连接： 1ssh centos 舒服多了。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3爬虫相关库笔记]]></title>
    <url>%2F2017%2F12%2F14%2FPython3%E7%88%AC%E8%99%AB%E7%9B%B8%E5%85%B3%E5%BA%93%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[有时候一个爬虫程序，可能只有几行代码，但是它涉及到的知识面却很广，这里先记下一些相关知识，以此共勉。 JSON什么是 JSON ？JSON 指的是 JavaScript 对象表示法 (JavaScript Object Notation） JSON 是轻量级的文本数据交换格式 JSON 独立于语言 JSON 具有自我描述性，更易理解 JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 JSON 有什么优点？ 方便于传输，较少冗余的字符。当然直接传二进制是最好的，但面临难解析的问题。亦可以是 XML、纯字符串的方式，但 JSON 有其独到的好处。有兴趣可了解一下。 方便转换。有很多的 JSON API 提供了 JSON 字符串转成对象、对象转换成 JSON 串的方法。 易于阅读。JSON 代码的良好结构，可以很直观地了解存的是什么内容。 简而言之，JSON 就是比 XML 的基础上，去掉了标签，这样也就节省了大量的存储空间。 Python 中的 JSON 模块 json 模块提供了一种很简单的方式来编码和解码 JSON 数据。其中两个主要的函数是 json.dumps() 和 json.loads()，要比其他序列化函数库如 pickle 的接口少得多。下面演示如何将一个 Python 数据结构转换为 JSON： 12345678910import jsondata = &#123; 'name' : 'ACME', 'shares' : 100, 'price' : 542.23&#125;json_str = json.dumps(data)print(json_str) 12#返回结果&#123;"name": "ACME", "shares": 100, "price": 542.23&#125; 下面演示如何将一个 JSON 编码的字符串转换回一个 Python 数据结构： 123&gt;&gt;&gt; data = json.loads(json_str)&gt;&gt;&gt; print(data)&#123;'name': 'ACME', 'shares': 100, 'price': 542.23&#125; 如果要处理的是文件而不是字符串，可以使用 json.dump() 和 json.load() 来编码和解码 JSON 数据。例如： 1234567# Writing JSON datawith open('data.json', 'w') as f: json.dump(data, f)# Reading data backwith open('data.json', 'r') as f: data = json.load(f) JSON 编码支持的基本数据类型为 None，bool，int，float 和 str，以及包含这些类型数据的 lists，tuples 和 dictionaries。 对 dictionaries，keys 需要是字符串类型(字典中任何非字符串类型的key在编码时会先转换为字符串)。为了遵循 JSON 规范，你应该只编 Python 的 lists 和 dictionaries。而且，在 Web 应用程序中，顶层对象被编码为一个字典是一个标准做法。 JSON 编码的格式对于 Python 语法而已几乎是完全一样的，除了一些小的差异之外。比如，True 会被映射为 true，False 被映射为 false，而 None 会被映射为 null。下面是一个例子，演示了编码后的字符串效果： 1234567&gt;&gt;&gt; json.dumps(False)'false'&gt;&gt;&gt; d = &#123;'a': True,... 'b': 'Hello',... 'c': None&#125;&gt;&gt;&gt; json.dumps(d)'&#123;"b": "Hello", "c": null, "a": true&#125;' 总结 JSON 字符串转为字典 json.load / json.loads两个方法功能类似，可选参数也相同，最大的区别在于，json.load 方法接受的输入，即第一个参数，是包含 JSON 数据的文件对象，如 open 方法的返回对象。json.loads 接受的输入是 JSON 字符串，而非文件对象。从输入类型的区别也可以看出两者的使用场合。可选参数包括是否需要转换整型、浮点型等数值的参数，还有一些复杂的功能，暂时没有用到，以后有机会再了解。 字典转换为 JSON json.dump / json.dumps对应于 load 和 loads，dump 的第一个参数是对象字典，第二个参数是文件对象，可以直接将转换后的 JSON 数据写入文件，dumps 的第一个参数是对象字典，其余都是可选参数。dump 和 dumps 的可选参数相同，这些参数都相当实用，现将用到的参数记录如下： ensure_ascii 默认为 True，保证转换后的 JSON 字符串中全部是 ascii 字符，非 ascii 字符都会被转义。如果数据中存在中文或其他非 ascii 字符，最好将 ensure_ascii 设置为 False，保证输出结果正常。 indent 缩进，默认为 None ，没有缩进，设置为正整数时，输出的格式将按照 indent 指定的半角空格数缩进，相当实用。 separators 设置分隔符，默认的分隔符是(‘,’, ‘: ‘)，如果需要自定义 JSON 中的分隔符，例如调整冒号前后的空格数，可以按 (item_separator, key_separator) 的形式设置。 sort_keys 默认为 False，设为 True 时，输出结果将按照字典中的 key 排序。 1234567# 举例&gt;&gt;&gt; print(json.dumps(data, indent=4))&#123; "name": "ACME", "shares": 100, "price": 542.23&#125; DemjsonDemjson 是 Python 的第三方模块库，可用于编码和解码 JSON 数据，包含了 JSON 的格式化及校验功能。安装命令很简单，一个命令就可以搞定了： 1pip3 install demjson 现在来使用一下： 123456789101112131415import demjsondata = &#123; 'name' : 'ACME', 'shares' : 100, 'price' : 542.23&#125;json_str = demjson.encode(data) # 转换为JSON字符串print(json_str)text = demjson.decode(json_str) # 转换为字典print(text)&gt;&gt;&gt;&#123;"name":"ACME","price":542.23,"shares":100&#125;&gt;&gt;&gt;&#123;'name': 'ACME', 'price': 542.23, 'shares': 100&#125; Hashlibhashlib 是一个提供了一些流行的 hash 算法的 Python 标准库，其中所包括的算法有 md5，sha1，sha224，sha256，sha384，sha512。另外，模块中所定义的 new(name, string=”) 方法可通过指定系统所支持的hash算法来构造相应的 hash 对象。Python3 中 hashlib 模块代替了 Python2 中的 md5 和 sham 模块，使用这个模块一般分为3步： 创建一个哈希对象，使用哈希算法命名的构造函数或通用构造函数来创建。 使用哈希对象调用 update() 方法填充这个对象。 调用 digest() 或 hexdigest() 方法来获取摘要（加密结果）。 md5 加密： 12345678# md5加密import hashlibhash = hashlib.md5()hash.update('sliver'.encode('utf-8'))print(hash.hexdigest())&gt;&gt;&gt;241f166bdf9887f732ae06ba859da376 也可以这样实现 md5 加密： 123456789101112import hashlibhash1 = hashlib.md5(b'sliver')print(hash1.hexdigest())hash2 = hashlib.md5('sliver'.encode('utf-8'))print(hash2.hexdigest())# 也就是加密前必须先指定编码&gt;&gt;&gt;241f166bdf9887f732ae06ba859da376&gt;&gt;&gt;241f166bdf9887f732ae06ba859da376 sha1 加密： 12345678# sha1加密import hashlibhash = hashlib.sha1()hash.update('sliver'.encode('utf-8'))print(hash.hexdigest())&gt;&gt;&gt;e7896b82b9fcccbba18d905c0e374c4e8d612b08 sha256 加密： 12345678# sha256加密import hashlibhash = hashlib.sha256()hash.update('sliver'.encode('utf-8'))print(hash.hexdigest())&gt;&gt;&gt;66cb86b497f2b457cc6a19fafda4952bfbd831ed9c2d7ba12157ef269ecf3885 sha512 加密： 12345678# sha512加密import hashlibhash = hashlib.sha512()hash.update('sliver'.encode('utf-8'))print(hash.hexdigest())&gt;&gt;&gt;f3e8498d2d0b2a91cc29e085ca22c4ca27345633b023ba8ec83430784ee715a9bb5a27e758ce04eb7b653c079e7264753fc313d7eb5df352e43e34c324d88bf0 “加盐”加密： 以上的算法确实是密码学大佬们的结晶，但比如sha1算法还是可以通过暴力破解被破解出来的，这时候，自己自定义加上key，俗称“加盐”，能让加密算法更加安全。 12345678# “加盐”加密import hashlibhash = hashlib.md5('ariel'.encode('utf-8'))hash.update('sliver'.encode('utf-8'))print(hash.hexdigest())&gt;&gt;&gt;077ee0a6276e80b65a42de44a27b9f08 GetPass众所周知，Linux 系统下，在终端输入密码时，是不显示密码位数的（不回显）。这也告诉我们：为了安全，核心的操作应该要设为不可见的。Python 也为我们提供了类似功能的库，getpass。它的核心代码很短，却很有用。 首先看看模块中主要的两个函数的 API 和介绍: getpass.getpass(prompt=&#39;Password: &#39;, stream=None) 1234567891011Prompt the user for a password without echoing. The user is prompted using the string prompt, which defaults to &apos;Password: &apos;.On Unix, the prompt is written to the file-like object stream using the replace error handler if needed. stream defaults to the controlling terminal (/dev/tty) or if that is unavailable to sys.stderr (this argument is ignored on Windows).If echo free input is unavailable getpass() falls back to printing a warning message to stream and reading from sys.stdin and issuing a GetPassWarning.Note: If you call getpass from within IDLE, the input may be done in the terminal you launched IDLE from rather than the idle window itself.exception getpass.GetPassWarningA UserWarning subclass issued when password input may be echoed. 调用该函数可以在命令行窗口里无回显输入密码。参数 prompt 代表提示字符串，默认是 Password:，有点类似 input。在 Unix 系统中，stream 默认为当前控制的终端。而在 Windows 系统中 stream 参数会被忽略掉，默认使用 stdin，另外在 IDLE 下使用 getpass 的话，一般会转换成终端来运行脚本。如果无法正常使用 getpass，会引发一个 GetPassWarning 错误，然后模块会使用有回显的输入模式读取数据。 getpass.getuser() 12345Return the “login name” of the user.This function checks the environment variables LOGNAME, USER, LNAME and USERNAME, in order, and returns the value of the first one which is set to a non-empty string. If none are set, the login name from the password database is returned on systems which support the pwd module, otherwise, an exception is raised. 通过这个函数可以去 Shell 的环境变量中获取当前用户名。 动手试试吧： 123456import getpassuser = getpass.getuser()print('Hello,',user)password = getpass.getpass('Please enter your password: ')print("Your password is:", password) 返回结果如下： 123Hello, sliverPlease enter your password:Your password is: 123456 PrettyTablePrettyTable 是 Python 的第三方模块，需要手动下载： 1pip install prettytable 这个模块可以将数据输出的如表格一般好看、整齐，很适合强迫症患者 hhh。现在来使用一下吧： 1234567from prettytable import PrettyTable as pttable = pt(["姓名", "性别", "成绩"])table.add_row(["Sliver", "男", 95])table.add_row(["Ariel", "女", 99])table.add_row(["Hollen", "男", 80])print(table) 结果如下： 总结 想要创建一个表，先进行初始化： 123from prettytable import PrettyTable as pttable = pt() 接下来就是添加表中的元素了： 123456# 按行添加table = pt(["姓名", "性别", "成绩"])table.add_row(["Sliver", "男", 95])table.add_row(["Ariel", "女", 99])table.add_row(["Hollen", "男", 80])print(table) 按行添加时，列表要在初始化时就要插入一个列表当做表头，否则 PrettyTable 会使用Field 1 | Field 2 | Field 3依次进行表头填充。 123456# 按列添加table = pt()table.add_column("姓名", ["Sliver", "Ariel", "Hollen"])table.add_column("性别", ["男", "女" ,"男"])table.add_column("成绩", [95, 99, 80])print(table) 按列添加时，不需要对表头进行初始化，但是插入列时，要添加要插入的列的名称。 其他功能 无表格框输出： 1print(pt.get_string()) 可将表按某列数值进行排序： 1print(table.get_string(sortby="成绩", reversesort=True)) 想了解更多功能可转到 Python PrettyTable 模块 FunctoolsFunctools 是一个很厉害的库，看看官方的介绍： 123The functools module is for higher-order functions: functions that act on or return other functions. In general, any callable object can be treated as a function for the purposes of this module. 简单来说，functools 是面向高阶函数的函数：指那些作用于函数或者返回其他函数的函数。通常情况下，只要是可以被当做函数调用的对象就是这个模块的目标。 这里主要介绍该模块的 partial() 函数。 partial() 函数是将所要承载的函数作为 partial() 函数的第一个参数，原函数的各个参数依次作为partial() 函数后续的参数，当然也可以使用关键字参数来赋值。 有时候函数的参数个数可能会很多，但在后续使用时，我们已经知道要一直使用这个参数，就可以使用 partial() 函数来简化函数。partial() 可以创建一个新的函数，这个新函数可以固定住原函数的全部或部分参数，从而在调用函数时更简单。 这里附上用于简化 BeautifulSoup 的例子： 12345678910111213141516import requests, sysfrom requests.exceptions import RequestExceptionfrom functools import partialfrom bs4 import BeautifulSoupheaders = &#123; "User-Agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"&#125;bs = partial(BeautifulSoup, features='html5lib')s = requests.Session()try: html = s.get("http://cas.hdu.edu.cn/cas/login", headers=headers, timeout=5) print(bs(html.text).prettify())except RequestException: print("请求超时!请检查网络后再次尝试!") sys.exit(1) 查看更多函数：Python functools模块学习总结 Python 中的函数eval(str) eval(str) 函数很强大，它是 Python 用于执行字符串内的表达式的一个内置函数，使用 eval，可以很方便的将字符串动态执行。 eval() 函数常见作用有： 1、计算字符串中有效的表达式，并返回结果 123456&gt;&gt;&gt; eval('pow(2,2)')4&gt;&gt;&gt; eval('2 + 2')4&gt;&gt;&gt; eval("4 * 4")16 2、将字符串转成相应的 Python 对象（如 list、tuple、dict 和 string 之间的转换） 123456789101112&gt;&gt;&gt; a = "[[1,2], [3,4], [5,6], [7,8], [9,0]]"&gt;&gt;&gt; b = eval(a)&gt;&gt;&gt; b[[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]]&gt;&gt;&gt; a = "&#123;1:'xx',2:'yy'&#125;"&gt;&gt;&gt; c = eval(a)&gt;&gt;&gt; c&#123;1: 'xx', 2: 'yy'&#125;&gt;&gt;&gt; a = "(1,2,3,4)"&gt;&gt;&gt; d = eval(a)&gt;&gt;&gt; d(1, 2, 3, 4) 3、将利用反引号转换的字符串再反转回对象 12345678910&gt;&gt;&gt; list1 = [1,2,3,4,5]&gt;&gt;&gt; `list1`'[1, 2, 3, 4, 5]'&gt;&gt;&gt; type(`list1`)&lt;type 'str'&gt;&gt;&gt;&gt; type(eval(`list1`))&lt;type 'list'&gt;&gt;&gt;&gt; a = eval(`list1`)&gt;&gt;&gt; a[1, 2, 3, 4, 5] 尾声先写这么多吧，未完待续。]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3爬虫之urllib模块的使用]]></title>
    <url>%2F2017%2F12%2F07%2FPython3%E7%88%AC%E8%99%AB%E4%B9%8Burllib%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[今天来说说 Python3 内置的一个 HTTP 请求库，urllib。 官方文档：urllib — URL handling modules urllib 中包括了四个模块，包括了：urllib.request，urllib.error，urllib.parse，urllib.robotparser urllib.request (请求模块)：可以用来发送 request 和获取 request 的结果 urllib.error (异常处理模块)：包含了 urllib.request 产生的异常 urllib.parse (URL 解析模块)：用来解析和处理URL urllib.robotparse (robots.txt 解析模块)：用来解析页面的 robots.txt 文件 显而易见，urllib.request 库和 urllib.error 库是在一次模拟请求中比较重要的库。 使用 urllib.request 发送请求 简单 urllib.request.urlopen() 使用方法urllib.request 模块提供了最基本的构造 HTTP 请求的方法，利用它可以模拟浏览器的一个请求发起过程，同时它还带有处理 authenticaton(授权验证)，redirections(重定向)，cookies(浏览器 Cookies) 以及其它内容。首先，先试着抓取一下百度的页面： 1234import urllib.request response = urllib.request.urlopen("http://www.baidu.com") print(response.read().decode("utf-8")) 真正的代码其实只有两行，我们便完成了对百度首页的抓取，并输出了它的网页源代码。在爬虫程序中，得到了网页源代码之后，你所需要的链接、图片、视频、文本信息等就可以在网页源代码中查找并提取出来。现在尝试利用 type 函数输出 response 的类型： 1234import urllib.request response = urllib.request.urlopen("http://www.baidu.com") print(type(response)) 输出结果为：&lt;class &#39;http.client.HTTPResponse&#39;&gt;通过输出结果可以发现它是一个 http.client.HTTPResponse 类型的对象，它主要包含的方法有 read()、readinto()、getheader(key)、getheaders()、fileno() 等函数和 msg、version、status、reason、debuglevel、closed 等属性。得到这个对象之后，将其赋值给 response，就可以用 response 调用这些方法和属性，以此得到返回结果和信息。如 response.read().decode(&quot;utf-8&quot;) 可以得到返回后的利用 utf-8 编码的网页内容，response.status 可以得到响应返回结果的状态码。下面再来一个实例感受一下： 123456789&gt;&gt;&gt; import urllib.request&gt;&gt;&gt;&gt;&gt;&gt; response = urllib.request.urlopen("http://www.baidu.com")&gt;&gt;&gt; print(response.status)200&gt;&gt;&gt; print(response.getheaders())[('Date', 'Thu, 07 Dec 2017 14:37:26 GMT'), ('Content-Type', 'text/html; charset=utf-8'), ('Transfer-Encoding', 'chunked'), ('Connection', 'Close'), ('Vary', 'Accept-Encoding'), ('Set-Cookie', 'BAIDUID=3D72FEFAEEE60FAB2F79886A59FAC02D:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com'), ('Set-Cookie', 'BIDUPSID=3D72FEFAEEE60FAB2F79886A59FAC02D; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com'), ('Set-Cookie', 'PSTM=1512657446; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com'), ('Set-Cookie', 'BDSVRTM=0; path=/'), ('Set-Cookie', 'BD_HOME=0; path=/'), ('Set-Cookie', 'H_PS_PSSID=25263_1467_21122_25178_20718; path=/; domain=.baidu.com'), ('P3P', 'CP=" OTI DSP COR IVA OUR IND COM "'), ('Cache-Control', 'private'), ('Cxy_all', 'baidu+90b96fddd3e4cc794d4573d45036518c'), ('Expires', 'Thu, 07 Dec 2017 14:36:39 GMT'), ('X-Powered-By', 'HPHP'), ('Server', 'BWS/1.1'), ('X-UA-Compatible', 'IE=Edge,chrome=1'), ('BDPAGETYPE', '1'), ('BDQID', '0xe4820d9700009820'), ('BDUSERID', '0')]&gt;&gt;&gt; print(response.getheader("Server"))BWS/1.1 可见，三个输出分别输出了响应的状态码，响应的头信息，以及通过传递一个参数来获取对应的头信息。 高级 urllib.request.urlopen() 使用方法利用 urlopen() 方法，我们可以实现对一般网页的 GET 请求。如果我们想给链接传递一些参数该怎么实现呢？我们首先看一下 urlopen() 函数的 API。 urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None) 可以发现除了第一个参数可以传递 URL 之外，我们还可以传递其它的内容，比如 data(附加参数)，timeout(超时时间) 等等。data 参数是可选的，如果要添加 data，它要求是字节流编码格式的内容，即 bytes 类型，通过 bytes() 函数可以进行转化，另外如果你传递了这个 data 参数，它的请求方式就不再是 GET 方式请求，而是 POST。 1234567import urllib.parse import urllib.request data = bytes(urllib.parse.urlencode(&#123;'word': 'hello'&#125;), encoding='utf-8') response = urllib.request.urlopen('http://httpbin.org/post', data=data) print(response.read().decode('utf-8'))# read 获取的是 bytes 型的数据，decode 可按特定编码方式编码(相当于获取响应体)。 在这里我们传递了一个参数 word，值是 hello。它需要被转码成 bytes(字节流) 类型。其中转字节流采用了 bytes() 方法，第一个参数需要是 str(字符串) 类型，需要用 urllib.parse.urlencode() 方法来将参数字典转化为字符串。第二个参数指定编码格式，在这里指定为 utf-8。提交的网址是 httpbin.org，它可以提供 HTTP 请求测试。http://httpbin.org/post 这个地址可以用来测试 POST 请求，它可以输出请求和响应信息，其中就包含我们传递的 data 参数。运行结果如下： 12345678910111213141516171819&#123; "args": &#123;&#125;, "data": "", "files": &#123;&#125;, "form": &#123; "word": "hello" &#125;, "headers": &#123; "Accept-Encoding": "identity", "Connection": "close", "Content-Length": "10", "Content-Type": "application/x-www-form-urlencoded", "Host": "httpbin.org", "User-Agent": "Python-urllib/3.6" &#125;, "json": null, "origin": "112.10.180.190", "url": "http://httpbin.org/post"&#125; 我们传递的参数出现在了 form 中，这表明我们的 Python 语句模拟了表单提交的方法，并以 POST 方式传输数据。 timeout 参数timeout 参数可以设置超时时间，单位为秒，意思就是如果请求超出了设置的这个时间还没有得到响应，就会抛出异常，如果不指定，就会使用全局默认时间。它支持 HTTP、HTTPS、FTP 请求。下面来用一个实例感受一下： 1234import urllib.request response = urllib.request.urlopen("http://httpbin.org/get",timeout=0.1) print(response.read()) 结果如下： 1234567891011121314151617During handling of the above exception, another exception occurred:Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "/Users/sliver/anaconda3/lib/python3.6/urllib/request.py", line 223, in urlopen return opener.open(url, data, timeout) File "/Users/sliver/anaconda3/lib/python3.6/urllib/request.py", line 526, in open response = self._open(req, data) File "/Users/sliver/anaconda3/lib/python3.6/urllib/request.py", line 544, in _open '_open', req) File "/Users/sliver/anaconda3/lib/python3.6/urllib/request.py", line 504, in _call_chain result = func(*args) File "/Users/sliver/anaconda3/lib/python3.6/urllib/request.py", line 1346, in http_open return self.do_open(http.client.HTTPConnection, req) File "/Users/sliver/anaconda3/lib/python3.6/urllib/request.py", line 1320, in do_open raise URLError(err)urllib.error.URLError: &lt;urlopen error timed out&gt; 在这里我们设置了超时时间是0.1秒，在0.1秒过后服务器依然没有响应，于是程序抛出了 urllib.error.URLError 异常，错误原因是 timed out。因此我们可以通过设置这个超时时间来控制一个网页如果长时间未响应就跳过它的抓取，利用 try，except 语句就可以实现这样的操作。 123456789import urllib.request import socket import urllib.error try: response = urllib.request.urlopen('http://httpbin.org/get',timeout=0.1) except urllib.error.URLError as e: if isinstance(e.reason, socket.timeout): print("Time out!") 在这里我们请求了 http://httpbin.org/get 这个测试链接，设置了超时时间是0.1秒，然后捕获了 urllib.error.URLError 这个异常，然后判断异常原因是超时异常，就得出它确实是因为超时而报错，打印输出了 TIME OUT，当然你也可以在这里做其他的处理。运行结果如下： 1Time out! 常理来说，0.1秒内基本不可能得到服务器响应，因此输出了 TIME OUT 的提示。这样，我们可以通过设置 timeout 这个参数来实现超时处理，有时还是很有用的。其他参数还有context参数，它必须是 ssl.SSLContext 类型，用来指定 SSL 设置。cafile 和capath 两个参数是指定 CA证书 和它的路径，这个在请求 HTTPS 链接时会有用。cadefault 参数现在已经弃用了，默认为 False。以上讲解了 url.request.urlopen() 方法的用法，通过这个最基本的函数可以完成简单的请求和网页抓取，如需详细了解，可以查看官方文档：https://docs.python.org/3/library/urllib.request.html urllib.request.Request() 使用方法由上我们知道利用 urlopen() 方法可以实现最基本的请求发起，但这几个简单的参数并不足以构建一个完整的请求，如果请求中需要加入 headers 等信息，我们就可以利用更强大的 Request 类来构建一个请求。首先我们用一个实例来感受一下 Request 的用法: 12345import urllib.request request = urllib.request.Request("https://www.baidu.com") response = urllib.request.urlopen(request) print(response.read().decode("utf-8")) 可以发现，我们依然是用 urlopen() 方法来发送这个请求，只不过这次 urlopen() 方法的参数不再是一个 URL，而是一个 Request，通过构造这个这个数据结构，一方面我们可以将请求独立成一个对象，另一方面一个请求可配置的参数将更加丰富和灵活。下面我们看一下 Request 都可以通过怎样的参数来构造，它的构造方法如下： urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None) 第一个参数是请求链接，这个是必传参数，其他的都是可选参数。data 参数如果要传必须传 bytes(字节流) 类型的，如果是一个字典，可以先用 urllib.parse.urlencode() 编码。headers 参数是一个字典，你可以在构造 Request 时通过 headers 参数传递，也可以通过调用 Request 对象的 add_header() 方法来添加请求头。请求头最常用的用法就是通过修改 User-Agent 来伪装浏览器，默认的 User-Agent 是 Python-urllib，你可以通过修改它来伪装成浏览器。origin_req_host 指的是请求方的 host 名称或是 IP 地址。unverifiable 指的是这个请求是否是无法验证的，默认是 False。意思就是说用户没有足够权限来选择接收这个请求的结果。例如我们请求一个 HTML 文档中的图片，但是我们没有自动抓取图像的权限，这时 unverifiable 的值就是 True。method 是一个字符串，它用来指示请求使用的方法，比如 GET，POST，PUT 等等。下面我们传入多个参数构建一个 Request 来感受一下： 1234567891011121314from urllib import request,parse url = "http://httpbin.org/post" headers = &#123; "User-Agent":'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36', "Host":'httpbin.org' &#125; dict = &#123; "name":"Germey" &#125; data = bytes(parse.urlencode(dict),encoding="utf-8") req = request.Request(url=url,data=data,headers=headers,method="POST") response = request.urlopen(req) print(response.read().decode("utf-8")) 在这里我们通过四个参数构造了一个 Request，url 即请求链接，在 headers 中指定了 User-Agent 和 Host，传递的参数 data 用了 urlencode() 和 bytes() 方法来转成字节流，另外指定了请求方式为 POST。运行结果如下： 12345678910111213141516171819&#123; "args": &#123;&#125;, "data": "", "files": &#123;&#125;, "form": &#123; "name": "Germey" &#125;, "headers": &#123; "Accept-Encoding": "identity", "Connection": "close", "Content-Length": "11", "Content-Type": "application/x-www-form-urlencoded", "Host": "httpbin.org", "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36" &#125;, "json": null, "origin": "112.10.180.190", "url": "http://httpbin.org/post"&#125; 通过观察结果可以发现，我们成功设置了 data，headers 以及 method 参数，并完成了请求。另外 headers 也可以用 add_header() 方法来添加： 12req = request.Request(url=url, data=data, method='POST')req.add_header('User-Agent', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36') 如此一来，我们就可以更加方便地构造一个 Request，实现请求的发送。 urllib.request 高级特性在上面的过程中，我们虽然可以构造 Request，但是一些更高级的操作，比如 Cookies 处理，代理该怎样来设置？接下来就需要更强大的工具 Handler 登场了。简而言之你可以把它理解为各种处理器，有专门处理登录验证的，有处理 Cookies 的，有处理代理设置的，利用它们我们几乎可以做到任何HTTP请求中所有的事情。首先介绍下 urllib.request.BaseHandler，它是所有其他 Handler 的父类，它提供了最基本的 Handler 的方法，例如 efault_open()、protocol_request() 等。接下来就有各种 Handler 类继承这个 BaseHandler，列举如下： HTTPDefaultErrorHandler：用于处理HTTP响应错误，错误都会抛出 HTTPError 类型的异常。 HTTPRedirectHandler：用于处理重定向。 HTTPCookieProcessor：用于处理 Cookie 。 ProxyHandler：用于设置代理，默认代理为空。 HTTPPasswordMgr：用于管理密码，它维护了用户名密码的表。 HTTPBasicAuthHandler：用于管理认证，如果一个链接打开时需要认证，那么可以用它来解决认证问题。 另外还有其他种类的 Handler，可以参考官方文档：https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler 另外一个比较重要的就是 OpenerDirector，我们可以称之为 Opener，我们之前用过 urllib.request.urlopen() 这个方法，实际上它就是一个 Opener。那么为什么要引入 Opener 呢？因为我们需要实现更高级的功能，之前我们使用的 Request、urlopen() 相当于类库为你封装好了极其常用的请求方法，利用它们两个我们就可以完成基本的请求，但是现在不一样了，我们需要实现更高级的功能，所以我们需要深入一层，使用更上层的实例来完成我们的操作。所以，在这里我们就用到了比调用 urlopen() 的对象的更普遍的对象，也就是 Opener。Opener 可以使用 open() 方法，返回的类型和 urlopen() 如出一辙。那么它和 Handler 有什么关系？简而言之，就是可以利用 Handler 来构建 Opener。 认证 我们先用一个实例来感受一下： 1234567import urllib.request auth_handler = urllib.request.HTTPBasicAuthHandler() auth_handler.add_password(realm='PDQ Application', uri='https://mahler:8092/site-updates.py', user='klem', passwd='kadidd!ehopper') opener = urllib.request.build_opener(auth_handler) urllib.request.install_opener(opener) urllib.request.urlopen('http://www.example.com/login.html') 此处代码为实例代码，用于说明 Handler 和 Opener 的使用方法。在这里，首先实例化了一个 HTTPBasicAuthHandler 对象，然后利用 add_password() 添加进去用户名和密码，相当于建立了一个处理认证的处理器。接下来利用 urllib.request.build_opener() 方法来利用这个处理器构建一个 Opener，那么这个 Opener 在发送请求的时候就具备了认证功能了。然后利用 Opener的open() 方法打开链接，就可以完成认证了。 代理 如果添加代理，可以这样做： 123456789import urllib.request proxy_handler = urllib.request.ProxyHandler(&#123; 'http': 'http://218.202.111.10:80', 'https': 'https://180.250.163.34:8888' &#125;) opener = urllib.request.build_opener(proxy_handler) response = opener.open('https://www.baidu.com') print(response.read()) 此处代码为实例代码，用于说明代理的设置方法，代理可能已经失效。 在这里使用了 ProxyHandler，ProxyHandler 的参数是一个字典，key 是协议类型，比如 HTTP 还是 HTTPS 等，value 是代理链接，可以添加多个代理。然后利用 build_opener() 方法利用这个 Handler 构造一个 Opener，然后发送请求即可。 Cookies 设置 我们先用一个实例来感受一下怎样将网站的 Cookie 获取下来。 12345678import http.cookiejar, urllib.request cookie = http.cookiejar.CookieJar() handler = urllib.request.HTTPCookieProcessor(cookie) opener = urllib.request.build_opener(handler) response = opener.open('http://www.baidu.com') for item in cookie: print(item.name+"="+item.value) 首先我们必须声明一个 CookieJar 对象，接下来我们就需要利用 HTTPCookieProcessor 来构建一个 handler，最后利用 build_opener 方法构建出 opener，执行 open() 即可。运行结果如下： 123456BAIDUID=2B835BFCEDF4325F88D0C6C3A4EBD649:FG=1BIDUPSID=2B835BFCEDF4325F88D0C6C3A4EBD649H_PS_PSSID=1427_24569_21091_18559_25178PSTM=1512660072BDSVRTM=0BD_HOME=0 可以看到输出了每一条 Cookie 的名称还有值。不过既然能输出，那可不可以输出成文件格式呢？我们知道很多 Cookie 实际也是以文本形式保存的.答案当然是肯定的，我们用下面的实例来感受一下： 12345678import http.cookiejar, urllib.requestfilename = 'cookie.txt' cookie = http.cookiejar.MozillaCookieJar(filename) handler = urllib.request.HTTPCookieProcessor(cookie) opener = urllib.request.build_opener(handler) response = opener.open('http://www.baidu.com') cookie.save(ignore_discard=True, ignore_expires=True) 这时的 CookieJar 就需要换成 MozillaCookieJar，生成文件时需要用到它，它是 CookieJar 的子类，可以用来处理 Cookie 和文件相关的事件，读取和保存 Cookie，它可以将 Cookie 保存成 Mozilla 型的格式。运行之后可以发现生成了一个 cookie.txt 文件。内容如下： 12345678910# Netscape HTTP Cookie File# http://curl.haxx.se/rfc/cookie_spec.html# This is a generated file! Do not edit..baidu.com TRUE / FALSE 3660143901 BAIDUID 96CAB1FCD2CD9F4D304DE943A7018842:FG=1.baidu.com TRUE / FALSE 3660143901 BIDUPSID 96CAB1FCD2CD9F4D304DE943A7018842.baidu.com TRUE / FALSE H_PS_PSSID 1453_19034_21117_17001_25177.baidu.com TRUE / FALSE 3660143901 PSTM 1512660254www.baidu.com FALSE / FALSE BDSVRTM 0www.baidu.com FALSE / FALSE BD_HOME 0 另外还有一个 LWPCookieJar，同样可以读取和保存 Cookie，但是保存的格式和 MozillaCookieJar 的不一样，它会保存成与 libwww-perl 的 Set-Cookie3 文件格式的 Cookie。那么在声明时就改为 cookie = http.cookiejar.LWPCookieJar(filename)生成的内容如下：由此看来生成的格式还是有比较大的差异的。 1234567#LWP-Cookies-2.0Set-Cookie3: BAIDUID="A84BFF86A8AACB4C3B4CD734F7D11193:FG=1"; path="/"; domain=".baidu.com"; path_spec; domain_dot; expires="2085-12-25 18:40:37Z"; version=0Set-Cookie3: BIDUPSID=A84BFF86A8AACB4C3B4CD734F7D11193; path="/"; domain=".baidu.com"; path_spec; domain_dot; expires="2085-12-25 18:40:37Z"; version=0Set-Cookie3: H_PS_PSSID=25292_1433_24885_21104_18560_17001_25178_20930; path="/"; domain=".baidu.com"; path_spec; domain_dot; discard; version=0Set-Cookie3: PSTM=1512660390; path="/"; domain=".baidu.com"; path_spec; domain_dot; expires="2085-12-25 18:40:37Z"; version=0Set-Cookie3: BDSVRTM=0; path="/"; domain="www.baidu.com"; path_spec; discard; version=0Set-Cookie3: BD_HOME=0; path="/"; domain="www.baidu.com"; path_spec; discard; version=0 那么生成了 Cookie 文件，怎样从文件读取并利用呢？下面我们以 LWPCookieJar 格式为例来感受一下： 12345678import http.cookiejar, urllib.requestcookie = http.cookiejar.LWPCookieJar() cookie.load('cookie.txt', ignore_discard=True, ignore_expires=True) handler = urllib.request.HTTPCookieProcessor(cookie) opener = urllib.request.build_opener(handler) response = opener.open('http://www.baidu.com') print(response.read().decode('utf-8')) 前提是我们首先利用上面的方式生成了 LWPCookieJar 格式的 Cookie，然后利用 load() 方法，传入文件名称，后面同样的方法构建 handler 和 opener 即可。运行结果正常输出百度网页的源代码。 小结 urllib 是 Python3 中写爬虫程序的得力助手，它很好，当然，也有比它更好的。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3爬虫之基本概念]]></title>
    <url>%2F2017%2F12%2F07%2FPython3%E7%88%AC%E8%99%AB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[学了 Python 也有一段时间了，这几天才开始去接触爬虫，再一次感叹 Python 的强大。而爬虫是之前一直接触的名词，但自以为一直没有学好基础，就一直没有去接触，在这次在学习的过程中，终于揭开了它的面纱。 爬虫，顾名思义，就是一只会爬行的虫子，如果把网络比喻成一张网，爬虫就是爬行在这张网上的小蜘蛛，网所及之处，都是它能到达的地方。顺到网页所在之处，获取需要的大量数据，就是爬虫的意义所在。简而言之，它就是一个能请求网站并提取其中的数据的自动化程序。 爬虫基本流程 发起请求：通过 HTTP 库向目标站点发起请求，即发送一个 Request，请求可以包含额外的 headers、data 等信息，等待服务器响应。 获取响应内容：如果服务器能正常响应，会得到一个 Response，Response 的内容便是所要获取的页面内容，类型可能有 HTML，JSON 字符串，二进制数据（如图片视频）等类型。 解析内容：得到的内容可能是HTML，可以用正则表达式，网页解析库进行解析，可能是 JSON，可以直接转为 JSON 对象解析，可能是二进制数据，可以做保存或者进一步的处理。 保存数据：保存形式多样，可以保存为文本，也可以保存至数据库，或者保存至数据库，或者保存特定格式的文件。 那么什么是 Request 和 Response 呢？ 首先要了解一下 HTTP 协议，这里简单说一下。在 HTTP 协议中，请求访问文本或图像资源的一端称为客户端，而提供资源响应的一端称为服务器端。在我们用浏览器访问一个网页时，浏览器和远在云端的服务器其实就分别扮演着客户端和服务端的角色。 当浏览器发送消息给我们请求的网页所在的服务器时，这个过程就是 HTTP Request。 服务器收到浏览器发送的消息后，能够根据浏览器发送消息的内容，采取相应处理，然后把消息传回给浏览器，这个过程叫做 HTTP Response。 浏览器收到服务器的 Response 信息后，会对信息进行相应处理，然后展示。 下面分别来看看 Request 和 Response 的内容 Request 请求方式：主要有 GET、POST 两种请求类型，另外还有不常用的 HEAD、PUT、DELETE、OPTIONS 请求类型等。 请求 URL：URL 全称为统一资源定位符，它就像人们可以通过自己所在的地址来定位自己一样，URL 通过资源所在的位置来唯一确定资源，如一个网页文档、一张图片、一个视频都能用 URL 来唯一确定。 请求头：Headers 包含请求时所包含的头部信息，如 User-Agent、Host、Cookies 等信息。 请求体：请求时额外携带的数据，如在网页提交时需要提交表单信息 data。 Response 响应状态：有多种表示响应状态的状态码，如200表示成功，301表示跳转，404表示找不到页面，502表示服务器发生错误。（2XX成功，3XX重定向，4XX客户端错误，5XX服务器错误） 响应头：如内容类型、内容长度、服务器信息、设置 Cookies 等。 响应体：这是 Response 种最重要的部分，包含了请求资源的内容，如网页的 HTML、二进制信息图片视频等。 12345import requestshtml = requests.get("http://www.baidu.com") #一个普通的GET请求print(html.text) print(html.status_code) #返回结果状态码 如何处理所得数据呢？（网页、图片、视频等其他数据） 话不多少，直接处理二进制数据。 用 JSON 解析。 “只是用来写”的正则表达式。 BeautifulSoup，强大的 Python 第三方解析库。 PyQuery、XPath 等。 当然，有时候我们通过 HTTP 访问库访问网页的结果与浏览器加载后所看到的不一样，这就涉及到了JavaScript 的渲染问题。可以通过分析 Ajax 请求、Selenium/WebDriver、Splash、PyV8 和 Ghost.py 等来解决。 12345from selenium import webdriverdriver = webdriver.Chrome()driver.get('http://www.taobao.com') #可驱使Chrome浏览器去访问网页print(driver.page_source) 怎样保存数据呢？ 文本：纯文本、JSON、XML 等。 关系型数据库：如 MySQL、Oracle、SQL Server 等具有结构化表结构形式存储。 非关系型数据库：如 MongoDB、Redis 等 Key-Value 形式存储。 二进制文件：如图片、视频、音频等直接保存成特点格式即可。 END 基本概念就是这些了，HTTP 协议想了解得更清楚一些的话可以去看看图解 HTTP，另外用 Python 写爬虫需要安装一些第三方库，可使用 pip 方法下载，以后再补充好了。]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown使用教程]]></title>
    <url>%2F2017%2F10%2F30%2FMarkdown%2F</url>
    <content type="text"><![CDATA[Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。总之，Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 以上文字引用自 Markdown 语法说明(简体中文版) 显而易见，Markdown有以下优点： 它是纯文本发布的，所以兼容性很强，可以用所有的文本编辑器打开并编写。 它让你更专注于文字的内容而不是无谓的排版。 它的格式转换方便，你可以轻松的将 Markdown 的文本转换为 HTML、电子书等。 它的标记语法有极好的可读性。 那就来学学吧🤔 标题 一篇文章都是从标题开始的，为了得到如上所示的标题，我们需要在 Markdown 编译器里输入： 1## 标题 # 号之后记住要加上空格，## 两个井号代表这是一个二级标题。 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 现在看看其他标题的大小： 一级标题二级标题三级标题四级标题五级标题六级标题粗体和斜体 有时候我们想对文章的几个字或者一段话进行强调，那强调的一般方法就是加粗了。Markdown 的粗体和斜体的表示非常简单，用一对 ** 包含一段文字就是粗体的表示方法，用一对 * 包含一段文字就是斜体的表示方法。 1**看我是不是变粗啦** *看我是不是变斜啦* 看我是不是变粗啦 看我是不是变斜啦 列表 列表分为无序列表和有序列表。在 Markdown 下，只要在文字前加上 - 或 * 即可变为无序列表，在文字前加上 1. 2. 3. 即可变为有序列表。划重点：要在符号和文字之间加上一个空格。 1234567891011* 一* 二* 三- 一- 二- 三1. 一2. 二3. 三 一 二 三 一 二 三 一 二 三 也可以对列表进行嵌套： 12345* 第一部分 * 第一小节（一般嵌套是缩进是四个空格~） * 第一小小节 * 第二小小节 * 第二小节 第一部分 第一小节（一般嵌套是缩进是四个空格~） 第一小小节 第二小小节 第二小节 * 可用 + - 替代。 引用 文章中引用一段话也是很普遍的，就像本篇教程首段也引用了 Markdown 官方的宗旨。引用时，只需要在文字前加入 &gt; 大于号即可。 1&gt;你是我唯一想要的了解。——《七里香》 你是我唯一想要的了解。——《七里香》 插入链接和图片 美观富有哲思的文章里少不了图片和链接。使用 [链接名称](链接地址) 的格式插入链接，图片与链接大部分相同，只是多在前面加了一个 ! ,也就是使用 ![图片名称](图片地址) 的格式插入图片。 123[百度一下，你就知道](https://www.baidu.com/)![柚子](Markdown/favicon.ico) 百度一下，你就知道 描述图片位置的时候我使用了相对位置描述图片相对于我的这篇文章的位置。 分隔线 为了清晰划分文章的层次，可以使用分隔线。使用连续三个 *** 或 --- 启用分隔线。 123***--- 如上所示👆 代码 身为一个程序员，在描述命令行或者代码块时，都可以使用 Markdown 优雅的引用代码框。 当只是引用少量的只是一行的代码时，可以用一对反引号 ` 包围代码： 1`hexo server` hexo server 当引用数量较大的行数较多的代码时，可以用一对三个反引号 ` 包围代码块： 12def Hello(): print("Hello World!") 还可以直接将代码块缩进四个空格或一个制表符引入代码框（如果是在嵌套列表中进行缩进，是要缩进4×当前属于第几层嵌套，如果是第二层嵌套就应该是缩进八个空格，以此类推）： Hello World! 贴上部分编写源码。 这里在三引号那里写入 Python 是为了表示所插入代码是 Python 语言编写的，这样可以使渲染引擎在此代码块区域对代码进行更好的渲染。另外在使用三引号括起代码块或缩进引用代码框时，最好在代码块上下两行各空一行且三引号最好放在代码上下行，以防不可抗力因素。（单引号括起就不需要空行了，可直接内嵌在文字中。） PS：反引号是在英文模式下的 ~ 键打出来的。 并且在 Hexo Next 主题渲染后发现单引号括起的代码只是简单的灰底，三引号括起的代码是带有序号的黑底代码框，四空格缩进的代码是无序号的黑底代码框，也许 Markdown 最终的显示跟渲染引擎有很大的关系吧… 小贴士 Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\ 反斜线 ` 反引号 * 星号 _ 底线 &#123;&#125; 花括号 [] 方括号 () 括弧 # 井字号 + 加号- 减号. 英文句点! 惊叹号 类似 C 语言的转义字符，满足 \特殊字符 的格式即可引用在文中了。 在写一篇文章时，我们往往想要在首行空两个空格，这时可以在段首加入 &amp;emsp; &amp;emsp; 来输入两个空格。 添加空行是可以结束先前的格式状态的，所以在想要改变格式，如插入列表或者引入代码框时，最好都添加一个空行。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub+Mac安装教程]]></title>
    <url>%2F2017%2F10%2F30%2FHexo%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[其实这个博客用了半天就搭好了。但是在主题和个人偏好设置方面真的是很痛苦，不断钻研最后才弄得算是拿得起台面了一些，现在分享一下我的经验。 首先，什么是 Hexo？什么是静态博客呢？ Hexo出自台湾大学生 tommy351 之手，是一个基于 Node.js 的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到 GitHub Pages，BAE，SAE 等平台上。 而静态博客相较于动态博客，它编译之后是纯 HTML 页面，支持它的环境十分好找，如 GitHub Pages；而选择在 VPS 上面搭建动态博客，这些 VPS 供应商往往是：“免费的不稳定，稳定的不免费”。那么，可以利用免费的资源搭载属于自己的稳定的个人博客，不是很爽吗？ 步骤 安装 Git 其实 mac 上只要安装了 Xcode 也就默认安装了 git，这里就直接推荐各位去 AppStore 下载 Xcode 了，顺便配置一下即可 👉 Xcode:在 Mac App Store 上的内容 另外推荐一下廖大的教程：廖雪峰git教程 安装 Node.js 使用 brew 安装 Node.js，安装 brew 之前要先安装命令行工具，如果安装了 Xcode 也就不需要安装了，所以建议还是先直接安装 Xcode 吧…安装完 Xcode 之后按组合键：command + 空格 打开 Spotlight 搜索，输入终端打开终端。 安装 Homebrew（终端粘贴如下代码即可）。 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装完brew后，终端输入 brew install node 安装 Node.js 即可。 安装 Hexo 同理，在终端一行一行输入如下命令： 123456sudo npm install -g hexo #下载安装Hexo。mkdir blog #在当前位置新建blog文件夹。cd blog #切换到blog目录。hexo init #初始化。hexo generate #生成静态文件。hexo server #启动本地服务，进行文章预览调试。 本地调试 现在打开 http://localhost:4000 就能看到默认的 Hexo 界面了。 但是，这还不够，因为你想展示你的博客给所有人看，所以你还要将你的页面托管起来。 注册 GitHub 账号与配置 SSH 参考教程 利用SSH建立远程链接 配置GitHub 建立 Repository，建立与你用户名对应的仓库，仓库名必须为 [your-name.github.io]，这是固定写法。 Spotlight 搜索我们之前创建的 blog 文件夹，里面有 _config.yml 文件，打开找到 deploy 字段，修改为： 1234deploy: type: git repo: https://github.com/your-name/your-name.github.io.git branch: master 保存以上修改后在终端输入：npm install hexo-deployer-git --save 成功后再执行命令：hexo deploy 然后在浏览器中输入 http://your-name.github.io/ 会发现你的博客可以通过这个网址打开了。 PS：记得把 your-name 改成你的 github 的账户名。 博客 博客部署 以后部署到GitHub Pages的步骤，可在终端按以下三步来进行。 123hexo clean #清除缓存文件 (db.json) 和已生成的静态文件 (public)。 hexo generate #生成静态页面至public目录。hexo deploy #将生成的目录部署到GitHub上。 当想在本地调试时，可以在终端切换到blog文件夹，使用hexo server命令启动服务器。默认情况下，访问网址为： http://localhost:4000/。即可预览产生的博客界面。 常用命令👇： 1234hexo new &quot;postname&quot; #新建文章hexo new page &quot;pagename&quot; #新建页面hexo help #查看帮助hexo version #查看Hexo的版本 博客主题 配置好博客后也许你会觉得你的博客界面并不靓丽，这就需要强大的主题了，可在以下三个链接中了解一下主题。 知乎：Hexo有哪些好看的主题？ 主题 | Hexo 还有我现在用的主题 NexT | Pisces 主题配置 每个主题都是有文档对其进行详细的描述的，这里不细说，发掘配置也是搭建这个博客的乐趣所在哈。 后记 搭好并配置完这个博客的时候还是很开心的，像是将之前学的 git、HTML 和命令行知识进行了融会贯通一般。小宝很可爱，JavaScript 很有趣，Holen 学长很 cool，前路漫漫，继续向前看吧。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>Tips</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS常用命令]]></title>
    <url>%2F2017%2F10%2F30%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[先来讲讲 macO S和 Unix 还有 Linux 的关系 Unix 最早是在贝尔实验室开发的，是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统。为主要的工作站平台和重要的企业操作平台。它主要安装在巨型计算机、大型机上作为网络操作系统使用，也可用于个人计算机和嵌入式系统。曾经是服务器操作系统的首选。 Linux 是一类类 Unix 计算机操作系统的统称。Linux 操作系统的内核的名字也是 “Linux”。Linux 操作系统也是自由软件和开放源代码发展中最著名的例子。严格来讲，Linux 这个词本身只表示 Linux 内核，但在实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统。Linux 得名于计算机业余爱好者 Linus Torvalds。一般可以认为，Linux 是一套自由使用（一般可以免费使用）和自由传播的类 Unix 操作系统。这个系统是由世界各地成千上万的程序员设计和实现的。其目的是建立不受任何商品化软件的版权制约、全世界都能自由使用的 Unix 兼容产品。实际上，Linux 仅仅的 Linux 操作系统中的核心（kernel）。 Mac 系统是苹果机专用系统，是基于 Unix 内核的图形化操作系统，一般情况下在普通 PC 上无法安装的操作系统。 所以说 Linux 是兼容 Unix 的，或者说是 Linus 写的一种开源的类 Unix系统，而 macOS 的内核其实就是 Unix。所以在同一种 shell 环境下，macOS 和 Linux 的许多命令是共通的，这里所说的 macOS 常用命令其实就是兼容大部分 Linux 系统的终端命令。 两种路径：绝对路径和相对路径 再来说说比较重要的路径 绝对路径：完整描述一个文件的位置，总是以斜杠 /（forward slash）开头。例如 /Users/michelle/Public/Drop Box。相对路径：只描述一部分位置信息，它和你在 command line 目前的目录有关。当你打开新的 Terminal 程序时，command line 会话的目录应该是你的 home folder。这时上面例子文件夹的相对路径写作Public/Drop Box。显然它从当前目录开始。和 HTML 类似，你也可以使用两个点.. 来代表父目录，这样你就可以用相对路径表示上级或同级目录了。例如你可以输入 cd .. 甚至 cd ../.. 来返回上级目录。 常用命令💻 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364ls (list directory contents) 列出当前目录的内容ls -l 列出当前目录文件详细信息l(list)ls -a 列出当前目录下所有文件及目录，包括隐藏的文件和目录 (a=all)mkdir 创建目录mkdir -p 创建目录，若无父目录，则创建 p(parent) rmdir 删除目录 (rmdir dir)cd (change directory) 改变当前目录到指定目录 (cd .. 返回上一目录)touch 创建空文件，可 touch test.txt 或者 touch 文件夹名/test.txt (在指定文件夹创建空文件)echo 创建带有内容的文件cat 查看文件内容cp 复制文件或目录 (cp file1 file2)cp -r 复制目录内所有内容mv 改变文件名或移动其所在目录 (mv file1 file2)mv -r 移动目录到另一目录 (mv dir1 dir2) rm 删除文件rm -r 递归删除，可删除子目录及文件rm -f 强制删除rm -rf 删除文件夹 pwd (print working directory) 显示当前目录的绝对路径vim 创建并编辑文件 (先按i插入文字，完成后按esc再按：wq保存并退出) (esc :q! 放弃修改编辑内容直接退出)control+d 退出 Python3vim test.c 编写 C 文件gcc test.c 编译 C 文件./a.out 运行 C 文件control+C 中止一个错误的或者发疯的命令control+L 清屏Mac 下常见 vim 的命令： 1. 在默认的&quot;指令模式&quot;下按 i 进入编辑模式 2. 在非指令模式下按 ESC 返回指令模式 3. 在&quot;指令模式&quot;下输入: :w 保存当前文件 :q 退出编辑,如果文件为保存需要用强制模式 :q! 强制退出不保存修改 :wq 组合指令, 保存并退出 4. 在“指令模式”下移动: h 左 j 下 k 上 l 右 shutdown -r 关机重启 -h 关机不重启 now 立刻关机halt 关机reboot 重启find 在文件系统中搜索某文件wc 统计文本中行数、字数、字符数grep 在文本文件中查找某个字符串tree 树形结构显示目录，需要安装 tree 包ln 创建链接文件more、less 分页显示文本文件内容head、tail 显示文件头、尾内容ctrl+alt+F1 命令行全屏模式 偶然看到这个博客，顺便贴上：Mac OS X Terminal 101：终端使用初级教程 未完待续。]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Disneyland 游玩攻略✨]]></title>
    <url>%2F2017%2F10%2F25%2FDisneyland%2F</url>
    <content type="text"><![CDATA[我想和你去，梦的城堡。 简述🦄 上海迪士尼乐园目前共分六个主题园区，分别是：以米奇和他的欢乐伙伴们为主题设计的迎宾大道 — 米奇大街；展现自然奇妙又充满想象力的花园设计主题区 — 奇想花园；完美呈现迪士尼电影世界之 — 梦幻世界；探寻神秘远古部落的冒险乐园 — 探险岛；惊险热闹的海盗世界 — 宝藏湾；科技打造的未来感满满的酷炫天地 — 明日世界。（在建的第七个主题园区 — 玩具总动园 将于2018年开放)除了遍布商店和餐馆的米奇大道外，每个园区都设置了与其主题相对应的游乐项目，各具特色，充满无穷的想象力和无尽的乐趣。除了亲身体验的游乐项目，各园区还有精心安排的表演秀，为你带来一场场视听盛宴。此外，各园区都有一些迪士尼经典人物形象出没，有专门的“与迪士尼朋友见面”环节，看到自己喜欢的卡通形象一定要记得合影留念哦。 步骤🎃 1 门票：抽奖得到了一张并低价向另一名中奖者买。 2 时间：工作日九点开园，节假日八点开园，最好提前40分钟，所以应该要7.20到。 3 物品：身份证，现金（要有硬币），雨伞（遮阳挡雨），充电宝，数据线，充电器，洗漱用品，舒服的鞋子，帽子，水杯，未开封的零食，雨衣（如果想玩雷鸣山漂流的话）。 4 网页：迪士尼官网 5 APP: 导航软件(百度地图等)，迪士尼度假区 app，乐拍通 app（找准位置，安排行程很重要）。 6 交通：迪士尼乐园在上海地铁11号线的终点站，交通方便。 7 酒店：迪士尼附近的酒店都很贵，其实找个地铁11号线沿线附近的酒店就可以了。 PS：开封后的饮料、牛奶和自拍杆都不能带入院内。 正篇☀️ 入园后，记得拿好门票、乐园指南和时间表。门票用来取 FP 卡（快速通道卡），乐园指南里面有详细的地图和项目介绍，时间表用来查看各个演出的时间。左边右边米奇大道都不要停留，也不要被一进门被光鲜的玩具们拖慢了脚步。立刻飞奔向明日世界附近的游客中心领取创极速光轮的快速通行证才是最重要的！ 🌟一定要领 FP！领 FP！领 FP！重要的事说三遍！ （当然如果人特别多的话就直接跑去排队，因为这时候排队拿卡一般只能排到下午的时间。） FP 卡在各区域的快速卡领取点领取，领取点可以在入园指南的地图里找。若有什么不懂的，可以直接问机器附近的工作人员。 FP 是高效玩转迪士尼的制胜法宝，一些热门景点经常要排队三四个小时，但是领了 FP 后，就可以在它指定的时间范围内直接去玩，不用排队。 由于一张门票一次只能领一张 FP，一张 FP 只能作用于一个景点，所以建议不要浪费，还是用在创极速光轮或者飞跃地平线这种排队排到天荒地老的大项目上。预约过FP后就要再过两个小时后才能预约下一个项目，这个时候如果想要预约第二个项目，就要看看有没有运气了。因为 FP 每天是有数量限制的，派完为止，一般中午后就领不到了。 News：9月7日上海迪士尼度假区发布，将在今年秋季推出电子版快速通行证，只需下载官方 app，走过入园闸机后使用 app 扫描关联门票或季卡，即可领取电子版快速通行证，无需再往来于游客服务中心。两次领取间隔为2小时，或前一张快速通行证已使用后才能领取第二张，先到先得，发完为止。游客将能以更高效、灵活的方式享受迪士尼快速通行证服务，且无需额外付费。届时，游客可以通过上海迪士尼度假区官方手机应用程序（app）获取电子版迪士尼快速通行证，而无需匆忙地来往于指定的游客服务中心领取。游客在入园后，可把已激活的乐园门票与手机应用程序关联，按照提示进行浏览、选择及预约迪士尼快速通行证，并可随时查看快速通行证的使用时间。使用时，游客在选定景点的快速通行证入口扫描他们的手机或乐园门票上的二维码，在快速通行证以及与乐园门票相关联的游客照片验证成功后，游客便可快捷地体验景点。 划重点⚡️ FP 不用再去游客中心排队领取了，也就是说进园后不必再不顾一切地向右跑了！ 迪士尼快速通行证每日限量发行，不可转让。两次领取间隔为2小时，或前一张快速通行证已使用后才能领取第二张，先到先得，发完为止。也就是说使用你的 FP 在验票时一定要用关联本人的门票，其次，虽然不用再往右跑了，但激活门票后也要在 app 上拼手速抢热门项目的 FP 啊！而且要密切关注下一次领 FP 的时间。 FP变成了电子版，也就是说你不会再手持一张纸质版的快速通行证进行验票了，所有的 FP 都与你的门票相关联，走FP通道验票验的也是你的门票。 游客中心领 FP 的传统方法没有被废，如果你想，还是可以去那里领，在自助机器上扫描门票，电子版 FP 就被关联上了。 1234567FP能用的7个项目： 明日世界：创极速光轮⭐️、巴斯光年星际营救 探险岛：飞跃地平线⭐️、雷鸣山漂流 梦幻世界：小飞侠天空奇遇、七个小矮人矿山车、小熊维尼历险记 单人通道（人太多时可选择）： 创极速光轮、雷鸣山漂流、 加勒比海盗-沉落宝藏之战、七个小矮人矿山车 未完待续。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>Disneyland</tag>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
</search>
