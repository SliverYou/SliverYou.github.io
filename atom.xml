<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青柚。</title>
  
  <subtitle>爱在阳光指缝间。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-14T15:54:58.968Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>青柚。</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python3爬虫相关库笔记</title>
    <link href="http://yoursite.com/2017/12/14/Python3%E7%88%AC%E8%99%AB%E7%9B%B8%E5%85%B3%E5%BA%93%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/12/14/Python3爬虫相关库笔记/</id>
    <published>2017-12-14T13:43:54.000Z</published>
    <updated>2017-12-14T15:54:58.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><hr><p>有时候一个爬虫程序，可能只有几行代码，但是它涉及到的知识面却很广，这里先记下一些相关知识，以此共勉。</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>什么是 JSON ？<br>JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）</p><ul><li>JSON 是轻量级的文本数据交换格式</li><li>JSON 独立于语言 </li><li>JSON 具有自我描述性，更易理解</li><li>JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。</li></ul><p>JSON 有什么优点？</p><ul><li>方便于传输，较少冗余的字符。当然直接传二进制是最好的，但面临难解析的问题。亦可以是 XML、纯字符串的方式，但 JSON 有其独到的好处。Google 有个自己的协议，叫 Protobuf，有兴趣可了解一下。</li><li>方便转换。有很多的 JSON API 提供了 JSON 字符串转成对象、对象转换成json串的方法。</li><li>易于阅读。JSON代码的良好结构，可以很直观地了解存的是什么内容。</li><li>简而言之，JSON就是比XML的基础上，去掉了标签，这样也就节省了大量的存储空间。</li></ul><p><strong>Python中的JSON模块</strong></p><p>json 模块提供了一种很简单的方式来编码和解码JSON数据。其中两个主要的函数是 json.dumps() 和 json.loads()，要比其他序列化函数库如pickle的接口少得多。下面演示如何将一个Python数据结构转换为JSON：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line">data = &#123;</div><div class="line">    <span class="string">'name'</span> : <span class="string">'ACME'</span>,</div><div class="line">    <span class="string">'shares'</span> : <span class="number">100</span>,</div><div class="line">    <span class="string">'price'</span> : <span class="number">542.23</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">json_str = json.dumps(data)</div><div class="line">print(json_str)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#返回结果</span></div><div class="line">&#123;<span class="string">"name"</span>: <span class="string">"ACME"</span>, <span class="string">"shares"</span>: <span class="number">100</span>, <span class="string">"price"</span>: <span class="number">542.23</span>&#125;</div></pre></td></tr></table></figure><p>下面演示如何将一个JSON编码的字符串转换回一个Python数据结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>data = json.loads(json_str)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(data)</div><div class="line">&#123;<span class="string">'name'</span>: <span class="string">'ACME'</span>, <span class="string">'shares'</span>: <span class="number">100</span>, <span class="string">'price'</span>: <span class="number">542.23</span>&#125;</div></pre></td></tr></table></figure><p>如果要处理的是文件而不是字符串，可以使用 json.dump() 和 json.load() 来编码和解码JSON数据。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Writing JSON data</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">'data.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</div><div class="line">    json.dump(data, f)</div><div class="line"></div><div class="line"><span class="comment"># Reading data back</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">'data.json'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">    data = json.load(f)</div></pre></td></tr></table></figure><p>JSON编码支持的基本数据类型为 None ，bool ，int ，float 和 str ，以及包含这些类型数据的lists，tuples和dictionaries。 对于dictionaries，keys需要是字符串类型(字典中任何非字符串类型的key在编码时会先转换为字符串)。为了遵循JSON规范，你应该只编码Python的lists和dictionaries。而且，在web应用程序中，顶层对象被编码为一个字典是一个标准做法。</p><p>JSON编码的格式对于Python语法而已几乎是完全一样的，除了一些小的差异之外。比如，True会被映射为true，False被映射为false，而None会被映射为null。下面是一个例子，演示了编码后的字符串效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(<span class="keyword">False</span>)</div><div class="line"><span class="string">'false'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'a'</span>: <span class="keyword">True</span>,</div><div class="line"><span class="meta">... </span>    <span class="string">'b'</span>: <span class="string">'Hello'</span>,</div><div class="line"><span class="meta">... </span>    <span class="string">'c'</span>: <span class="keyword">None</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(d)</div><div class="line"><span class="string">'&#123;"b": "Hello", "c": null, "a": true&#125;'</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure><p><strong>总结</strong></p><p><strong>JSON字符串转为字典</strong></p><p>json.load / json.loads<br>两个方法功能类似，可选参数也相同，最大的区别在于，json.load 方法接受的输入，即第一个参数，是包含 JSON 数据的文件对象，如open方法的返回对象。<br>json.loads 接受的输入是 JSON 字符串，而非文件对象。从输入类型的区别也可以看出两者的使用场合。<br>可选参数包括是否需要转换整型、浮点型等数值的参数，还有一些复杂的功能，暂时没有用到，以后有机会再了解。</p><p><strong>字典转换为JSON</strong></p><p>json.dump / json.dumps<br>对应于 load 和 loads，dump 的第一个参数是对象字典，第二个参数是文件对象，可以直接将转换后的 JSON 数据写入文件，dumps的第一个参数是对象字典，其余都是可选参数。dump 和 dumps 的可选参数相同，这些参数都相当实用，现将用到的参数记录如下：</p><ul><li>ensure_ascii 默认为 True，保证转换后的 JSON 字符串中全部是 ascii 字符，非 ascii 字符都会被转义。如果数据中存在中文或其他非 ascii 字符，最好将 ensure_ascii 设置为 False，保证输出结果正常。  </li><li>indent 缩进，默认为 None ，没有缩进，设置为正整数时，输出的格式将按照 indent 指定的半角空格数缩进，相当实用。  </li><li>separators 设置分隔符，默认的分隔符是(‘,’, ‘: ‘)，如果需要自定义 JSON 中的分隔符，例如调整冒号前后的空格数，可以按照(item_separator, key_separator)的形式设置。  </li><li>sort_keys 默认为 False，设为 True 时，输出结果将按照字典中的 key 排序。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 举例</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(data, indent=<span class="number">4</span>))</div><div class="line">&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"ACME"</span>,</div><div class="line">    <span class="string">"shares"</span>: <span class="number">100</span>,</div><div class="line">    <span class="string">"price"</span>: <span class="number">542.23</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Demjson"><a href="#Demjson" class="headerlink" title="Demjson"></a>Demjson</h3><p>Demjson 是 python 的第三方模块库，可用于编码和解码 JSON 数据，包含了 JSONLint 的格式化及校验功能。安装命令很简单，一个命令就可以搞定了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip3 install demjson</div></pre></td></tr></table></figure><p>现在来使用一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> demjson</div><div class="line"></div><div class="line">data = &#123;</div><div class="line">    <span class="string">'name'</span> : <span class="string">'ACME'</span>,</div><div class="line">    <span class="string">'shares'</span> : <span class="number">100</span>,</div><div class="line">    <span class="string">'price'</span> : <span class="number">542.23</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">json_str = demjson.encode(data) <span class="comment"># 转换为JSON字符串</span></div><div class="line">print(json_str)</div><div class="line">text = demjson.decode(json_str) <span class="comment"># 转换为字典</span></div><div class="line">print(text)</div><div class="line"></div><div class="line">&gt;&gt;&gt;&#123;<span class="string">"name"</span>:<span class="string">"ACME"</span>,<span class="string">"price"</span>:<span class="number">542.23</span>,<span class="string">"shares"</span>:<span class="number">100</span>&#125;</div><div class="line">&gt;&gt;&gt;&#123;<span class="string">'name'</span>: <span class="string">'ACME'</span>, <span class="string">'price'</span>: <span class="number">542.23</span>, <span class="string">'shares'</span>: <span class="number">100</span>&#125;</div></pre></td></tr></table></figure><h3 id="Hashlib"><a href="#Hashlib" class="headerlink" title="Hashlib"></a>Hashlib</h3><p>hashlib 是一个提供了一些流行的hash算法的 Python 标准库，其中所包括的算法有 md5，sha1，sha224，sha256，sha384，sha512。另外，模块中所定义的 new(name, string=”) 方法可通过指定系统所支持的hash算法来构造相应的hash对象。<br>Python3 中 hashlib 模块代替了 Python2 中的 md5 和 sham 模块，使用这个模块一般分为3步：</p><ul><li>创建一个哈希对象，使用哈希算法命名的构造函数或通用构造函数来创建。</li><li>使用哈希对象调用 update() 方法填充这个对象。</li><li>调用 digest() 或 hexdigest() 方法来获取摘要（加密结果）。</li></ul><p><strong>md5加密：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># md5加密</span></div><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"></div><div class="line">hash = hashlib.md5()</div><div class="line">hash.update(<span class="string">'sliver'</span>.encode(<span class="string">'utf-8'</span>))</div><div class="line">print(hash.hexdigest())</div><div class="line"></div><div class="line">&gt;&gt;&gt;<span class="number">241</span>f166bdf9887f732ae06ba859da376</div></pre></td></tr></table></figure><p><strong>也可以这样实现md5加密：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"></div><div class="line">hash1 = hashlib.md5(<span class="string">b'sliver'</span>)</div><div class="line">print(hash1.hexdigest())</div><div class="line"></div><div class="line">hash2 = hashlib.md5(<span class="string">'sliver'</span>.encode(<span class="string">'utf-8'</span>))</div><div class="line">print(hash2.hexdigest())</div><div class="line"></div><div class="line"><span class="comment"># 也就是加密前必须先指定编码</span></div><div class="line"></div><div class="line">&gt;&gt;&gt;<span class="number">241</span>f166bdf9887f732ae06ba859da376</div><div class="line">&gt;&gt;&gt;<span class="number">241</span>f166bdf9887f732ae06ba859da376</div></pre></td></tr></table></figure><p><strong>sha1加密：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sha1加密</span></div><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"></div><div class="line">hash = hashlib.sha1()</div><div class="line">hash.update(<span class="string">'sliver'</span>.encode(<span class="string">'utf-8'</span>))</div><div class="line">print(hash.hexdigest())</div><div class="line"></div><div class="line">&gt;&gt;&gt;e7896b82b9fcccbba18d905c0e374c4e8d612b08</div></pre></td></tr></table></figure><p><strong>sha256加密：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sha256加密</span></div><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"></div><div class="line">hash = hashlib.sha256()</div><div class="line">hash.update(<span class="string">'sliver'</span>.encode(<span class="string">'utf-8'</span>))</div><div class="line">print(hash.hexdigest())</div><div class="line"></div><div class="line">&gt;&gt;&gt;<span class="number">66</span>cb86b497f2b457cc6a19fafda4952bfbd831ed9c2d7ba12157ef269ecf3885</div></pre></td></tr></table></figure><p><strong>sha512加密：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sha512加密</span></div><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"></div><div class="line">hash = hashlib.sha512()</div><div class="line">hash.update(<span class="string">'sliver'</span>.encode(<span class="string">'utf-8'</span>))</div><div class="line">print(hash.hexdigest())</div><div class="line"></div><div class="line">&gt;&gt;&gt;f3e8498d2d0b2a91cc29e085ca22c4ca27345633b023ba8ec83430784ee715a9bb5a27e758ce04eb7b653c079e7264753fc313d7eb5df352e43e34c324d88bf0</div></pre></td></tr></table></figure><p><strong>“加盐”加密：</strong></p><p>以上的算法确实是密码学大佬们的结晶，但比如sha1算法还是可以通过暴力破解被破解出来的，这时候，自己自定义加上key，俗称“加盐”，能让加密算法更加安全。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># “加盐”加密</span></div><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"></div><div class="line">hash = hashlib.md5(<span class="string">'ariel'</span>.encode(<span class="string">'utf-8'</span>))</div><div class="line">hash.update(<span class="string">'sliver'</span>.encode(<span class="string">'utf-8'</span>))</div><div class="line">print(hash.hexdigest())</div><div class="line"></div><div class="line">&gt;&gt;&gt;<span class="number">077</span>ee0a6276e80b65a42de44a27b9f08</div></pre></td></tr></table></figure><h3 id="Python-中的函数"><a href="#Python-中的函数" class="headerlink" title="Python 中的函数"></a>Python 中的函数</h3><p><strong>eval(str)</strong></p><p>eval(str)函数很强大，它是Python用于执行字符串内的表达式的一个内置函数，使用eval，可以很方便的将字符串动态执行。</p><p>eval()函数常见作用有： </p><p>1、计算字符串中有效的表达式，并返回结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">'pow(2,2)'</span>)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">'2 + 2'</span>)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">"4 * 4"</span>)</div><div class="line"><span class="number">16</span></div></pre></td></tr></table></figure><p>2、将字符串转成相应的 python 对象（如 list、tuple、dict 和 string 之间的转换）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"[[1,2], [3,4], [5,6], [7,8], [9,0]]"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = eval(a)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b</div><div class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">0</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"&#123;1:'xx',2:'yy'&#125;"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = eval(a)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c</div><div class="line">&#123;<span class="number">1</span>: <span class="string">'xx'</span>, <span class="number">2</span>: <span class="string">'yy'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"(1,2,3,4)"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = eval(a)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div></pre></td></tr></table></figure><p>3、将利用反引号转换的字符串再反转回对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>`list1`</div><div class="line"><span class="string">'[1, 2, 3, 4, 5]'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(`list1`)</div><div class="line">&lt;type <span class="string">'str'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(eval(`list1`))</div><div class="line">&lt;type <span class="string">'list'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = eval(`list1`)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div></pre></td></tr></table></figure><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>先写这么多吧，未完待续。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;有时候一个爬虫程序，可能只有几行代码，但是它涉及到的知识面却很广，这里先记下一些相关知识，以此共勉。&lt;/p&gt;
&lt;h3 id=&quot;JS
      
    
    </summary>
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python3爬虫之urllib模块的使用</title>
    <link href="http://yoursite.com/2017/12/07/Python3%E7%88%AC%E8%99%AB%E4%B9%8Burllib%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/12/07/Python3爬虫之urllib模块的使用/</id>
    <published>2017-12-07T14:15:58.000Z</published>
    <updated>2017-12-07T15:34:00.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><hr><p>今天来说说python3内置的一个HTTP请求库，urllib。<br>官方文档：<a href="https://docs.python.org/3/library/urllib.html" target="_blank" rel="external">urllib — URL handling modules</a>  </p><p>urllib中包括了四个模块，包括了：urllib.request，urllib.error，urllib.parse，urllib.robotparser</p><ul><li>urllib.request (请求模块)：可以用来发送request和获取request的结果</li><li>urllib.error (异常处理模块)：包含了urllib.request产生的异常</li><li>urllib.parse (URL解析模块)：用来解析和处理URL</li><li>urllib.robotparse (robots.txt解析模块)：用来解析页面的robots.txt文件</li></ul><p>显而易见，urllib.request库和urllib.error库是在一次模拟请求中比较重要的库。</p><h3 id="使用urllib-request发送请求"><a href="#使用urllib-request发送请求" class="headerlink" title="使用urllib.request发送请求"></a>使用urllib.request发送请求</h3><hr><p><strong>简单urllib.request.urlopen()使用方法</strong></p><p>urllib.request模块提供了最基本的构造HTTP请求的方法，利用它可以模拟浏览器的一个请求发起过程，同时它还带有处理<code>authenticaton(授权验证)，redirections(重定向)，cookies(浏览器Cookies)</code>以及其它内容。<br>首先，先试着抓取一下百度的页面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request  </div><div class="line">  </div><div class="line">response = urllib.request.urlopen(<span class="string">"http://www.baidu.com"</span>)  </div><div class="line">print(response.read().decode(<span class="string">"utf-8"</span>))</div></pre></td></tr></table></figure><p>真正的代码其实只有两行，我们便完成了对百度首页的抓取，并输出了它的网页源代码。在爬虫程序中，得到了网页源代码之后，你所需要的链接、图片、视频、文本信息等就可以在网页源代码中查找并提取出来。<br>现在尝试利用type函数输出response的类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request  </div><div class="line"></div><div class="line">response = urllib.request.urlopen(<span class="string">"http://www.baidu.com"</span>)  </div><div class="line">print(type(response))</div></pre></td></tr></table></figure><p>输出结果为：<code>&lt;class &#39;http.client.HTTPResponse&#39;&gt;</code><br>通过输出结果可以发现它是一个<strong>http.client.HTTPResponse</strong>类型的对象，它主要包含的方法有<code>read()、readinto()、getheader(key)、getheaders()、fileno()</code>等函数和<code>msg、version、status、reason、debuglevel、closed</code>等属性。得到这个对象之后，将其赋值给response，就可以用response调用这些方法和属性，以此得到返回结果和信息。如response.read().decode(“utf-8”)可以得到返回后的利用utf-8编码的网页内容，response.status可以得到响应返回结果的状态码。<br>下面再来一个实例感受一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import urllib.request</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; response = urllib.request.urlopen(&quot;http://www.baidu.com&quot;)</div><div class="line">&gt;&gt;&gt; print(response.status)</div><div class="line">200</div><div class="line">&gt;&gt;&gt; print(response.getheaders())</div><div class="line">[(&apos;Date&apos;, &apos;Thu, 07 Dec 2017 14:37:26 GMT&apos;), (&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;), (&apos;Transfer-Encoding&apos;, &apos;chunked&apos;), (&apos;Connection&apos;, &apos;Close&apos;), (&apos;Vary&apos;, &apos;Accept-Encoding&apos;), (&apos;Set-Cookie&apos;, &apos;BAIDUID=3D72FEFAEEE60FAB2F79886A59FAC02D:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com&apos;), (&apos;Set-Cookie&apos;, &apos;BIDUPSID=3D72FEFAEEE60FAB2F79886A59FAC02D; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com&apos;), (&apos;Set-Cookie&apos;, &apos;PSTM=1512657446; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com&apos;), (&apos;Set-Cookie&apos;, &apos;BDSVRTM=0; path=/&apos;), (&apos;Set-Cookie&apos;, &apos;BD_HOME=0; path=/&apos;), (&apos;Set-Cookie&apos;, &apos;H_PS_PSSID=25263_1467_21122_25178_20718; path=/; domain=.baidu.com&apos;), (&apos;P3P&apos;, &apos;CP=&quot; OTI DSP COR IVA OUR IND COM &quot;&apos;), (&apos;Cache-Control&apos;, &apos;private&apos;), (&apos;Cxy_all&apos;, &apos;baidu+90b96fddd3e4cc794d4573d45036518c&apos;), (&apos;Expires&apos;, &apos;Thu, 07 Dec 2017 14:36:39 GMT&apos;), (&apos;X-Powered-By&apos;, &apos;HPHP&apos;), (&apos;Server&apos;, &apos;BWS/1.1&apos;), (&apos;X-UA-Compatible&apos;, &apos;IE=Edge,chrome=1&apos;), (&apos;BDPAGETYPE&apos;, &apos;1&apos;), (&apos;BDQID&apos;, &apos;0xe4820d9700009820&apos;), (&apos;BDUSERID&apos;, &apos;0&apos;)]</div><div class="line">&gt;&gt;&gt; print(response.getheader(&quot;Server&quot;))</div><div class="line">BWS/1.1</div></pre></td></tr></table></figure><p>可见，三个输出分别输出了响应的状态码，响应的头信息，以及通过传递一个参数来获取对应的头信息。</p><p><strong>高级urllib.request.urlopen()使用方法</strong></p><p>利用urlopen()方法，我们可以实现对一般网页的GET请求。<br>如果我们想给链接传递一些参数该怎么实现呢？我们首先看一下urlopen()函数的API。</p><p><code>urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)</code></p><p>可以发现除了第一个参数可以传递URL之外，我们还可以传递其它的内容，比如data(附加参数)，timeout(超时时间)等等。<br>data参数是可选的，如果要添加data，它要求是字节流编码格式的内容，即bytes类型，通过bytes()函数可以进行转化，另外如果你传递了这个data参数，它的请求方式就不再是GET方式请求，而是POST。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.parse  </div><div class="line"><span class="keyword">import</span> urllib.request  </div><div class="line">data = bytes(urllib.parse.urlencode(&#123;<span class="string">'word'</span>: <span class="string">'hello'</span>&#125;), encoding=<span class="string">'utf-8'</span>)  </div><div class="line">response = urllib.request.urlopen(<span class="string">'http://httpbin.org/post'</span>, data=data)  </div><div class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</div><div class="line"><span class="comment">#read获取的是bytes型的数据，decode可按特定编码方式编码(相当于获取响应体)。</span></div></pre></td></tr></table></figure><p>在这里我们传递了一个参数word，值是hello。它需要被转码成bytes(字节流)类型。其中转字节流采用了bytes()方法，第一个参数需要是str(字符串)类型，需要用urllib.parse.urlencode()方法来将参数字典转化为字符串。第二个参数指定编码格式，在这里指定为utf-8。<br>提交的网址是<a href="httpbin.org">httpbin.org</a>，它可以提供HTTP请求测试。<a href="http://httpbin.org/post" target="_blank" rel="external">http://httpbin.org/post</a>这个地址可以用来测试POST请求，它可以输出请求和响应信息，其中就包含我们传递的data参数。<br>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;args&quot;: &#123;&#125;,</div><div class="line">  &quot;data&quot;: &quot;&quot;,</div><div class="line">  &quot;files&quot;: &#123;&#125;,</div><div class="line">  &quot;form&quot;: &#123;</div><div class="line">    &quot;word&quot;: &quot;hello&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;headers&quot;: &#123;</div><div class="line">    &quot;Accept-Encoding&quot;: &quot;identity&quot;,</div><div class="line">    &quot;Connection&quot;: &quot;close&quot;,</div><div class="line">    &quot;Content-Length&quot;: &quot;10&quot;,</div><div class="line">    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,</div><div class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;,</div><div class="line">    &quot;User-Agent&quot;: &quot;Python-urllib/3.6&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;json&quot;: null,</div><div class="line">  &quot;origin&quot;: &quot;112.10.180.190&quot;,</div><div class="line">  &quot;url&quot;: &quot;http://httpbin.org/post&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们传递的参数出现在了form中，这表明我们的python语句模拟了表单提交的方法，并以POST方式传输数据。</p><p><strong>timeout参数</strong></p><p>timeout参数可以设置超时时间，单位为秒，意思就是如果请求超出了设置的这个时间还没有得到响应，就会抛出异常，如果不指定，就会使用全局默认时间。它支持HTTP、HTTPS、FTP请求。<br>下面来用一个实例感受一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request  </div><div class="line">response = urllib.request.urlopen(<span class="string">"http://httpbin.org/get"</span>,timeout=<span class="number">0.1</span>)  </div><div class="line">print(response.read())</div></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">During handling of the above exception, another exception occurred:</div><div class="line"></div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;/Users/sliver/anaconda3/lib/python3.6/urllib/request.py&quot;, line 223, in urlopen</div><div class="line">    return opener.open(url, data, timeout)</div><div class="line">  File &quot;/Users/sliver/anaconda3/lib/python3.6/urllib/request.py&quot;, line 526, in open</div><div class="line">    response = self._open(req, data)</div><div class="line">  File &quot;/Users/sliver/anaconda3/lib/python3.6/urllib/request.py&quot;, line 544, in _open</div><div class="line">    &apos;_open&apos;, req)</div><div class="line">  File &quot;/Users/sliver/anaconda3/lib/python3.6/urllib/request.py&quot;, line 504, in _call_chain</div><div class="line">    result = func(*args)</div><div class="line">  File &quot;/Users/sliver/anaconda3/lib/python3.6/urllib/request.py&quot;, line 1346, in http_open</div><div class="line">    return self.do_open(http.client.HTTPConnection, req)</div><div class="line">  File &quot;/Users/sliver/anaconda3/lib/python3.6/urllib/request.py&quot;, line 1320, in do_open</div><div class="line">    raise URLError(err)</div><div class="line">urllib.error.URLError: &lt;urlopen error timed out&gt;</div></pre></td></tr></table></figure><p>在这里我们设置了超时时间是0.1秒，在0.1秒过后服务器依然没有响应，于是程序抛出了<code>urllib.error.URLError</code>异常，错误原因是timed out。<br>因此我们可以通过设置这个超时时间来控制一个网页如果长时间未响应就跳过它的抓取，利用try，except语句就可以实现这样的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request  </div><div class="line"><span class="keyword">import</span> socket  </div><div class="line"><span class="keyword">import</span> urllib.error  </div><div class="line"></div><div class="line"><span class="keyword">try</span>:  </div><div class="line">    response = urllib.request.urlopen(<span class="string">'http://httpbin.org/get'</span>,timeout=<span class="number">0.1</span>)  </div><div class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:  </div><div class="line">    <span class="keyword">if</span> isinstance(e.reason, socket.timeout):  </div><div class="line">        print(<span class="string">"Time out!"</span>)</div></pre></td></tr></table></figure><p>在这里我们请求了<a href="http://httpbin.org/get" target="_blank" rel="external">http://httpbin.org/get</a>这个测试链接，设置了超时时间是0.1秒，然后捕获了<code>urllib.error.URLError</code>这个异常，然后判断异常原因是超时异常，就得出它确实是因为超时而报错，打印输出了<code>TIME OUT</code>，当然你也可以在这里做其他的处理。<br>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Time out!</div></pre></td></tr></table></figure><p>常理来说，0.1秒内基本不可能得到服务器响应，因此输出了<code>TIME OUT</code>的提示。这样，我们可以通过设置 timeout这个参数来实现超时处理，有时还是很有用的。<br>其他参数还有context参数，它必须是<code>ssl.SSLContext</code>类型，用来指定SSL设置。cafile和capath两个参数是指定CA证书和它的路径，这个在请求HTTPS链接时会有用。cadefault参数现在已经弃用了，默认为False。<br>以上讲解了url.request.urlopen()方法的用法，通过这个最基本的函数可以完成简单的请求和网页抓取，如需详细了解，可以查看官方文档：<a href="https://docs.python.org/3/library/urllib.request.html" target="_blank" rel="external">https://docs.python.org/3/library/urllib.request.html</a></p><p><strong>urllib.request.Request()使用方法</strong></p><p>由上我们知道利用urlopen()方法可以实现最基本的请求发起，但这几个简单的参数并不足以构建一个完整的请求，如果请求中需要加入headers等信息，我们就可以利用更强大的Request类来构建一个请求。<br>首先我们用一个实例来感受一下Request的用法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request  </div><div class="line">  </div><div class="line">request = urllib.request.Request(<span class="string">"https://www.baidu.com"</span>)  </div><div class="line">response = urllib.request.urlopen(request)  </div><div class="line">print(response.read().decode(<span class="string">"utf-8"</span>))</div></pre></td></tr></table></figure><p>可以发现，我们依然是用urlopen()方法来发送这个请求，只不过这次urlopen()方法的参数不再是一个URL，而是一个Request，通过构造这个这个数据结构，一方面我们可以将请求独立成一个对象，另一方面一个请求可配置的参数将更加丰富和灵活。<br>下面我们看一下Request都可以通过怎样的参数来构造，它的构造方法如下：</p><p><code>urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None)</code></p><p>第一个参数是请求链接，这个是必传参数，其他的都是可选参数。<br>data参数如果要传必须传bytes(字节流)类型的，如果是一个字典，可以先用urllib.parse.urlencode()编码。<br>headers参数是一个字典，你可以在构造Request时通过headers参数传递，也可以通过调用Request对象的add_header()方法来添加请求头。<br>请求头最常用的用法就是通过修改User-Agent来伪装浏览器，默认的<code>User-Agent</code>是Python-urllib，你可以通过修改它来伪装成浏览器。<br>origin_req_host指的是请求方的host名称或是IP地址。<br>unverifiable指的是这个请求是否是无法验证的，默认是False。意思就是说用户没有足够权限来选择接收这个请求的结果。例如我们请求一个HTML文档中的图片，但是我们没有自动抓取图像的权限，这时unverifiable的值就是True。<br>method是一个字符串，它用来指示请求使用的方法，比如GET，POST，PUT等等。<br>下面我们传入多个参数构建一个Request来感受一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,parse  </div><div class="line">url = <span class="string">"http://httpbin.org/post"</span>  </div><div class="line"></div><div class="line">headers = &#123;  </div><div class="line">    <span class="string">"User-Agent"</span>:<span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'</span>, </div><div class="line">    <span class="string">"Host"</span>:<span class="string">'httpbin.org'</span>  </div><div class="line">&#125;  </div><div class="line">dict = &#123;  </div><div class="line">    <span class="string">"name"</span>:<span class="string">"Germey"</span>  </div><div class="line">&#125;  </div><div class="line">data = bytes(parse.urlencode(dict),encoding=<span class="string">"utf-8"</span>)  </div><div class="line">req = request.Request(url=url,data=data,headers=headers,method=<span class="string">"POST"</span>)  </div><div class="line">response = request.urlopen(req)  </div><div class="line">print(response.read().decode(<span class="string">"utf-8"</span>))</div></pre></td></tr></table></figure><p>在这里我们通过四个参数构造了一个Request，url即请求链接，在headers中指定了User-Agent 和Host，传递的参数data用了urlencode()和bytes()方法来转成字节流，另外指定了请求方式为POST。<br>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;args&quot;: &#123;&#125;,</div><div class="line">  &quot;data&quot;: &quot;&quot;,</div><div class="line">  &quot;files&quot;: &#123;&#125;,</div><div class="line">  &quot;form&quot;: &#123;</div><div class="line">    &quot;name&quot;: &quot;Germey&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;headers&quot;: &#123;</div><div class="line">    &quot;Accept-Encoding&quot;: &quot;identity&quot;,</div><div class="line">    &quot;Connection&quot;: &quot;close&quot;,</div><div class="line">    &quot;Content-Length&quot;: &quot;11&quot;,</div><div class="line">    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,</div><div class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;,</div><div class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;json&quot;: null,</div><div class="line">  &quot;origin&quot;: &quot;112.10.180.190&quot;,</div><div class="line">  &quot;url&quot;: &quot;http://httpbin.org/post&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过观察结果可以发现，我们成功设置了data，headers以及method参数，并完成了请求。<br>另外headers也可以用add_header()方法来添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">req = request.Request(url=url, data=data, method=&apos;POST&apos;)</div><div class="line">req.add_header(&apos;User-Agent&apos;, &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;)</div></pre></td></tr></table></figure><p>如此一来，我们就可以更加方便地构造一个Request，实现请求的发送。</p><p><strong>urllib.request高级特性</strong></p><p>在上面的过程中，我们虽然可以构造Request，但是一些更高级的操作，比如Cookies处理，代理该怎样来设置？<br>接下来就需要更强大的工具Handler登场了。<br>简而言之你可以把它理解为各种处理器，有专门处理登录验证的，有处理 Cookies 的，有处理代理设置的，利用它们我们几乎可以做到任何HTTP请求中所有的事情。<br>首先介绍下urllib.request.BaseHandler，它是所有其他Handler的父类，它提供了最基本的 Handler的方法，例如<code>efault_open()、protocol_request()</code>等。<br>接下来就有各种Handler类继承这个BaseHandler，列举如下： </p><ul><li>HTTPDefaultErrorHandler：用于处理HTTP响应错误，错误都会抛出HTTPError类型的异常。</li><li>HTTPRedirectHandler：用于处理重定向。</li><li>HTTPCookieProcessor：用于处理Cookie 。</li><li>ProxyHandler：用于设置代理，默认代理为空。</li><li>HTTPPasswordMgr：用于管理密码，它维护了用户名密码的表。</li><li>HTTPBasicAuthHandler：用于管理认证，如果一个链接打开时需要认证，那么可以用它来解决认证问题。</li></ul><blockquote><p>另外还有其他的Handler，可以参考官方文档：<a href="https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler" target="_blank" rel="external">https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler</a></p></blockquote><p>另外一个比较重要的就是OpenerDirector，我们可以称之为Opener，我们之前用过urllib.request.urlopen()这个方法，实际上它就是一个Opener。<br>那么为什么要引入Opener呢？因为我们需要实现更高级的功能，之前我们使用的Request、urlopen()相当于类库为你封装好了极其常用的请求方法，利用它们两个我们就可以完成基本的请求，但是现在不一样了，我们需要实现更高级的功能，所以我们需要深入一层，使用更上层的实例来完成我们的操作。所以，在这里我们就用到了比调用urlopen()的对象的更普遍的对象，也就是Opener。<br>Opener可以使用open()方法，返回的类型和urlopen()如出一辙。那么它和Handler有什么关系？简而言之，就是可以利用Handler来构建Opener。 </p><p><strong>认证</strong> </p><p>我们先用一个实例来感受一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request  </div><div class="line"></div><div class="line">auth_handler = urllib.request.HTTPBasicAuthHandler()  </div><div class="line">auth_handler.add_password(realm=<span class="string">'PDQ Application'</span>, uri=<span class="string">'https://mahler:8092/site-updates.py'</span>, user=<span class="string">'klem'</span>, passwd=<span class="string">'kadidd!ehopper'</span>)  </div><div class="line">opener = urllib.request.build_opener(auth_handler)  </div><div class="line">urllib.request.install_opener(opener)  </div><div class="line">urllib.request.urlopen(<span class="string">'http://www.example.com/login.html'</span>)</div></pre></td></tr></table></figure><p>此处代码为实例代码，用于说明Handler和Opener的使用方法。在这里，首先实例化了一个HTTPBasicAuthHandler对象，然后利用add_password()添加进去用户名和密码，相当于建立了一个处理认证的处理器。<br>接下来利用urllib.request.build_opener()方法来利用这个处理器构建一个Opener，那么这个Opener在发送请求的时候就具备了认证功能了。然后利用Opener的open()方法打开链接，就可以完成认证了。</p><p><strong>代理</strong></p><p>如果添加代理，可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request  </div><div class="line">proxy_handler = urllib.request.ProxyHandler(&#123;  </div><div class="line"><span class="string">'http'</span>: <span class="string">'http://218.202.111.10:80'</span>,  </div><div class="line"><span class="string">'https'</span>: <span class="string">'https://180.250.163.34:8888'</span>  </div><div class="line">&#125;)  </div><div class="line">opener = urllib.request.build_opener(proxy_handler)  </div><div class="line">response = opener.open(<span class="string">'https://www.baidu.com'</span>)  </div><div class="line">print(response.read())</div></pre></td></tr></table></figure><p>此处代码为实例代码，用于说明代理的设置方法，代理可能已经失效。</p><p>在这里使用了ProxyHandler，ProxyHandler的参数是一个字典，key是协议类型，比如HTTP还是HTTPS等，value是代理链接，可以添加多个代理。<br>然后利用build_opener()方法利用这个Handler构造一个Opener，然后发送请求即可。</p><p><strong>Cookies设置</strong></p><p>我们先用一个实例来感受一下怎样将网站的Cookie获取下来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> http.cookiejar, urllib.request </div><div class="line"> </div><div class="line">cookie = http.cookiejar.CookieJar()  </div><div class="line">handler = urllib.request.HTTPCookieProcessor(cookie)  </div><div class="line">opener = urllib.request.build_opener(handler)  </div><div class="line">response = opener.open(<span class="string">'http://www.baidu.com'</span>)  </div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> cookie:  </div><div class="line">    print(item.name+<span class="string">"="</span>+item.value)</div></pre></td></tr></table></figure><p>首先我们必须声明一个CookieJar对象，接下来我们就需要利用HTTPCookieProcessor来构建一个handler，最后利用build_opener方法构建出opener，执行open()即可。<br>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">BAIDUID=2B835BFCEDF4325F88D0C6C3A4EBD649:FG=1</div><div class="line">BIDUPSID=2B835BFCEDF4325F88D0C6C3A4EBD649</div><div class="line">H_PS_PSSID=1427_24569_21091_18559_25178</div><div class="line">PSTM=1512660072</div><div class="line">BDSVRTM=0</div><div class="line">BD_HOME=0</div></pre></td></tr></table></figure><p>可以看到输出了每一条Cookie的名称还有值。<br>不过既然能输出，那可不可以输出成文件格式呢？我们知道很多Cookie实际也是以文本形式保存的.<br>答案当然是肯定的，我们用下面的实例来感受一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> http.cookiejar, urllib.request</div><div class="line"></div><div class="line">filename = <span class="string">'cookie.txt'</span>  </div><div class="line">cookie = http.cookiejar.MozillaCookieJar(filename)  </div><div class="line">handler = urllib.request.HTTPCookieProcessor(cookie)  </div><div class="line">opener = urllib.request.build_opener(handler)  </div><div class="line">response = opener.open(<span class="string">'http://www.baidu.com'</span>)  </div><div class="line">cookie.save(ignore_discard=<span class="keyword">True</span>, ignore_expires=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><p>这时的CookieJar就需要换成MozillaCookieJar，生成文件时需要用到它，它是CookieJar的子类，可以用来处理Cookie和文件相关的事件，读取和保存Cookie，它可以将Cookie保存成Mozilla型的格式。<br>运行之后可以发现生成了一个cookie.txt文件。<br>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># Netscape HTTP Cookie File</div><div class="line"># http://curl.haxx.se/rfc/cookie_spec.html</div><div class="line"># This is a generated file!  Do not edit.</div><div class="line"></div><div class="line">.baidu.comTRUE/FALSE3660143901BAIDUID96CAB1FCD2CD9F4D304DE943A7018842:FG=1</div><div class="line">.baidu.comTRUE/FALSE3660143901BIDUPSID96CAB1FCD2CD9F4D304DE943A7018842</div><div class="line">.baidu.comTRUE/FALSEH_PS_PSSID1453_19034_21117_17001_25177</div><div class="line">.baidu.comTRUE/FALSE3660143901PSTM1512660254</div><div class="line">www.baidu.comFALSE/FALSEBDSVRTM0</div><div class="line">www.baidu.comFALSE/FALSEBD_HOME0</div></pre></td></tr></table></figure><p>另外还有一个LWPCookieJar，同样可以读取和保存Cookie，但是保存的格式和MozillaCookieJar的不一样，它会保存成与libwww-perl的Set-Cookie3文件格式的Cookie。<br>那么在声明时就改为<code>cookie = http.cookiejar.LWPCookieJar(filename)</code><br>生成的内容如下：由此看来生成的格式还是有比较大的差异的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#LWP-Cookies-2.0</div><div class="line">Set-Cookie3: BAIDUID=&quot;A84BFF86A8AACB4C3B4CD734F7D11193:FG=1&quot;; path=&quot;/&quot;; domain=&quot;.baidu.com&quot;; path_spec; domain_dot; expires=&quot;2085-12-25 18:40:37Z&quot;; version=0</div><div class="line">Set-Cookie3: BIDUPSID=A84BFF86A8AACB4C3B4CD734F7D11193; path=&quot;/&quot;; domain=&quot;.baidu.com&quot;; path_spec; domain_dot; expires=&quot;2085-12-25 18:40:37Z&quot;; version=0</div><div class="line">Set-Cookie3: H_PS_PSSID=25292_1433_24885_21104_18560_17001_25178_20930; path=&quot;/&quot;; domain=&quot;.baidu.com&quot;; path_spec; domain_dot; discard; version=0</div><div class="line">Set-Cookie3: PSTM=1512660390; path=&quot;/&quot;; domain=&quot;.baidu.com&quot;; path_spec; domain_dot; expires=&quot;2085-12-25 18:40:37Z&quot;; version=0</div><div class="line">Set-Cookie3: BDSVRTM=0; path=&quot;/&quot;; domain=&quot;www.baidu.com&quot;; path_spec; discard; version=0</div><div class="line">Set-Cookie3: BD_HOME=0; path=&quot;/&quot;; domain=&quot;www.baidu.com&quot;; path_spec; discard; version=0</div></pre></td></tr></table></figure><p>那么生成了Cookie文件，怎样从文件读取并利用呢？<br>下面我们以LWPCookieJar格式为例来感受一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> http.cookiejar, urllib.request</div><div class="line"></div><div class="line">cookie = http.cookiejar.LWPCookieJar()  </div><div class="line">cookie.load(<span class="string">'cookie.txt'</span>, ignore_discard=<span class="keyword">True</span>, ignore_expires=<span class="keyword">True</span>)  </div><div class="line">handler = urllib.request.HTTPCookieProcessor(cookie)  </div><div class="line">opener = urllib.request.build_opener(handler)  </div><div class="line">response = opener.open(<span class="string">'http://www.baidu.com'</span>)  </div><div class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</div></pre></td></tr></table></figure><p>前提是我们首先利用上面的方式生成了LWPCookieJar格式的Cookie，然后利用load()方法，传入文件名称，后面同样的方法构建handler和opener即可。<br>运行结果正常输出百度网页的源代码。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr><p>urllib是python3中写爬虫程序的得力助手，它很好，当然，也有比它更好的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;今天来说说python3内置的一个HTTP请求库，urllib。&lt;br&gt;官方文档：&lt;a href=&quot;https://docs.py
      
    
    </summary>
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python3之爬虫基本概念</title>
    <link href="http://yoursite.com/2017/12/07/Python3%E4%B9%8B%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2017/12/07/Python3之爬虫基本概念/</id>
    <published>2017-12-07T08:15:58.000Z</published>
    <updated>2017-12-14T13:45:56.324Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><hr><p>学了python也有一段时间了，这几天才开始去接触爬虫，再一次感叹python的强大。而爬虫是之前一直接触的名词，但自以为一直没有学好基础，就一直没有去接触，在这次在学习的过程中，终于揭开了它的面纱。</p><blockquote><p>爬虫，顾名思义，就是一只会爬行的虫子，如果把网络比喻成一张网，爬虫就是爬行在这张网上的小蜘蛛，网所及之处，都是它能到达的地方。顺到网页所在之处，获取需要的大量数据，就是爬虫的意义所在。简而言之，它就是一个能请求网站并提取其中的数据的自动化程序。</p></blockquote><h3 id="爬虫基本流程"><a href="#爬虫基本流程" class="headerlink" title="爬虫基本流程"></a>爬虫基本流程</h3><hr><ul><li>发起请求：通过HTTP库向目标站点发起请求，即发送一个Request，请求可以包含额外的headers、data等信息，等待服务器响应。</li><li>获取响应内容：如果服务器能正常响应，会得到一个Response，Response的内容便是所要获取的页面内容，类型可能有HTML，Json字符串，二进制数据（如图片视频）等类型。</li><li>解析内容：得到的内容可能是HTML，可以用正则表达式，网页解析库进行解析，可能是Json，可以直接转为Json对象解析，可能是二进制数据，可以做保存或者进一步的处理。</li><li>保存数据：保存形式多样，可以保存为文本，也可以保存至数据库，或者保存至数据库，或者保存特定格式的文件。</li></ul><p><strong>那么什么是Request和Response呢？</strong> </p><p>首先要了解一下HTTP协议，这里简单说一下。在HTTP协议中，请求访问文本或图像资源的一端称为客户端，而提供资源响应的一端称为服务器端。在我们用浏览器访问一个网页时，浏览器和远在云端的服务器其实就分别扮演着客户端和服务端的角色。<br><img src="/2017/12/07/Python3之爬虫基本概念/客户端和服务端.jpg" alt="图1"></p><ul><li>当浏览器发送消息给我们请求的网页所在的服务器时，这个过程就是HTTP Request。</li><li>服务器收到浏览器发送的消息后，能够根据浏览器发送消息的内容，采取相应处理，然后把消息传回给浏览器，这个过程叫做HTTP Response。</li><li>浏览器收到服务器的Response信息后，会对信息进行相应处理，然后展示。</li></ul><p><img src="/2017/12/07/Python3之爬虫基本概念/请求和响应.jpg" alt="图2"></p><p><strong>下面分别来看看Request和Response的内容</strong></p><ul><li>Request<ul><li>请求方式：主要有GET、POST两种请求类型，另外还有不常用的HEAD、PUT、DELETE、OPTIONS请求类型等。</li><li>请求URL：URL全称为统一资源定位符，它就像人们可以通过自己所在的地址来定位自己一样，URL通过资源所在的位置来唯一确定资源，如一个网页文档、一张图片、一个视频都能用URL来唯一确定。</li><li>请求头：Headers包含请求时所包含的头部信息，如User-Agent、Host、Cookies等信息。</li><li>请求体：请求时额外携带的数据，如在网页提交时需要提交表单信息data。</li></ul></li></ul><ul><li><p>Response</p><ul><li>响应状态：有多种表示响应状态的状态码，如200表示成功，301表示跳转，404表示找不到页面，502表示服务器发生错误。（2XX成功，3XX重定向，4XX客户端错误，5XX服务器错误）</li><li>响应头：如内容类型、内容长度、服务器信息、设置Cookies等。</li><li><p>响应体：这是Response种最重要的部分，包含了请求资源的内容，如网页的HTML、二进制信息图片视频等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line">html = requests.get(<span class="string">"http://www.baidu.com"</span>) <span class="comment">#一个普通的GET请求</span></div><div class="line">print(html.text) </div><div class="line">print(html.status_code) <span class="comment">#返回结果状态码</span></div></pre></td></tr></table></figure></li></ul></li></ul><p><strong>如何处理所得数据呢？（网页、图片、视频等其他数据）</strong></p><ul><li>话不多少，直接处理二进制数据。</li><li>用Json解析。</li><li>“只是用来写”的正则表达式。</li><li>BeautifulSoup，强大的python第三方解析库。</li><li>PyQuery、XPath等。</li></ul><p>当然，有时候我们通过HTTP访问库访问网页的结果与浏览器加载后所看到的不一样，这就涉及到了Javascript的渲染问题。可以通过分析Ajax请求、Selenium/WebDriver、Splash、PyV8和Ghost.py等来解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line"></div><div class="line">driver = webdriver.Chrome()</div><div class="line">driver.get(<span class="string">'http://www.taobao.com'</span>) <span class="comment">#可驱使Chrome浏览器去访问网页</span></div><div class="line">print(driver.page_source)</div></pre></td></tr></table></figure><p><strong>怎样保存数据呢？</strong></p><ol><li>文本：纯文本、Json、Xml等。</li><li>关系型数据库：如Mysql、Oracle、SQL Server等具有结构化表结构形式存储。</li><li>非关系型数据库：如MongoDB、Redis等Key-Value形式存储。</li><li>二进制文件：如图片、视频、音频等直接保存成特点格式即可。</li></ol><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><hr><p>基本概念就是这些了，HTTP协议想了解得更清楚一些的话可以去看看图解HTTP，另外用python写爬虫需要安装一些第三方库，可使用pip方法下载，以后再补充好啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;学了python也有一段时间了，这几天才开始去接触爬虫，再一次感叹python的强大。而爬虫是之前一直接触的名词，但自以为一直没有
      
    
    </summary>
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Markdown使用教程</title>
    <link href="http://yoursite.com/2017/10/30/Markdown/"/>
    <id>http://yoursite.com/2017/10/30/Markdown/</id>
    <published>2017-10-30T14:35:21.000Z</published>
    <updated>2017-10-31T08:45:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述✨"><a href="#简述✨" class="headerlink" title="简述✨"></a>简述✨</h3><hr><blockquote><p>Markdown 的目标是实现「易读易写」。<br>可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。<br>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像<em>强调</em>。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p></blockquote><p>以上文字引用自<a href="http://www.appinn.com/markdown/" target="_blank" rel="external">Markdown 语法说明(简体中文版)</a></p><p>显而易见，Markdown有以下优点：</p><ul><li>它是纯文本发布的，所以兼容性很强，可以用所有的文本编辑器打开并编写。</li><li>它让你更专注于文字的内容而不是无谓的排版。</li><li>它的格式转换方便，你可以轻松的将Markdown的文本转换为html、电子书等。</li><li>它的标记语法有极好的可读性。</li></ul><p>那就来学学吧🤔</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><hr><p>一篇文章都是从标题开始的，为了得到如上所示的标题，我们需要在Markdown编译器里输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">## 标题</div></pre></td></tr></table></figure><p><code>#</code>号之后记住要加上空格，<code>##</code>两个井号代表这是一个二级标题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 一级标题</div><div class="line">## 二级标题</div><div class="line">### 三级标题</div><div class="line">#### 四级标题</div><div class="line">##### 五级标题</div><div class="line">###### 六级标题</div></pre></td></tr></table></figure><p>现在看看其他标题的大小：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h2><hr><p>有时候我们想对文章的几个字或者一段话进行强调，那强调的一般方法就是加粗了。Markdown的粗体和斜体的表示非常简单，用一对<code>**</code>包含一段文字就是粗体的表示方法，用一对<code>*</code>包含一段文字就是斜体的表示方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">**看我是不是变粗啦**  *看我是不是变斜啦*</div></pre></td></tr></table></figure><p><strong>看我是不是变粗啦</strong> <em>看我是不是变斜啦</em></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><hr><p>列表分为无序列表和有序列表。在Markdown下，只要在文字前加上<code>-</code>或<code>*</code>即可变为无序列表，在文字前加上<code>1.</code> <code>2.</code> <code>3.</code>即可变为有序列表。<strong>划重点：要在符号和文字之间加上一个空格。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">* 一</div><div class="line">* 二</div><div class="line">* 三</div><div class="line"></div><div class="line">- 一</div><div class="line">- 二</div><div class="line">- 三</div><div class="line"></div><div class="line">1. 一</div><div class="line">2. 二</div><div class="line">3. 三</div></pre></td></tr></table></figure><ul><li>一</li><li>二</li><li>三</li></ul><ul><li>一</li><li>二</li><li>三</li></ul><ol><li>一</li><li>二</li><li>三</li></ol><p>也可以对列表进行嵌套：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* 第一部分</div><div class="line">    * 第一小节（一般嵌套是缩进是四个空格~）</div><div class="line">        * 第一小小节</div><div class="line">        * 第二小小节</div><div class="line">    * 第二小节</div></pre></td></tr></table></figure><ul><li>第一部分<ul><li>第一小节（一般嵌套是缩进是四个空格~）<ul><li>第一小小节</li><li>第二小小节</li></ul></li><li>第二小节</li></ul></li></ul><p><strong><code>*</code>可用<code>+</code> <code>-</code>替代。</strong></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><hr><p>文章中引用一段话也是很普遍的，就像本篇教程首段也引用了Markdown官方的宗旨。引用时，只需要在文字前加入<code>&gt;</code>大于号即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;你是我唯一想要的了解。——《七里香》</div></pre></td></tr></table></figure><blockquote><p>你是我唯一想要的了解。——《七里香》</p></blockquote><h2 id="插入链接和图片"><a href="#插入链接和图片" class="headerlink" title="插入链接和图片"></a>插入链接和图片</h2><hr><p>美观富有哲思的文章里少不了图片和链接。使用<code>[链接名称](链接地址)</code>的格式插入链接，图片与链接大部分相同，只是多在前面加了一个<code>!</code>,也就是使用<code>![图片名称](图片地址)</code>的格式插入图片。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[百度一下，你就知道](https://www.baidu.com/)</div><div class="line"></div><div class="line">![柚子](Markdown/favicon.ico)</div></pre></td></tr></table></figure><p><a href="https://www.baidu.com/" target="_blank" rel="external">百度一下，你就知道</a></p><p><img src="/2017/10/30/Markdown/favicon.ico" alt="柚子"></p><p><strong>描述图片位置的时候我使用了相对位置描述图片相对于我的这篇文章的位置。</strong></p><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><hr><p>为了清晰划分文章的层次，可以使用分隔线。使用连续三个<code>***</code>或<code>---</code>启用分隔线。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">***</div><div class="line"></div><div class="line">---</div></pre></td></tr></table></figure><hr><hr><p>如上所示👆</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><hr><p>身为一个程序员，在描述命令行或者代码块时，都可以使用Markdown优雅的引用代码框。</p><p>当只是引用少量的只是一行的代码时，可以用一对 反引号`包围代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`hexo server`</div></pre></td></tr></table></figure><p><code>hexo server</code></p><p>当引用数量较大的行数较多的代码时，可以用一对三个反引号`包围代码块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Hello</span><span class="params">()</span>:</span> </div><div class="line">print(<span class="string">"Hello World!"</span>)</div></pre></td></tr></table></figure><p>还可以直接将代码块缩进四个空格或一个制表符引入代码框（如果是在嵌套列表中进行缩进，是要缩进4×当前属于第几层嵌套，如果是第二层嵌套就应该是缩进八个空格，以此类推）：</p><pre><code>Hello World!</code></pre><p>贴上部分编写源码。</p><p><img src="/2017/10/30/Markdown/代码.png" alt="代码"></p><p>这里在三引号那里写入Python是为了表示所插入代码是Python语言编写的，这样可以使渲染引擎在此代码块区域对代码进行更好的渲染。<br>另外在使用三引号括起代码块或缩进引用代码框时，最好在代码块上下两行各空一行且三引号最好放在代码上下行，以防不可抗力因素。（单引号括起就不需要空行了，可直接内嵌在文字中。） </p><p><strong>PS：反引号是在英文模式下的~键打出来的。</strong></p><p><img src="/2017/10/30/Markdown/举例.png" alt="举例"></p><p>并且在hexo next主题渲染后发现单引号括起的代码只是简单的灰底，三引号括起的代码是带有序号的黑底代码框，四空格缩进的代码是无序号的黑底代码框，也许Markdown最终的显示跟渲染引擎有很大的关系吧…</p><h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><hr><ul><li><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">\   反斜线    </div><div class="line">`   反引号   </div><div class="line">*   星号     </div><div class="line">_   底线    </div><div class="line">&#123;&#125;  花括号   </div><div class="line">[]  方括号   </div><div class="line">()  括弧     </div><div class="line">#   井字号   </div><div class="line">+   加号</div><div class="line">-   减号</div><div class="line">.   英文句点</div><div class="line">!   惊叹号</div></pre></td></tr></table></figure></li><li><p>类似c语言的转义字符，满足<code>\特殊字符</code>的格式即可引用在文中了。</p></li><li>在写一篇文章时，我们往往想要在首行空两个空格，这时可以在段首加入<code>&amp;emsp;</code> <code>&amp;emsp;</code>来输入两个空格。</li><li>添加空行是可以结束先前的格式状态的，所以在想要改变格式，如插入列表或者引入代码框时，最好都添加一个空行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简述✨&quot;&gt;&lt;a href=&quot;#简述✨&quot; class=&quot;headerlink&quot; title=&quot;简述✨&quot;&gt;&lt;/a&gt;简述✨&lt;/h3&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;Markdown 的目标是实现「易读易写」。&lt;br&gt;可读性，无论如何，都是最重要的。一份使用 M
      
    
    </summary>
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
      <category term="Study" scheme="http://yoursite.com/tags/Study/"/>
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub+Mac安装教程</title>
    <link href="http://yoursite.com/2017/10/30/Hexo%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/10/30/Hexo安装教程/</id>
    <published>2017-10-30T06:17:58.000Z</published>
    <updated>2017-10-30T14:29:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr><p>其实这个博客用了半天就搭好了。<br>但是在主题和个人偏好设置方面真的是很痛苦，不断钻研最后才弄得算是拿得起台面了一些，现在分享一下我的经验。</p><p><strong>首先，什么是Hexo？什么是静态博客呢？</strong></p><blockquote><p>Hexo出自台湾大学生 tommy351 之手，是一个基于 Node.js 的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。</p></blockquote><p>而静态博客相较于动态博客，它编译之后是纯html页面，支持它的环境十分好找，如GitHub Pages；而选择在v、VPS上面搭建动态博客，这些VPS供应商往往是“免费的不稳定，稳定的不免费”。<br>那么，可以利用免费的资源搭载属于自己的稳定的个人博客，何乐而不为呢？</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><hr><ul><li><p><strong>安装Git</strong></p><ul><li>其实mac上只要安装了Xcode也就默认安装了git，这里就直接推荐各位去AppStore下载Xcode了，顺便配置一下即可👉<a href="https://itunes.apple.com/cn/app/xcode/id497799835?mt=12" target="_blank" rel="external">Xcode:在 Mac App Store 上的内容</a></li><li>另外推荐一下廖大的教程：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="external">廖雪峰git教程</a></li></ul></li></ul><ul><li><p><strong>安装Node.js</strong></p><ul><li>使用brew安装node.js，安装brew之前要先安装命令行工具，如果安装了Xcode也就不需要安装了，所以建议还是先直接安装Xcode吧…安装完Xcode之后按组合键：command+空格打开Spotlight搜索，输入终端打开终端。</li><li><p>安装Homebrew（终端粘贴如下代码即可）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure></li><li><p>安装完brew后，终端输入<code>brew install node</code>安装node.js即可。</p></li></ul></li></ul><ul><li><p><strong>安装Hexo</strong></p><ul><li>同理，在终端一行一行输入如下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g hexo    #下载安装Hexo。</div><div class="line">mkdir blog    #在当前位置新建blog文件夹。</div><div class="line">cd blog    #切换到blog目录。</div><div class="line">hexo init    #初始化。</div><div class="line">hexo generate    #生成静态文件。</div><div class="line">hexo server    #启动本地服务，进行文章预览调试。</div></pre></td></tr></table></figure></li></ul></li><li><p><strong>本地调试</strong></p><ul><li>现在打开<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>就能看到默认的Hexo界面了。</li><li>但是，这还不够，因为你想展示你的博客给所有人看，所以你还要将你的页面托管起来。</li></ul></li></ul><ul><li><p><strong>注册GitHub账号与配置SSH</strong></p><ul><li>参考教程<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374385852170d9c7adf13c30429b9660d0eb689dd43a000" target="_blank" rel="external">利用SSH建立远程链接</a></li></ul></li></ul><ul><li><p><strong>配置GitHub</strong></p><ul><li>建立Repository，建立与你用户名对应的仓库，仓库名必须为[your-name.github.io]，这是固定写法。</li><li><p>Spotlight搜索我们之前创建的blog文件夹，里面有_config.yml文件，打开找到deploy字段，修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/your-name/your-name.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></li><li><p>保存以上修改后在终端输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></li><li><p>成功后再执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo deploy</div></pre></td></tr></table></figure></li><li><p>然后在浏览器中输入<strong><a href="http://your-name.github.io/" target="_blank" rel="external">http://your-name.github.io/</a></strong>会发现你的博客可以通过这个网址打开了。</p></li></ul><p><strong>PS：记得把your-name改成你的github的账户名。</strong></p></li></ul><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><hr><ul><li><p><strong>博客部署</strong></p><ul><li><p>以后部署到GitHub Pages的步骤，可在终端按以下三步来进行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean    #清除缓存文件 (db.json) 和已生成的静态文件 (public)。 </div><div class="line">hexo generate    #生成静态页面至public目录。</div><div class="line">hexo deploy    #将生成的目录部署到GitHub上。</div></pre></td></tr></table></figure></li><li><p>当想在本地调试时，可以在终端切换到blog文件夹，使用<code>hexo server</code>命令启动服务器。默认情况下，访问网址为： <strong><a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a></strong>。即可预览产生的博客界面。</p></li><li>常用命令👇：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hexo new &quot;postname&quot;    #新建文章</div><div class="line">hexo new page &quot;pagename&quot;    #新建页面</div><div class="line">hexo help    #查看帮助</div><div class="line">hexo version    #查看Hexo的版本</div></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>博客主题</strong></p><ul><li>配置好博客后也许你会觉得你的博客界面并不靓丽，这就需要强大的主题了，可在以下三个链接中了解一下主题。</li><li><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="external">知乎：Hexo有哪些好看的主题？</a></li><li><a href="https://hexo.io/zh-cn/docs/themes.html" target="_blank" rel="external">主题 | Hexo</a></li><li>还有我现在用的主题 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">NexT | Pisces</a></li></ul></li></ul><ul><li><p><strong>主题配置</strong></p><ul><li>每个主题都是有文档对其进行详细的描述的，这里不细说，发掘配置也是搭建这个博客的乐趣所在哈。</li></ul></li></ul><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><hr><p>搭好并配置完这个博客的时候还是很开心的，像是将之前学的git、html和命令行知识进行了融会贯通一般。<br>小宝很可爱，JavaScript很有趣，Holen学长很cool，前端路漫漫，继续向前看吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;其实这个博客用了半天就搭好了。&lt;br&gt;但是在主题和个人偏好设置方面真的是很痛苦，不断钻研最后才弄得算是拿得起台面了一些，现在分享一
      
    
    </summary>
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="Study" scheme="http://yoursite.com/tags/Study/"/>
    
  </entry>
  
  <entry>
    <title>macOS常用命令</title>
    <link href="http://yoursite.com/2017/10/30/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2017/10/30/常用命令/</id>
    <published>2017-10-30T06:14:01.000Z</published>
    <updated>2017-10-30T14:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言✨"><a href="#前言✨" class="headerlink" title="前言✨"></a>前言✨</h3><hr><p><strong>先来讲讲macOS和Unix还有Linux的关系</strong></p><blockquote><p>Unix最早是在贝尔实验室开发的，是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统。为主要的工作站平台和重要的企业操作平台。它主要安装在巨型计算机、大型机上作为网络操作系统使用，也可用于个人计算机和嵌入式系统。曾经是服务器操作系统的首选。 </p><p>Linux是一类类Unix计算机操作系统的统称。Linux操作系统的内核的名字也是“Linux”。Linux操作系统也是自由软件和开放源代码发展中最著名的例子。严格来讲，Linux这个词本身只表示Linux内核，但在实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。Linux得名于计算机业余爱好者Linus Torvalds。一般可以认为，Linux是一套自由使用（一般可以免费使用）和自由传播的类Unix操作系统。这个系统是由世界各地成千上万的程序员设计和实现的。其目的是建立不受任何商品化软件的版权制约、全世界都能自由使用的Unix兼容产品。实际上，Linux仅仅的Linux操作系统中的核心（kernel）。</p><p>Mac系统是苹果机专用系统，是基于Unix内核的图形化操作系统，一般情况下在普通pc上无法安装的操作系统。</p></blockquote><p>所以说linux是兼容unix的，或者说是Linus写的一种开源的类unix系统，而macOS的内核其实就是unix。所以在同一种shell环境下，macOS和Linux的许多命令是共通的，这里所说的macOS常用命令其实就是兼容大部分Linux系统的终端命令。</p><h3 id="两种路径：绝对路径和相对路径"><a href="#两种路径：绝对路径和相对路径" class="headerlink" title="两种路径：绝对路径和相对路径"></a>两种路径：绝对路径和相对路径</h3><hr><p><strong>再来说说比较重要的路径</strong></p><p>绝对路径：完整描述一个文件的位置，总是以斜杠（<code>/</code>）（forward slash）开头。例如<code>/Users/michelle/Public/Drop Box</code>。<br>相对路径：只描述一部分位置信息，它和你在 command line 目前的目录有关。当你打开新的 Terminal 程序时，command line 会话的目录应该是你的 home folder。这时上面例子文件夹的相对路径写作<code>Public/Drop Box</code>。显然它从当前目录开始。和html类似，你也可以使用两个点（“<code>..</code>”）来代表父目录，这样你就可以用相对路径表示上级或同级目录了。例如你可以输入<code>cd ..</code>甚至<code>cd ../..</code>来返回上级目录。</p><h3 id="常用命令💻"><a href="#常用命令💻" class="headerlink" title="常用命令💻"></a>常用命令💻</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">ls     (list directory contents)列出当前目录的内容</div><div class="line">ls -l  列出当前目录文件详细信息l(list)</div><div class="line">ls -a  列出当前目录下所有文件及目录，包括隐藏的文件和目录(a=all)</div><div class="line"></div><div class="line">mkdir  创建目录</div><div class="line">mkdir -p  创建目录，若无父目录，则创建p(parent)  </div><div class="line">rmdir  删除目录(rmdir dir)</div><div class="line"></div><div class="line">cd     (change directory)改变当前目录到指定目录(cd .. 返回上一目录)</div><div class="line">touch  创建空文件，可touch test.txt或者touch 文件夹名/test.txt(在指定文件夹创建空文件)</div><div class="line">echo   创建带有内容的文件</div><div class="line">cat    查看文件内容</div><div class="line">cp     复制文件或目录(cp file1 file2)</div><div class="line">cp -r  复制目录内所有内容</div><div class="line">mv     改变文件名或移动其所在目录(mv file1 file2)</div><div class="line">mv -r  移动目录到另一目录(mv dir1 dir2)</div><div class="line">  </div><div class="line">rm     删除文件</div><div class="line">rm -r  递归删除，可删除子目录及文件</div><div class="line">rm -f  强制删除</div><div class="line">rm -rf 删除文件夹</div><div class="line">   </div><div class="line">pwd    (print working directory)显示当前目录的绝对路径</div><div class="line">vim    创建并编辑文件(先按i插入文字，完成后按esc再按：wq保存并退出)（esc :q! 放弃修改编辑内容直接退出）</div><div class="line"></div><div class="line">control+d    退出python3</div><div class="line">vim test.c    编写c文件</div><div class="line">gcc test.c    编译c文件</div><div class="line">./a.out    运行c文件</div><div class="line"></div><div class="line">control+C 中止一个错误的或者发疯的命令</div><div class="line">control+L 清屏</div><div class="line"></div><div class="line">Mac下常见vim的命令： </div><div class="line">1. 在默认的&quot;指令模式&quot;下按 i 进入编辑模式 </div><div class="line">2. 在非指令模式下按 ESC 返回指令模式 </div><div class="line">3. 在&quot;指令模式&quot;下输入: </div><div class="line"></div><div class="line">:w保存当前文件 </div><div class="line">:q 退出编辑,如果文件为保存需要用强制模式 </div><div class="line">:q!强制退出不保存修改 </div><div class="line">:wq组合指令, 保存并退出 </div><div class="line"></div><div class="line">4. 在“指令模式”下移动: </div><div class="line">h 左 </div><div class="line">j 下 </div><div class="line">k 上 </div><div class="line">l 右 </div><div class="line"></div><div class="line">shutdown</div><div class="line">    -r      关机重启</div><div class="line">    -h      关机不重启</div><div class="line">    now     立刻关机</div><div class="line">halt        关机</div><div class="line">reboot      重启</div><div class="line"></div><div class="line">find   在文件系统中搜索某文件</div><div class="line">wc     统计文本中行数、字数、字符数</div><div class="line">grep   在文本文件中查找某个字符串</div><div class="line">tree   树形结构显示目录，需要安装tree包</div><div class="line">ln     创建链接文件</div><div class="line">more、less   分页显示文本文件内容</div><div class="line">head、tail   显示文件头、尾内容</div><div class="line">ctrl+alt+F1  命令行全屏模式</div></pre></td></tr></table></figure><p>偶然看到这个博客，顺便贴上：<a href="https://www.renfei.org/blog/mac-os-x-terminal-101.html" target="_blank" rel="external">Mac OS X Terminal 101：终端使用初级教程</a></p><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言✨&quot;&gt;&lt;a href=&quot;#前言✨&quot; class=&quot;headerlink&quot; title=&quot;前言✨&quot;&gt;&lt;/a&gt;前言✨&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;先来讲讲macOS和Unix还有Linux的关系&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="命令" scheme="http://yoursite.com/categories/%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="Study" scheme="http://yoursite.com/tags/Study/"/>
    
  </entry>
  
  <entry>
    <title>Disneyland</title>
    <link href="http://yoursite.com/2017/10/25/Disneyland/"/>
    <id>http://yoursite.com/2017/10/25/Disneyland/</id>
    <published>2017-10-25T13:41:04.000Z</published>
    <updated>2017-10-30T14:28:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="✨Disneyland游玩攻略✨"><a href="#✨Disneyland游玩攻略✨" class="headerlink" title="✨Disneyland游玩攻略✨"></a>✨Disneyland游玩攻略✨</h1><hr><p><img src="/2017/10/25/Disneyland/Disneyland1.jpg" alt="Disneyland1"></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="420" height="86" src="//music.163.com/outchain/player?type=2&id=460578703&auto=1&height=66"></iframe><h3 id="简述🦄"><a href="#简述🦄" class="headerlink" title="简述🦄"></a>简述🦄</h3><hr><p>上海迪士尼乐园目前共分六个主题园区，分别是：<br>以米奇和他的欢乐伙伴们为主题设计的迎宾大道 — 米奇大街；<br>展现自然奇妙又充满想象力的花园设计主题区 — 奇想花园；<br>完美呈现迪士尼电影世界之 — 梦幻世界；<br>探寻神秘远古部落的冒险乐园 — 探险岛；<br>惊险热闹的海盗世界 — 宝藏湾；<br>科技打造的未来感满满的酷炫天地 — 明日世界。<br>（在建的第七个主题园区 — 玩具总动园 将于2018年开放)<br>除了遍布商店和餐馆的米奇大道外，每个园区都设置了与其主题相对应的游乐项目，各具特色，充满无穷的想象力和无尽的乐趣。除了亲身体验的游乐项目，各园区还有精心安排的表演秀，为你带来一场场视听盛宴。此外，各园区都有一些迪士尼经典人物形象出没，有专门的“与迪士尼朋友见面”环节，看到自己喜欢的卡通形象一定要记得合影留念哦。</p><h3 id="步骤🎃"><a href="#步骤🎃" class="headerlink" title="步骤🎃"></a>步骤🎃</h3><hr><ul><li>1 门票：抽奖得到了一张并低价向另一名中奖者买。</li><li>2 时间：工作日九点开园，节假日八点开园，最好提前40分钟，所以应该要7.20到。</li><li>3 物品：身份证，现金（要有硬币），雨伞（遮阳挡雨），充电宝，数据线，充电器，洗漱用品，舒服的鞋子，帽子，水杯，未开封的零食，雨衣（如果想玩雷鸣山漂流的话）。</li><li>4 网页：<a href="https://www.shanghaidisneyresort.com/" target="_blank" rel="external">迪士尼官网</a></li><li>5 APP: 导航软件(百度地图等)，迪士尼度假区app，乐拍通app（找准位置，安排行程很重要）。<br><img src="/2017/10/25/Disneyland/APP.jpg" alt="APP"></li><li>6 交通：迪士尼乐园在上海地铁11号线的终点站，交通方便。</li><li>7 酒店：迪士尼附近的酒店都很贵，其实找个地铁11号线沿线附近的酒店就可以了。</li></ul><blockquote><p><strong>PS：开封后的饮料、牛奶和自拍杆都不能带入院内。</strong></p></blockquote><h3 id="正篇☀️"><a href="#正篇☀️" class="headerlink" title="正篇☀️"></a>正篇☀️</h3><hr><p>入园后，记得拿好门票、乐园指南和时间表。门票用来取FP卡（快速通道卡），乐园指南里面有详细的地图和项目介绍，时间表用来查看各个演出的时间。左边右边米奇大道都不要停留，也不要被一进门被光鲜的玩具们拖慢了脚步。立刻飞奔向明日世界附近的游客中心领取创极速光轮的快速通行证才是最重要的！</p><p><strong>🌟一定要领 FP！领 FP！领 FP！重要的事说三遍！</strong></p><p><em>（当然如果人特别多的话就直接跑去排队，因为这时候排队拿卡一般只能排到下午的时间。）</em></p><p>FP卡在各区域的快速卡领取点领取，领取点可以在入园指南的地图里找。若有什么不懂的，可以直接问机器附近的工作人员。 </p><p>FP是高效玩转迪士尼的制胜法宝，一些热门景点经常要排队三四个小时，但是领了FP后，就可以在它指定的时间范围内直接去玩，不用排队。</p><p>由于一张门票一次只能领一张FP，一张FP只能作用于一个景点，所以建议不要浪费，还是用在创极速光轮或者飞跃地平线这种排队排到天荒地老的大项目上。<br>预约过FP后就要再过两个小时后才能预约下一个项目，这个时候如果想要预约第二个项目，就要看看有没有运气了。因为FP每天是有数量限制的，派完为止，一般中午后就领不到了。</p><blockquote><p>News：9月7日上海迪士尼度假区发布，将在今年秋季推出电子版快速通行证，只需下载官方app，走过入园闸机后使用app扫描关联门票或季卡，即可领取电子版快速通行证，无需再往来于游客服务中心。两次领取间隔为2小时，或前一张快速通行证已使用后才能领取第二张，先到先得，发完为止。<br>游客将能以更高效、灵活的方式享受迪士尼快速通行证服务，且无需额外付费。届时，游客可以通过上海迪士尼度假区官方手机应用程序（app）获取电子版迪士尼快速通行证，而无需匆忙地来往于指定的游客服务中心领取。游客在入园后，可把已激活的乐园门票与手机应用程序关联，按照提示进行浏览、选择及预约迪士尼快速通行证，并可随时查看快速通行证的使用时间。使用时，游客在选定景点的快速通行证入口扫描他们的手机或乐园门票上的二维码，在快速通行证以及与乐园门票相关联的游客照片验证成功后，游客便可快捷地体验景点。</p></blockquote><h3 id="划重点⚡️"><a href="#划重点⚡️" class="headerlink" title="划重点⚡️"></a>划重点⚡️</h3><hr><ol><li>FP不用再去游客中心排队领取了，也就是说进园后不必再不顾一切地向右跑了！</li><li>迪士尼快速通行证每日限量发行，不可转让。两次领取间隔为2小时，或前一张快速通行证已使用后才能领取第二张，先到先得，发完为止。也就是说使用你的FP在验票时一定要用关联本人的门票，其次，虽然不用再往右跑了，但激活门票后也要在app上拼手速抢热门项目的FP啊！而且要密切关注下一次领FP的时间。</li><li>FP变成了电子版，也就是说你不会再手持一张纸质版的快速通行证进行验票了，所有的FP都与你的门票相关联，走FP通道验票验的也是你的门票。</li><li>游客中心领FP的传统方法没有被废，如果你想，还是可以去那里领，在自助机器上扫描门票，电子版FP就被关联上了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FP能用的7个项目：</div><div class="line">    明日世界：创极速光轮⭐️、巴斯光年星际营救</div><div class="line">    探险岛：飞跃地平线⭐️、雷鸣山漂流</div><div class="line">    梦幻世界：小飞侠天空奇遇、七个小矮人矿山车、小熊维尼历险记 </div><div class="line">单人通道（人太多时可选择）：</div><div class="line">    创极速光轮、雷鸣山漂流、</div><div class="line">    加勒比海盗-沉落宝藏之战、七个小矮人矿山车</div></pre></td></tr></table></figure></li></ol><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;✨Disneyland游玩攻略✨&quot;&gt;&lt;a href=&quot;#✨Disneyland游玩攻略✨&quot; class=&quot;headerlink&quot; title=&quot;✨Disneyland游玩攻略✨&quot;&gt;&lt;/a&gt;✨Disneyland游玩攻略✨&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&lt;img src=
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Happy" scheme="http://yoursite.com/tags/Happy/"/>
    
      <category term="Disneyland" scheme="http://yoursite.com/tags/Disneyland/"/>
    
      <category term="Life" scheme="http://yoursite.com/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/10/21/hello-world/"/>
    <id>http://yoursite.com/2017/10/21/hello-world/</id>
    <published>2017-10-21T14:34:54.000Z</published>
    <updated>2017-10-30T14:28:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="命令" scheme="http://yoursite.com/categories/%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
      <category term="Study" scheme="http://yoursite.com/tags/Study/"/>
    
  </entry>
  
</feed>
